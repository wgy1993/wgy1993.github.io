<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wgy的博客</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wgy1993.gitee.io/"/>
  <updated>2020-06-01T05:39:23.856Z</updated>
  <id>https://wgy1993.gitee.io/</id>
  
  <author>
    <name>Wgy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hibernate(三)</title>
    <link href="https://wgy1993.gitee.io/archives/3e87eb50.html"/>
    <id>https://wgy1993.gitee.io/archives/3e87eb50.html</id>
    <published>2020-05-31T08:27:38.000Z</published>
    <updated>2020-06-01T05:39:23.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-多表设计"><a href="#1-多表设计" class="headerlink" title="1.    多表设计"></a>1.    多表设计</h1><h2 id="1-1-表之间的关系划分"><a href="#1-1-表之间的关系划分" class="headerlink" title="1.1    表之间的关系划分"></a>1.1    表之间的关系划分</h2><ul><li>一对一</li><li>一对多（多对一）</li><li>多对多</li></ul><h1 id="2-如何确立和实现数据库中的表关系"><a href="#2-如何确立和实现数据库中的表关系" class="headerlink" title="2.    如何确立和实现数据库中的表关系"></a>2.    如何确立和实现数据库中的表关系</h1><h2 id="2-1-一对多的表关系在数据库中如何实现"><a href="#2-1-一对多的表关系在数据库中如何实现" class="headerlink" title="2.1    一对多的表关系在数据库中如何实现?"></a>2.1    一对多的表关系在数据库中如何实现?</h2><p>使用外键约束。我们一般习惯把一的方称为主表，把多的一方称为从表。</p><a id="more"></a><p><strong>什么是外键：</strong></p><p>从表中有一列，该列的取值除了null之外，只能来源于主表的主键。默认情况下，外键字段的值是可以重复的。</p><h2 id="2-2-多对多的表关系在数据库中如何实现？"><a href="#2-2-多对多的表关系在数据库中如何实现？" class="headerlink" title="2.2    多对多的表关系在数据库中如何实现？"></a>2.2    多对多的表关系在数据库中如何实现？</h2><p>使用中间表。中间表中只有两个外键，引用两个多对多表的主键。不能有其他字段信息，至于中间表的主键，应该采用联合主键。</p><p>任何一个多方的表和中间表去比较，都是一对多的关系。</p><h2 id="2-3-一对一的表关系在数据库中如何实现？"><a href="#2-3-一对一的表关系在数据库中如何实现？" class="headerlink" title="2.3    一对一的表关系在数据库中如何实现？"></a>2.3    一对一的表关系在数据库中如何实现？</h2><p>有两种：</p><ul><li><p>第一种：建立外键的方式：</p><p>使用外键约束，唯一约束，非空约束。它是把外键字段加了非空和唯一约束。从而实现了一对一。</p></li><li><p>第二种：使用主键的方式：</p><p>让其中一张表既是主键，又是外键。</p></li></ul><h2 id="2-4-如何确立两张表之间的关系："><a href="#2-4-如何确立两张表之间的关系：" class="headerlink" title="2.4    如何确立两张表之间的关系："></a>2.4    如何确立两张表之间的关系：</h2><p>找外键。</p><h1 id="3-学习多表映射配置要遵循的步骤"><a href="#3-学习多表映射配置要遵循的步骤" class="headerlink" title="3.    学习多表映射配置要遵循的步骤"></a>3.    学习多表映射配置要遵循的步骤</h1><ul><li>第一步：确定两张表之间的关系</li><li>第二步：在数据库中实现两张表之间的关系建立</li><li>第三步：在实体类中描述出两个实体之间的关系</li><li>第四步：在映射配置文件中建立两个实体和两张表之间的关系</li></ul><h1 id="4-一对多关系映射配置"><a href="#4-一对多关系映射配置" class="headerlink" title="4.    一对多关系映射配置"></a>4.    一对多关系映射配置</h1><p>示例：客户和联系人两张表</p><h2 id="4-1-确定两张表之间的关系"><a href="#4-1-确定两张表之间的关系" class="headerlink" title="4.1    确定两张表之间的关系"></a>4.1    确定两张表之间的关系</h2><p>一个客户可以包含多个联系人，多个联系人可以属于同一个客户。所以：客户和联系人之间的关系是一对多。</p><h2 id="4-2-在数据库中实现两张表之间的关系建立"><a href="#4-2-在数据库中实现两张表之间的关系建立" class="headerlink" title="4.2    在数据库中实现两张表之间的关系建立"></a>4.2    在数据库中实现两张表之间的关系建立</h2><p>实现一对多的关系，靠外键。客户表是主表，联系人表是从表。我们需要在联系人表中添加外键。</p><p><img src="https://ae01.alicdn.com/kf/H64f49425b6ea4334b45df98958537583N.jpg" alt="img"></p><h2 id="4-3-在实体类中描述出两个实体之间的关系"><a href="#4-3-在实体类中描述出两个实体之间的关系" class="headerlink" title="4.3    在实体类中描述出两个实体之间的关系"></a>4.3    在实体类中描述出两个实体之间的关系</h2><p>主表的实体类应该包含从表实体类的集合引用，从表的实体类应该包含主表实体类的对象引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wgy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long custId;</span><br><span class="line">    <span class="keyword">private</span> String custName;</span><br><span class="line">    <span class="keyword">private</span> String custSource;</span><br><span class="line">    <span class="keyword">private</span> String custIndustry;</span><br><span class="line">    <span class="keyword">private</span> String custLevel;</span><br><span class="line">    <span class="keyword">private</span> String custAddress;</span><br><span class="line">    <span class="keyword">private</span> String custPhone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一对多关系映射：一的一方</span></span><br><span class="line"><span class="comment">     * 主表实体应该包含从表实体的集合引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;LinkMan&gt; linkmans = <span class="keyword">new</span> HashSet&lt;LinkMan&gt;(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 联系人的实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wgy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkMan</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long lkmId;</span><br><span class="line">    <span class="keyword">private</span> String lkmName;</span><br><span class="line">    <span class="keyword">private</span> String lkmGender;</span><br><span class="line">    <span class="keyword">private</span> String lkmPhone;</span><br><span class="line">    <span class="keyword">private</span> String lkmMobile;</span><br><span class="line">    <span class="keyword">private</span> String lkmEmail;</span><br><span class="line">    <span class="keyword">private</span> String lkmPosition;</span><br><span class="line">    <span class="keyword">private</span> String lkmMemo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一对多关系映射，多的一方。</span></span><br><span class="line"><span class="comment">     * 从表实体包含主表实体的对象引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-在映射配置文件中建立两个实体和两张表之间的关系"><a href="#4-4-在映射配置文件中建立两个实体和两张表之间的关系" class="headerlink" title="4.4    在映射配置文件中建立两个实体和两张表之间的关系"></a>4.4    在映射配置文件中建立两个实体和两张表之间的关系</h2><p>客户配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml导入约束：dtd约束 --&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">        &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt;</span><br><span class="line">    &lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot; lazy&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt;</span><br><span class="line">            &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;id&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- 一对多关系映射：主表实体的映射配置</span><br><span class="line">            涉及的标签：</span><br><span class="line">                set：</span><br><span class="line">                    作用：用于配置set集合属性。</span><br><span class="line">                    属性：</span><br><span class="line">                      name：指定实体类中set集合的属性名称。</span><br><span class="line">                      table：指定从表的名称。在一对多配置时可以不写。</span><br><span class="line">                key:</span><br><span class="line">                    作用：用于映射外键字段。</span><br><span class="line">                    属性：</span><br><span class="line">                      column：指定外键字段名称</span><br><span class="line">                one-to-many:</span><br><span class="line">                    作用：用于建立一对多的映射配置</span><br><span class="line">                    属性：</span><br><span class="line">                      class：用于指定从表实体的名称</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot;&gt;</span><br><span class="line">            &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt;</span><br><span class="line">            &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;set&gt;</span><br><span class="line">    &lt;&#x2F;class&gt;</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><p>联系人配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">        &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt;</span><br><span class="line">    &lt;class name&#x3D;&quot;LinkMan&quot; table&#x3D;&quot;cst_linkman&quot;&gt;</span><br><span class="line">        &lt;id name&#x3D;&quot;lkmId&quot; column&#x3D;&quot;lkm_id&quot;&gt;</span><br><span class="line">            &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;id&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;lkmName&quot; column&#x3D;&quot;lkm_name&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;lkmGender&quot; column&#x3D;&quot;lkm_gender&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;lkmPhone&quot; column&#x3D;&quot;lkm_phone&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;lkmMobile&quot; column&#x3D;&quot;lkm_mobile&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;lkmEmail&quot; column&#x3D;&quot;lkm_email&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;lkmPosition&quot; column&#x3D;&quot;lkm_position&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;lkmMemo&quot; column&#x3D;&quot;lkm_memo&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- 一对多关系映射：从表实体的映射配置</span><br><span class="line">                涉及的标签：</span><br><span class="line">                    many-to-one：</span><br><span class="line">                        作用：建立多对一的映射配置</span><br><span class="line">                        属性：</span><br><span class="line">                          name：从表实体中引用主表实体对象引用的名称</span><br><span class="line">                          class：指定属性所对应的实体类名称</span><br><span class="line">                          column：指定从表中外键字段的名称</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;class&gt;</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><h1 id="5-多对多关系映射配置"><a href="#5-多对多关系映射配置" class="headerlink" title="5.    多对多关系映射配置"></a>5.    多对多关系映射配置</h1><p>示例：用户和角色</p><h2 id="5-1-确定两张表之间的关系"><a href="#5-1-确定两张表之间的关系" class="headerlink" title="5.1    确定两张表之间的关系"></a>5.1    确定两张表之间的关系</h2><p>一个用户可以有多个角色，一个角色可以赋给多个用户，所以用户和角色之间是多对多。</p><h2 id="5-2-在数据库中实现两张表之间的关系建立"><a href="#5-2-在数据库中实现两张表之间的关系建立" class="headerlink" title="5.2    在数据库中实现两张表之间的关系建立"></a>5.2    在数据库中实现两张表之间的关系建立</h2><p>在数据库中实现多对多要靠中间表。中间表中只能出现用户和角色主键。</p><p><img src="https://ae01.alicdn.com/kf/H9827530ea7634df58ad9ee7616cfe92dq.jpg" alt="img"></p><h2 id="5-3-在实体类中描述出两个实体之间的关系"><a href="#5-3-在实体类中描述出两个实体之间的关系" class="headerlink" title="5.3    在实体类中描述出两个实体之间的关系"></a>5.3    在实体类中描述出两个实体之间的关系</h2><p>各自包含对方一个集合引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户的实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wgy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPassword;</span><br><span class="line">    <span class="keyword">private</span> Integer userState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多对多关系映射：一个用户可以具备多个角色</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;SysRole&gt; roles = <span class="keyword">new</span> HashSet&lt;SysRole&gt;(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 角色的实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wgy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysRole</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long roleId;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String roleMemo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多对多关系映射：一个角色可以赋予多个用户</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;SysUser&gt; users = <span class="keyword">new</span> HashSet&lt;SysUser&gt;(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-在映射配置文件中建立两个实体和两张表之间的关系"><a href="#5-4-在映射配置文件中建立两个实体和两张表之间的关系" class="headerlink" title="5.4    在映射配置文件中建立两个实体和两张表之间的关系"></a>5.4    在映射配置文件中建立两个实体和两张表之间的关系</h2><p>用户配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">        &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt;</span><br><span class="line">    &lt;class name&#x3D;&quot;SysUser&quot; table&#x3D;&quot;sys_user&quot;&gt;</span><br><span class="line">        &lt;id name&#x3D;&quot;userId&quot; column&#x3D;&quot;user_id&quot;&gt;</span><br><span class="line">            &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">        &lt;&#x2F;id&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;userName&quot; column&#x3D;&quot;user_name&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;userPassword&quot; column&#x3D;&quot;user_password&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;userState&quot; column&#x3D;&quot;user_state&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!-- 多对多关系映射</span><br><span class="line">                涉及的标签：</span><br><span class="line">                    set:</span><br><span class="line">                        作用：用于映射set集合属性</span><br><span class="line">                        属性：</span><br><span class="line">                            name：指定集合的名称</span><br><span class="line">                            table：指定的是中间表的名称</span><br><span class="line">                    key:</span><br><span class="line">                        作用：用于映射外键字段</span><br><span class="line">                        属性：</span><br><span class="line">                            column：指定的是当前实体在中间表的外键字段名称</span><br><span class="line">                    many-to-many</span><br><span class="line">                        作用：用于映射多对多的关系</span><br><span class="line">                        属性：</span><br><span class="line">                            class：对方的实体类名称</span><br><span class="line">                            column：对方在中间表的外键字段名称</span><br><span class="line">         --&gt;</span><br><span class="line">        &lt;set name&#x3D;&quot;roles&quot; table&#x3D;&quot;user_role_ref&quot;&gt;</span><br><span class="line">            &lt;key column&#x3D;&quot;user_id&quot;&gt;&lt;&#x2F;key&gt;</span><br><span class="line">            &lt;many-to-many class&#x3D;&quot;SysRole&quot; column&#x3D;&quot;role_id&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;set&gt;</span><br><span class="line">    &lt;&#x2F;class&gt;</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><p>角色配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">        &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt;</span><br><span class="line">    &lt;class name&#x3D;&quot;SysRole&quot; table&#x3D;&quot;sys_role&quot;&gt;</span><br><span class="line">        &lt;id name&#x3D;&quot;roleId&quot; column&#x3D;&quot;role_id&quot;&gt;</span><br><span class="line">            &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">        &lt;&#x2F;id&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;roleName&quot; column&#x3D;&quot;role_name&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;roleMemo&quot; column&#x3D;&quot;role_memo&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!-- 多对多关系映射 --&gt;</span><br><span class="line">        &lt;set name&#x3D;&quot;users&quot; table&#x3D;&quot;user_role_ref&quot; inverse&#x3D;&quot;true&quot;&gt;</span><br><span class="line">            &lt;key column&#x3D;&quot;role_id&quot;&gt;&lt;&#x2F;key&gt;</span><br><span class="line">            &lt;many-to-many class&#x3D;&quot;SysUser&quot; column&#x3D;&quot;user_id&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;set&gt;</span><br><span class="line">    &lt;&#x2F;class&gt;</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><h1 id="6-多表增删改操作"><a href="#6-多表增删改操作" class="headerlink" title="6.    多表增删改操作"></a>6.    多表增删改操作</h1><h2 id="6-1-一对多关系的操作"><a href="#6-1-一对多关系的操作" class="headerlink" title="6.1    一对多关系的操作"></a>6.1    一对多关系的操作</h2><h3 id="6-1-1-保存操作"><a href="#6-1-1-保存操作" class="headerlink" title="6.1.1    保存操作"></a>6.1.1    保存操作</h3><h4 id="6-1-1-1-正常保存"><a href="#6-1-1-1-正常保存" class="headerlink" title="6.1.1.1    正常保存"></a>6.1.1.1    正常保存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存操作</span></span><br><span class="line"><span class="comment"> * 正常的保存：创建一个新的联系人，需要关联一个客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1.查询一个客户</span></span><br><span class="line">    Customer c1 = s.get(Customer<span class="class">.<span class="keyword">class</span>, 1<span class="title">L</span>)</span>;</span><br><span class="line">    <span class="comment">//2.创建一个新的联系人</span></span><br><span class="line">    LinkMan l = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    l.setLkmName(<span class="string">"一对多的联系人"</span>);</span><br><span class="line">    <span class="comment">//3.建立客户和联系人的关联关系（让联系人知道属于哪个客户即可）</span></span><br><span class="line">    l.setCustomer(c1);</span><br><span class="line">    <span class="comment">//4.保存联系人</span></span><br><span class="line">    s.save(l);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-1-2-特殊情况"><a href="#6-1-1-2-特殊情况" class="headerlink" title="6.1.1.2    特殊情况"></a>6.1.1.2    特殊情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 特殊的情况：</span></span><br><span class="line"><span class="comment"> *  创建一个客户和一个联系人</span></span><br><span class="line"><span class="comment"> *  建立联系人和客户的双向关联关系</span></span><br><span class="line"><span class="comment"> *   使用符合原则的保存</span></span><br><span class="line"><span class="comment"> *   原则是：先保存主表实体，再保存从表实体</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  此时保存会有问题：</span></span><br><span class="line"><span class="comment"> *  我们保存两个实体，应该只有两条insert语句。</span></span><br><span class="line"><span class="comment"> *  而执行结果却是多了一条update的语句。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  解决办法：</span></span><br><span class="line"><span class="comment"> *  让客户在执行操作的时候，放弃维护关联关系的权利。</span></span><br><span class="line"><span class="comment"> *  配置的方式：</span></span><br><span class="line"><span class="comment"> *  在Customer的映射配置文件中的set标签上使用inverse属性。</span></span><br><span class="line"><span class="comment"> *  inverse含义：是否放弃维护关联关系的权利</span></span><br><span class="line"><span class="comment"> *  true：放弃</span></span><br><span class="line"><span class="comment"> *  false：不放弃（默认值）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个客户</span></span><br><span class="line">    <span class="comment">//瞬时态</span></span><br><span class="line">    Customer c1 = <span class="keyword">new</span> Customer();</span><br><span class="line">    c1.setCustName(<span class="string">"一对多的客户_4"</span>);</span><br><span class="line">    <span class="comment">//2.创建一个新的联系人</span></span><br><span class="line">    <span class="comment">//瞬时态</span></span><br><span class="line">    LinkMan l = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    l.setLkmName(<span class="string">"一对多的联系人_4"</span>);</span><br><span class="line">    <span class="comment">//3.建立客户和联系人的关联关系(双向)</span></span><br><span class="line">    l.setCustomer(c1);</span><br><span class="line">    c1.getLinkmans().add(l);</span><br><span class="line"></span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.保存，要符合原则</span></span><br><span class="line">    <span class="comment">//持久态  有一级缓存和快照</span></span><br><span class="line">    s.save(c1);</span><br><span class="line">    <span class="comment">//持久态    有一级缓存和快照</span></span><br><span class="line">    s.save(l);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot;&gt;</span><br><span class="line">    &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt;</span><br><span class="line">    &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure><h4 id="6-1-1-3-级联保存"><a href="#6-1-1-3-级联保存" class="headerlink" title="6.1.1.3    级联保存"></a>6.1.1.3    级联保存</h4><p>级联操作是指当主控方执行保存、更新或者删除操作时，其关联对象（被控方）也执行相同的操作。</p><p>保存客户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存操作：</span></span><br><span class="line"><span class="comment"> *  级联保存</span></span><br><span class="line"><span class="comment"> *  使用级联保存，配置的方式，仍然是找到Customer的映射配置文件的Set标签，</span></span><br><span class="line"><span class="comment"> *  也可以配置在many-to-one上。</span></span><br><span class="line"><span class="comment"> *  在上面加入cascade属性</span></span><br><span class="line"><span class="comment"> *  cascade：配置级联操作</span></span><br><span class="line"><span class="comment"> *  级联保存更新的取值：save-update</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个客户</span></span><br><span class="line">    <span class="comment">//瞬时态</span></span><br><span class="line">    Customer c1 = <span class="keyword">new</span> Customer();</span><br><span class="line">    c1.setCustName(<span class="string">"一对多的客户_5"</span>);</span><br><span class="line">    <span class="comment">//2.创建一个新的联系人</span></span><br><span class="line">    <span class="comment">//瞬时态</span></span><br><span class="line">    LinkMan l = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    l.setLkmName(<span class="string">"一对多的联系人_5"</span>);</span><br><span class="line">    <span class="comment">//3.建立客户和联系人的关联关系(双向)</span></span><br><span class="line">    l.setCustomer(c1);</span><br><span class="line">    c1.getLinkmans().add(l);</span><br><span class="line"></span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.保存，要符合原则</span></span><br><span class="line">    s.save(c1);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update&quot;&gt;</span><br><span class="line">    &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt;</span><br><span class="line">    &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure><p>保存联系人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个客户</span></span><br><span class="line">    <span class="comment">//瞬时态</span></span><br><span class="line">    Customer c1 = <span class="keyword">new</span> Customer();</span><br><span class="line">    c1.setCustName(<span class="string">"一对多的客户_6"</span>);</span><br><span class="line">    <span class="comment">//2.创建一个新的联系人</span></span><br><span class="line">    <span class="comment">//瞬时态</span></span><br><span class="line">    LinkMan l = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    l.setLkmName(<span class="string">"一对多的联系人_6"</span>);</span><br><span class="line">    <span class="comment">//3.建立客户和联系人的关联关系(双向)</span></span><br><span class="line">    l.setCustomer(c1);</span><br><span class="line">    c1.getLinkmans().add(l);</span><br><span class="line"></span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.保存，要符合原则</span></span><br><span class="line">    s.save(l);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-更新操作"><a href="#6-1-2-更新操作" class="headerlink" title="6.1.2    更新操作"></a>6.1.2    更新操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新操作</span></span><br><span class="line"><span class="comment"> *  需求：</span></span><br><span class="line"><span class="comment"> *      创建一个新的联系人，查询一个已有客户</span></span><br><span class="line"><span class="comment"> *      联系人新联系人和已有客户的双向关联关系</span></span><br><span class="line"><span class="comment"> *  更新客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1.查询一个客户</span></span><br><span class="line">    Customer c1 = s.get(Customer<span class="class">.<span class="keyword">class</span>, 1<span class="title">L</span>)</span>;</span><br><span class="line">    <span class="comment">//2.创建一个新的联系人</span></span><br><span class="line">    <span class="comment">//瞬时态</span></span><br><span class="line">    LinkMan l = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    l.setLkmName(<span class="string">"一对多的联系人"</span>);</span><br><span class="line">    <span class="comment">//3.建立客户和联系人的关联关系（双向）</span></span><br><span class="line">    l.setCustomer(c1);</span><br><span class="line">    c1.getLinkmans().add(l);</span><br><span class="line">    <span class="comment">//4.更新客户</span></span><br><span class="line">    s.update(c1);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-3-删除操作"><a href="#6-1-3-删除操作" class="headerlink" title="6.1.3    删除操作"></a>6.1.3    删除操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除操作</span></span><br><span class="line"><span class="comment"> *      删除从表数据就是单表</span></span><br><span class="line"><span class="comment"> *      删除主表数据：</span></span><br><span class="line"><span class="comment"> *     看有没有从表数据引用</span></span><br><span class="line"><span class="comment"> *     有引用：</span></span><br><span class="line"><span class="comment"> *         在删除是，hibernate会把从表中的外键字段置为null，然后再删除主表数据。</span></span><br><span class="line"><span class="comment"> * 如果外键字段有非空约束，则hibernate不能更新外键字段为null，会报错。</span></span><br><span class="line"><span class="comment"> * 如果仍然想删除，此时需要使用级联删除。同时必须配置inverse属性是true。</span></span><br><span class="line"><span class="comment"> *     没有引用： 就是单表，直接删</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1.查询一个客户</span></span><br><span class="line">    Customer c9 = s.get(Customer<span class="class">.<span class="keyword">class</span>, 5<span class="title">L</span>)</span>;</span><br><span class="line">    <span class="comment">//2.删除id为5的客户</span></span><br><span class="line">    s.delete(c9);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update,delete&quot;&gt;</span><br><span class="line">    &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt;</span><br><span class="line">    &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure><h2 id="6-2-多对多关系的操作"><a href="#6-2-多对多关系的操作" class="headerlink" title="6.2    多对多关系的操作"></a>6.2    多对多关系的操作</h2><h3 id="6-2-1-保存操作"><a href="#6-2-1-保存操作" class="headerlink" title="6.2.1    保存操作"></a>6.2.1    保存操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存操作</span></span><br><span class="line"><span class="comment"> *  需求：</span></span><br><span class="line"><span class="comment"> *      创建2个用户和3个角色</span></span><br><span class="line"><span class="comment"> *      让1号用户具备1号和2号角色</span></span><br><span class="line"><span class="comment"> *      让2号用户具备2号和3号角色</span></span><br><span class="line"><span class="comment"> *      保存用户和角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SysUser u1 = <span class="keyword">new</span> SysUser();</span><br><span class="line">    u1.setUserName(<span class="string">"用户1"</span>);</span><br><span class="line">    SysUser u2 = <span class="keyword">new</span> SysUser();</span><br><span class="line">    u2.setUserName(<span class="string">"用户2"</span>);</span><br><span class="line"></span><br><span class="line">    SysRole r1 = <span class="keyword">new</span> SysRole();</span><br><span class="line">    r1.setRoleName(<span class="string">"角色1"</span>);</span><br><span class="line">    SysRole r2 = <span class="keyword">new</span> SysRole();</span><br><span class="line">    r2.setRoleName(<span class="string">"角色2"</span>);</span><br><span class="line">    SysRole r3 = <span class="keyword">new</span> SysRole();</span><br><span class="line">    r3.setRoleName(<span class="string">"角色3"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立双向关联关系</span></span><br><span class="line">    <span class="comment">//先建立用户的</span></span><br><span class="line">    u1.getRoles().add(r1);</span><br><span class="line">    u1.getRoles().add(r2);</span><br><span class="line">    u2.getRoles().add(r2);</span><br><span class="line">    u2.getRoles().add(r3);</span><br><span class="line">    <span class="comment">//再建立角色</span></span><br><span class="line">    r1.getUsers().add(u1);</span><br><span class="line">    r2.getUsers().add(u1);</span><br><span class="line">    r2.getUsers().add(u2);</span><br><span class="line">    r3.getUsers().add(u2);</span><br><span class="line"></span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    s.save(u1);</span><br><span class="line">    s.save(u2);</span><br><span class="line">    s.save(r1);</span><br><span class="line">    s.save(r2);</span><br><span class="line">    s.save(r3);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-2-删除操作"><a href="#6-2-2-删除操作" class="headerlink" title="6.2.2    删除操作"></a>6.2.2    删除操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除操作</span></span><br><span class="line"><span class="comment"> * 实际开发中：多对多的双向级联删除是禁止使用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1查询id为3的用户</span></span><br><span class="line">    SysUser u3 = s.get(SysUser<span class="class">.<span class="keyword">class</span>, 3<span class="title">L</span>)</span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    s.delete(u3);</span><br><span class="line">    tx.commit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-Hibernate中的多表查询"><a href="#7-Hibernate中的多表查询" class="headerlink" title="7.    Hibernate中的多表查询"></a>7.    Hibernate中的多表查询</h1><h2 id="7-1-对象导航查询"><a href="#7-1-对象导航查询" class="headerlink" title="7.1    对象导航查询"></a>7.1    对象导航查询</h2><h3 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1    概述"></a>7.1.1    概述</h3><p>对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。</p><p>例如：我们通过OID查询方式查出一个客户，可以调用Customer类中的getLinkMans()方法来获取该客户的所有联系人。</p><p> 对象导航查询的使用要求是：两个对象之间必须存在关联关系。</p><h3 id="7-1-2-对象导航检索示例"><a href="#7-1-2-对象导航检索示例" class="headerlink" title="7.1.2    对象导航检索示例"></a>7.1.2    对象导航检索示例</h3><p>查询联系人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询id为1的客户下所属联系人</span></span><br><span class="line"><span class="comment"> * 一对多时，根据一的一方查询多的一方时，需要使用延迟加载。（默认配置即可）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//查询id为1的客户</span></span><br><span class="line">    Customer c = s.get(Customer<span class="class">.<span class="keyword">class</span>, 1<span class="title">L</span>)</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    Set&lt;LinkMan&gt; linkmans = c.getLinkmans();</span><br><span class="line">    System.out.println(linkmans);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询客户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询id为5的联系人属于哪个客户</span></span><br><span class="line"><span class="comment"> * 多对一时，根据多的一方查询一的一方时，不需要使用延迟加载，而是使用立即加载，需要配置一下</span></span><br><span class="line"><span class="comment"> * 需要找到联系人的映射配置文件：在many-to-one标签上使用lazy属性。</span></span><br><span class="line"><span class="comment"> *      取值有：</span></span><br><span class="line"><span class="comment"> *          false：使用立即加载。</span></span><br><span class="line"><span class="comment"> *          proxy：是看load方法是延迟加载还是立即加载</span></span><br><span class="line"><span class="comment"> *          no-proxy：不管</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    LinkMan l = s.get(LinkMan<span class="class">.<span class="keyword">class</span>, 5<span class="title">L</span>)</span>;</span><br><span class="line">    System.out.println(l);</span><br><span class="line">    Customer c = l.getCustomer();</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot; lazy&#x3D;&quot;false&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>load方法加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于load方法改为立即加载的方式</span></span><br><span class="line"><span class="comment"> *      找到查询实体的映射配置文件，它的class标签上也有一个lazy属性。含义是：是否延迟加载</span></span><br><span class="line"><span class="comment"> *          true：延迟加载(默认值)</span></span><br><span class="line"><span class="comment"> *          false：立即加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    Customer c = s.load(Customer<span class="class">.<span class="keyword">class</span>, 1<span class="title">L</span>)</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>class标签的lazy：它只能管load方法是否是延迟加载。</li><li>set标签的lazy：它管查询关联的集合对象是否是延迟加载。</li><li>many-to-one的lazy：它管查询关联的主表实体是否是立即加载。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-多表设计&quot;&gt;&lt;a href=&quot;#1-多表设计&quot; class=&quot;headerlink&quot; title=&quot;1.    多表设计&quot;&gt;&lt;/a&gt;1.    多表设计&lt;/h1&gt;&lt;h2 id=&quot;1-1-表之间的关系划分&quot;&gt;&lt;a href=&quot;#1-1-表之间的关系划分&quot; class=&quot;headerlink&quot; title=&quot;1.1    表之间的关系划分&quot;&gt;&lt;/a&gt;1.1    表之间的关系划分&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一对一&lt;/li&gt;
&lt;li&gt;一对多（多对一）&lt;/li&gt;
&lt;li&gt;多对多&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-如何确立和实现数据库中的表关系&quot;&gt;&lt;a href=&quot;#2-如何确立和实现数据库中的表关系&quot; class=&quot;headerlink&quot; title=&quot;2.    如何确立和实现数据库中的表关系&quot;&gt;&lt;/a&gt;2.    如何确立和实现数据库中的表关系&lt;/h1&gt;&lt;h2 id=&quot;2-1-一对多的表关系在数据库中如何实现&quot;&gt;&lt;a href=&quot;#2-1-一对多的表关系在数据库中如何实现&quot; class=&quot;headerlink&quot; title=&quot;2.1    一对多的表关系在数据库中如何实现?&quot;&gt;&lt;/a&gt;2.1    一对多的表关系在数据库中如何实现?&lt;/h2&gt;&lt;p&gt;使用外键约束。我们一般习惯把一的方称为主表，把多的一方称为从表。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Hibernate" scheme="https://wgy1993.gitee.io/tags/Hibernate/"/>
    
      <category term="ORM" scheme="https://wgy1993.gitee.io/tags/ORM/"/>
    
      <category term="框架" scheme="https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate(二)</title>
    <link href="https://wgy1993.gitee.io/archives/4074cb7b.html"/>
    <id>https://wgy1993.gitee.io/archives/4074cb7b.html</id>
    <published>2020-05-28T16:09:27.000Z</published>
    <updated>2020-06-01T05:39:23.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Hibernate的持久化类和对象标识符"><a href="#1-Hibernate的持久化类和对象标识符" class="headerlink" title="1.    Hibernate的持久化类和对象标识符"></a>1.    Hibernate的持久化类和对象标识符</h1><h2 id="1-1-持久化类的编写规范"><a href="#1-1-持久化类的编写规范" class="headerlink" title="1.1    持久化类的编写规范"></a>1.1    持久化类的编写规范</h2><h3 id="1-1-1-什么是持久化类"><a href="#1-1-1-什么是持久化类" class="headerlink" title="1.1.1    什么是持久化类"></a>1.1.1    什么是持久化类</h3><p>Hibernate是持久层的ORM映射框架，专注于数据的持久化工作。</p><ul><li>持久化就是将内存中的数据永久存储到关系型数据库中。</li><li>持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为是持久化类。其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。</li></ul><a id="more"></a><h3 id="1-1-2-持久化类的编写规范"><a href="#1-1-2-持久化类的编写规范" class="headerlink" title="1.1.2    持久化类的编写规范"></a>1.1.2    持久化类的编写规范</h3><p><strong>应该遵循JavaBean的编写规范:</strong></p><ul><li>Bean：在软件开发中是指的可重用的组件。</li><li>JavaBean：指的是用java语言编写的可重用组件。在我们的实际项目中：domain,service,dao都可以看成是JavaBean。</li></ul><p><strong>编写规范：</strong></p><ul><li>类都是public的</li><li>一般实现序列化接口</li><li>类成员（字段）都是私有的</li><li>私有类成员都有公有get/set方法</li><li>类都有默认无参构造函数</li></ul><p><strong>细节：</strong><br>        数据类型的选择问题：<br>        基本类型和包装类，选择哪个？由于包装类可以有null值。所以实际开发中都是用包装类。</p><h2 id="1-2-Hibernate中对象标识符（OID）"><a href="#1-2-Hibernate中对象标识符（OID）" class="headerlink" title="1.2    Hibernate中对象标识符（OID）"></a>1.2    Hibernate中对象标识符（OID）</h2><p>OID全称是Object Identifier，又叫做对象标识符。</p><p>它是hibernate用于区分两个对象是否是同一个对象的标识。</p><p>我们都知道，虚拟机内存区分两个对象看的是内存的地址是否一致。数据库区分两个对象，靠的是表的主键。Hibernate负责把内存中的对象持久化到数据库表中，靠的就是对象标识符来区分两个对象是否是同一个。实体类中映射主键的字段就是OID，如下图所示：</p><p><img src="https://ae01.alicdn.com/kf/Hdbe077ec86b3435789c33904d9afbaeeQ.jpg" alt="image-20200528202834139"></p><h2 id="1-3-Hibernate的主键生成策略"><a href="#1-3-Hibernate的主键生成策略" class="headerlink" title="1.3    Hibernate的主键生成策略"></a>1.3    Hibernate的主键生成策略</h2><p><img src="https://ae01.alicdn.com/kf/H953436512c2a464dab238f6f639b58f53.jpg" alt="image-20200528203024600"></p><h1 id="2-Hibernate的一级缓存和对象状态"><a href="#2-Hibernate的一级缓存和对象状态" class="headerlink" title="2.    Hibernate的一级缓存和对象状态"></a>2.    Hibernate的一级缓存和对象状态</h1><h2 id="2-1-Hibernate的一级缓存"><a href="#2-1-Hibernate的一级缓存" class="headerlink" title="2.1    Hibernate的一级缓存"></a>2.1    Hibernate的一级缓存</h2><p><strong>什么缓存？</strong></p><p>它就是内存中的临时数据。</p><p><strong>什么样的数据适用于缓存，什么样的数据不适用缓存？</strong></p><ul><li><p>适用缓存的数据：</p><p>经常查询的，并且不经常修改的。同时数据一旦出现问题，对最终结果影响不大的。</p></li><li><p>不适用缓存的数据：</p><p>不管是否经常查询，只要是经常修改的，都可以不用缓存。并且如果数据由于使用缓存，产生了异常数据，对最终结果影响很大，则不能使用。例如：股市的牌价，银行的汇率，商品的库存等等。</p></li></ul><h3 id="2-1-1-Hibernate中的一级缓存"><a href="#2-1-1-Hibernate中的一级缓存" class="headerlink" title="2.1.1    Hibernate中的一级缓存"></a>2.1.1    Hibernate中的一级缓存</h3><p>Hibernate的一级缓存就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。<strong>Hibernate的一级缓存的作用就是减少对数据库的访问次数</strong>。</p><p>在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存。只要 Session 实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。</p><p>Hibernate的一级缓存有如下特点：</p><ul><li>当应用程序调用Session接口的save()、update()、saveOrUpdate时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。</li><li>当调用Session接口的load()、get()方法，以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中。</li><li>当调用Session的close()方法时，Session缓存会被清空。</li></ul><h3 id="2-1-2-测试一级缓存"><a href="#2-1-2-测试一级缓存" class="headerlink" title="2.1.2    测试一级缓存"></a>2.1.2    测试一级缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 证明一级缓存确实存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1.根据id查询客户</span></span><br><span class="line">    <span class="comment">//先去数据库查询，并且把查询的结果存入了一级缓存之中</span></span><br><span class="line">    Customer c1 = s.get(Customer<span class="class">.<span class="keyword">class</span>, 1<span class="title">L</span>)</span>;</span><br><span class="line">    System.out.println(c1);</span><br><span class="line">    <span class="comment">//2.根据id再次查询客户</span></span><br><span class="line">    <span class="comment">//先去一级缓存中看看有没有，如果有的话，直接拿过来用，如果没有的话，再去查询。</span></span><br><span class="line">    Customer c2 = s.get(Customer<span class="class">.<span class="keyword">class</span>, 1<span class="title">L</span>)</span>;</span><br><span class="line">    System.out.println(c2);</span><br><span class="line">    <span class="comment">//true 一级缓存缓存的是对象的地址</span></span><br><span class="line">    System.out.println(c1 == c2);</span><br><span class="line">    tx.commit();</span><br><span class="line">    <span class="comment">//session关闭，一级缓存就消失了</span></span><br><span class="line">    s.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/H5078bb74071a4da0a7b3aa93ac35c15dn.jpg" alt="image-20200528204420329"></p><h3 id="2-1-3-快照机制"><a href="#2-1-3-快照机制" class="headerlink" title="2.1.3    快照机制"></a>2.1.3    快照机制</h3><p>Hibernate 向一级缓存放入数据时，同时复制一份数据放入到Hibernate快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1.根据id查询客户</span></span><br><span class="line">    Customer c5 = s.get(Customer<span class="class">.<span class="keyword">class</span>, 2<span class="title">L</span>)</span>;</span><br><span class="line">    <span class="comment">//输出客户的地址：北京市顺义区</span></span><br><span class="line">    System.out.println(c5.getCustAddress());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.修改客户的地址为  湖北省</span></span><br><span class="line">    c5.setCustAddress(<span class="string">"湖北省"</span>);</span><br><span class="line">    <span class="comment">//输出客户的地址：湖北省</span></span><br><span class="line">    System.out.println(c5.getCustAddress());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有写update语句</span></span><br><span class="line">    tx.commit();</span><br><span class="line">    <span class="comment">//session关闭，一级缓存就消失了</span></span><br><span class="line">    s.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印c5的address，这个c5能不能用   答案是可以使用。</span></span><br><span class="line">    <span class="comment">//此时输出是什么  北京市顺义区 | 湖北省</span></span><br><span class="line">    System.out.println(c5.getCustAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/H304b9e33b0fd404296da6d659b514d7d9.jpg" alt="image-20200528210754044"></p><h2 id="2-2-对象的状态"><a href="#2-2-对象的状态" class="headerlink" title="2.2    对象的状态"></a>2.2    对象的状态</h2><h3 id="2-2-1-对象的状态说明"><a href="#2-2-1-对象的状态说明" class="headerlink" title="2.2.1    对象的状态说明"></a>2.2.1    对象的状态说明</h3><p>Hibernate为了更好的来管理持久化类，特将持久化类分成了三种状态。在Hibernate中持久化的对象可以划分为四种状态，分别是瞬时态、持久态、脱管态和删除状态，一个持久化类的实例可能处于四种不同状态中的某一种，四种状态的详细介绍如下。</p><ol><li><p><strong>瞬时态（transient）</strong></p><p>瞬时态也称为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，<strong>不存在持久化标识OID（相当于主键值），尚未与Hibernate Session关联</strong>，在数据库中也没有记录，失去引用后将被JVM回收。瞬时状态的对象在内存中是孤立存在的，与数据库中的数据无任何关联，仅是一个信息携带的载体。</p></li><li><p><strong>持久态（persistent）</strong></p><p>持久态的对象<strong>存在持久化标识OID ，加入到了Session缓存中，并且相关联的Session没有关闭</strong>，在数据库中有对应的记录，每条记录只对应唯一的持久化对象，需要注意的是，持久态对象是在事务还未提交前变成持久态的。</p></li><li><p><strong>脱管态（detached）</strong></p><p>脱管态也称离线态或者游离态，当某个持久化状态的实例与Session的关联被关闭时就变成了脱管态。<strong>脱管态对象存在持久化标识OID，并且仍然与数据库中的数据存在关联，只是失去了与当前Session的关联</strong>，脱管状态对象发生改变时Hibernate不能检测到。</p></li><li><p><strong>删除状态（了解）</strong></p></li></ol><p><img src="https://ae01.alicdn.com/kf/Hd74ac1d004ad47f6bba94e92c76d5f40B.jpg" alt="image-20200528211757358"></p><h3 id="2-2-2-学习对象状态我们要明确的"><a href="#2-2-2-学习对象状态我们要明确的" class="headerlink" title="2.2.2    学习对象状态我们要明确的"></a>2.2.2    学习对象状态我们要明确的</h3><ol><li><p>是为了更好的掌握hibernate中操作的方法。</p></li><li><p>区分状态只有两个标识：一是否有OID，二是否和Session建立的关系</p><ul><li><p>瞬时状态（临时状态）</p><p>标志：没有OID，和Session没有关系。</p></li><li><p>持久化状态</p><p>标志：有OID，和Session有关系。只有持久化状态的对象才会有一级缓存的概念。</p></li><li><p>脱管状态（游离状态）</p><p>标志：有OID，和Session没有关系。</p></li><li><p>删除状态（了解）：</p><p>标志：有OID，和Session有关系。同时已经调用了删除方法，即将从数据库中把记录删除。但是事务还没有提交，此时的对象状态是删除态。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//瞬时状态</span></span><br><span class="line">    Customer c = <span class="keyword">new</span> Customer();</span><br><span class="line">    c.setCustName(<span class="string">"测试_saveOrUpdate"</span>);</span><br><span class="line">    Session s1 = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx1 = s1.beginTransaction();</span><br><span class="line">    s1.saveOrUpdate(c);</span><br><span class="line">    tx1.commit();</span><br><span class="line">    s1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s1 = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx1 = s1.beginTransaction();</span><br><span class="line">    <span class="comment">//持久化状态</span></span><br><span class="line">    Customer c = s1.get(Customer<span class="class">.<span class="keyword">class</span>, 9<span class="title">L</span>)</span>;</span><br><span class="line">    tx1.commit();</span><br><span class="line">    s1.close();</span><br><span class="line"></span><br><span class="line">    c.setCustAddress(<span class="string">"顺义校区"</span>);</span><br><span class="line">    <span class="comment">//脱管状态</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line"></span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">//持久化状态</span></span><br><span class="line">    session.saveOrUpdate(c);</span><br><span class="line">    tx.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-Hibernate的事务控制"><a href="#3-Hibernate的事务控制" class="headerlink" title="3.    Hibernate的事务控制"></a>3.    Hibernate的事务控制</h1><h2 id="3-1-配置Session和线程绑定"><a href="#3-1-配置Session和线程绑定" class="headerlink" title="3.1    配置Session和线程绑定"></a>3.1    配置Session和线程绑定</h2><p>保证在Service中开启的事务时使用的Session对象和DAO中多个操作使用的是同一个Session对象。</p><ol><li><p>在hibernate.cfg.xml文件中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure></li><li><p>获取Session时使用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽取hibernate的工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wgy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//了解：hibernate把可以预见的异常都转成了运行时异常</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">            configuration.configure();</span><br><span class="line">            factory = configuration.buildSessionFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExceptionInInitializerError e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">"初始化SessionFactory失败,请检查配置文件"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从当前线程上获取Session对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getCurrentSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//只有配置了把session和线程绑定之后，才能使用此方法，否则返回值是null</span></span><br><span class="line">        <span class="keyword">return</span> factory.getCurrentSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证session和线程绑定的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s1 = HibernateUtil.getCurrentSession();</span><br><span class="line">    Session s2 = HibernateUtil.getCurrentSession();</span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1 == s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当我们把session和线程绑定之后，hibernate就会在提交或者回滚事务之后，自动帮我们关闭session</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//瞬时状态</span></span><br><span class="line">    Customer c = <span class="keyword">new</span> Customer();</span><br><span class="line">    c.setCustName(<span class="string">"测试_getCurrentSession"</span>);</span><br><span class="line">    Session s1 = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx1 = s1.beginTransaction();</span><br><span class="line">    s1.saveOrUpdate(c);</span><br><span class="line">    tx1.commit();</span><br><span class="line">    <span class="comment">//s1.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="4-Hibernate中的查询方式"><a href="#4-Hibernate中的查询方式" class="headerlink" title="4.    Hibernate中的查询方式"></a>4.    Hibernate中的查询方式</h1><p>hibernate中一共有5种查询方式</p><ol><li><p>OID查询：</p><p>根据id查询一个实体。涉及的方法：get和load</p></li><li><p>SQL查询：</p><p>使用SQL语句查询数据库。涉及两种方式：</p><ul><li><p>第一种：SQLQuery（一般不怎么用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//使用session对象，获取一个查询对象Query</span></span><br><span class="line">    SQLQuery sqlquery = s.createSQLQuery(<span class="string">"select * from cst_customer"</span>);</span><br><span class="line">    <span class="comment">//使用sqlquery对象获取结果集</span></span><br><span class="line">    List&lt;Object[]&gt; list = sqlquery.list();</span><br><span class="line">    <span class="keyword">for</span> (Object[] os : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">"------------数组中的内容-----------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : os) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tx.commit();</span><br><span class="line">    s.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种：session的doWork方法，它可以拿到Connection</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hibernate中如何使用原始JDBC API</span></span><br><span class="line"><span class="comment"> * JDBC的API：</span></span><br><span class="line"><span class="comment"> * Connection</span></span><br><span class="line"><span class="comment"> * Statement</span></span><br><span class="line"><span class="comment"> * PreparedStatement</span></span><br><span class="line"><span class="comment"> * ResultSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.获取Session对象</span></span><br><span class="line">    Session s = HibernateUtil.openSession();</span><br><span class="line">    <span class="comment">//2.调用doWork方法</span></span><br><span class="line">    s.doWork(<span class="keyword">new</span> Work() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            System.out.println(conn.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>HQL查询：</p><p>使用HQL语句查询数据库</p></li><li><p>QBC查询：</p><p>使用Criteria对象查询数据库</p></li><li><p>对象导航查询：</p><p>对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。</p></li></ol><h1 id="5-Hibernate查询对象的API"><a href="#5-Hibernate查询对象的API" class="headerlink" title="5.    Hibernate查询对象的API"></a>5.    Hibernate查询对象的API</h1><h2 id="5-1-Query"><a href="#5-1-Query" class="headerlink" title="5.1    Query"></a>5.1    Query</h2><h3 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1    概述"></a>5.1.1    概述</h3><p>Query代表面向对象的一个Hibernate查询操作。</p><p>在Hibernate中，通常使用session.createQuery()方法接受一个HQL语句，然后调用Query的list()或uniqueResult()方法执行查询。</p><p>所谓的<strong>HQL</strong>是Hibernate Query Language缩写，其语法很像SQL语法，但它是完全面向对象的。</p><p>在Hibernate中使用Query对象的步骤，具体所示：</p><ol><li>获得Hibernate的Session对象</li><li>编写HQL语句</li><li>调用session.createQuery 创建查询对象</li><li>如果HQL语句包含参数，则调用Query的setXxx设置参数</li><li>调用Query对象的方法执行查询</li></ol><p>HQL的说明：</p><p>​           把表的名称换成实体类名称。把表字段名称换成实体类属性名称。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL：select * from cst_customer where cust_name like ?</span><br><span class="line"></span><br><span class="line">HQL：select * from Customer where custName &#x3D; ?</span><br><span class="line"></span><br><span class="line">其中select * 可以省略，写为：from Customer where custName &#x3D; ?</span><br></pre></td></tr></table></figure><h3 id="5-1-2-常用查询"><a href="#5-1-2-常用查询" class="headerlink" title="5.1.2    常用查询"></a>5.1.2    常用查询</h3><h4 id="5-1-2-1-基本查询"><a href="#5-1-2-1-基本查询" class="headerlink" title="5.1.2.1    基本查询"></a>5.1.2.1    基本查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line">    <span class="comment">//1.获取Query对象</span></span><br><span class="line">    Query query = session.createQuery(<span class="string">"from Customer"</span>);</span><br><span class="line">    <span class="comment">//2.获取结果集</span></span><br><span class="line">    List list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">    System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-2-条件查询"><a href="#5-1-2-2-条件查询" class="headerlink" title="5.1.2.2    条件查询"></a>5.1.2.2    条件查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 条件查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line">    <span class="comment">//1.获取Query对象</span></span><br><span class="line">    Query query = session.createQuery(<span class="string">"from Customer where custLevel = ?  and  custName like ?"</span>);</span><br><span class="line">    <span class="comment">//给参数占位符赋值 </span></span><br><span class="line">    <span class="comment">//hibernate的参数占位符是从0开始的</span></span><br><span class="line">    query.setString(<span class="number">0</span>, <span class="string">"23"</span>);</span><br><span class="line">    query.setString(<span class="number">1</span>, <span class="string">"%集%"</span>);</span><br><span class="line">    <span class="comment">//2.获取结果集</span></span><br><span class="line">    List list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 条件查询</span></span><br><span class="line"><span class="comment"> *  给参数占位符提供一个具体的名称</span></span><br><span class="line"><span class="comment"> *  参数占位符的写法：</span></span><br><span class="line"><span class="comment"> *  :名称</span></span><br><span class="line"><span class="comment"> *  赋值的时候不需要写冒号，直接写名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1.获取Query对象</span></span><br><span class="line">    Query query = s.createQuery(<span class="string">"from Customer where custName like :custName and custLevel = :custLevel"</span>);</span><br><span class="line">    <span class="comment">//2.给参数占位符赋值</span></span><br><span class="line">    <span class="comment">//query.setString("custName", "%集%");</span></span><br><span class="line">    <span class="comment">//query.setString("custLevel", "普通客户");</span></span><br><span class="line">    query.setParameter(<span class="string">"custLevel"</span>, <span class="string">"23"</span>);</span><br><span class="line">    query.setParameter(<span class="string">"custName"</span>, <span class="string">"%集%"</span>);</span><br><span class="line">    <span class="comment">//3.执行对象的方法，获取结果集</span></span><br><span class="line">    List list = query.list();</span><br><span class="line">    <span class="keyword">for</span>(Object o : list)&#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-3-分页查询"><a href="#5-1-2-3-分页查询" class="headerlink" title="5.1.2.3    分页查询"></a>5.1.2.3    分页查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询</span></span><br><span class="line"><span class="comment"> *  mysql分页关键字</span></span><br><span class="line"><span class="comment"> *  limit</span></span><br><span class="line"><span class="comment"> *  Limit的两个参数含义</span></span><br><span class="line"><span class="comment"> *  第一个：查询的开始记录索引</span></span><br><span class="line"><span class="comment"> *  第二个：每次查询的条数</span></span><br><span class="line"><span class="comment"> * hibernate为我们提供了两个方法：</span></span><br><span class="line"><span class="comment"> * setFirstResult：设置查询的开始记录索引</span></span><br><span class="line"><span class="comment"> * setMaxResults：设置每次查询的条数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不管是用什么数据库，涉及分页的都是这两个方法。</span></span><br><span class="line"><span class="comment"> * 因为SQL语句的生成已经是hibernate的事了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line">    <span class="comment">//1.获取Query对象</span></span><br><span class="line">    Query query = session.createQuery(<span class="string">"from Customer"</span>);</span><br><span class="line">    <span class="comment">//设置分页的方法</span></span><br><span class="line">    query.setFirstResult(<span class="number">2</span>);</span><br><span class="line">    query.setMaxResults(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//2.获取结果集</span></span><br><span class="line">    List list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-4-排序查询"><a href="#5-1-2-4-排序查询" class="headerlink" title="5.1.2.4    排序查询"></a>5.1.2.4    排序查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line">    <span class="comment">//1.获取Query对象</span></span><br><span class="line">    Query query = session.createQuery(<span class="string">"from Customer order by custId desc"</span>);</span><br><span class="line">    <span class="comment">//2.获取结果集</span></span><br><span class="line">    List list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-5-统计查询"><a href="#5-1-2-5-统计查询" class="headerlink" title="5.1.2.5    统计查询"></a>5.1.2.5    统计查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HQL使用聚合函数：</span></span><br><span class="line"><span class="comment"> *     统计查询</span></span><br><span class="line"><span class="comment"> * 聚合函数：</span></span><br><span class="line"><span class="comment"> *     count sum max min avg</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * sql语句使用聚合函数时，在不使用group by子句的情况下，返回的结果，永远只有一行一列的情况。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在SQL语句时：</span></span><br><span class="line"><span class="comment"> * select count(*) from table它是统计所有字段，效率没有只统计主键字段高</span></span><br><span class="line"><span class="comment"> * select count(主键) from table它和第一个的结果是一样的，但是效率更高</span></span><br><span class="line"><span class="comment"> * select count(非主键) from table只统计不为null的字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1.获取Query对象</span></span><br><span class="line">    Query query = s.createQuery(<span class="string">"select count(*) from Customer"</span>);</span><br><span class="line">    <span class="comment">//2.获取结果集</span></span><br><span class="line">    <span class="comment">//当返回的结果唯一时，可以使用此方法。如果返回的结果不唯一，使用了此方法会抛异常。</span></span><br><span class="line">    Long total = (Long)query.uniqueResult();</span><br><span class="line">    System.out.println(total);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-6-投影查询"><a href="#5-1-2-6-投影查询" class="headerlink" title="5.1.2.6    投影查询"></a>5.1.2.6    投影查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 投影查询</span></span><br><span class="line"><span class="comment"> * 当我们在查询实体时，只需要部分字段，而是全部。并且希望它的返回结果使用实体类来封装，而不是Object[]</span></span><br><span class="line"><span class="comment"> * 这个时候我们称之为创建实体类的投影</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 投影查询的用法：</span></span><br><span class="line"><span class="comment"> * 1.查询语句需要时使用new关键字</span></span><br><span class="line"><span class="comment"> * 2.在实体类中添加对应参数列表的构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line">    <span class="comment">//1.获取Query对象</span></span><br><span class="line">    Query query = session.createQuery(<span class="string">"select new com.wgy.domain.Customer(custId,custName) from Customer"</span>);</span><br><span class="line">    <span class="comment">//2.获取结果集</span></span><br><span class="line">    List list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wgy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long custId;</span><br><span class="line">    <span class="keyword">private</span> String custName;</span><br><span class="line">    <span class="keyword">private</span> String custSource;</span><br><span class="line">    <span class="keyword">private</span> String custIndustry;</span><br><span class="line">    <span class="keyword">private</span> String custLevel;</span><br><span class="line">    <span class="keyword">private</span> String custAddress;</span><br><span class="line">    <span class="keyword">private</span> String custPhone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //提供对应参数列表的构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> custId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> custName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Long custId, String custName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.custId = custId;</span><br><span class="line">        <span class="keyword">this</span>.custName = custName;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br></pre></td></tr></table></figure><h3 id="5-1-3-Query中的方法说明"><a href="#5-1-3-Query中的方法说明" class="headerlink" title="5.1.3    Query中的方法说明"></a>5.1.3    Query中的方法说明</h3><ul><li>list方法：该方法用于查询语句，返回的结果是一个list集合。</li><li>uniqueResult方法：该方法用于查询，返回的结果是一个Object对象。</li><li>setter方法：Query接口中提供了一系列的setter方法用于设置查询语句中的参数，针对不同的数据类型，需要用到不同的setter方法。</li><li>uniqueResult()方法：该方法用于返回唯一的结果，在确保只有一条记录的查询时可以使用该方法。</li><li>setFirstResult()方法：该方法可以设置获取第一个记录的位置，也就是它表示从第几条记录开始查询，默认从0开始计算。</li><li>setMaxResult()方法：该方法用于设置结果集的最大记录数，通常与setFirstResult()方法结合使用，用于限制结果集的范围，以实现分页功能。</li></ul><h2 id="5-2-Criteria"><a href="#5-2-Criteria" class="headerlink" title="5.2    Criteria"></a>5.2    Criteria</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1    概述"></a>5.2.1    概述</h3><p>Criteria是一个完全面向对象，可扩展的条件查询API，通过它完全不需要考虑数据库底层如何实现，以及SQL语句如何编写，它是Hibernate框架的核心查询对象。</p><p>Criteria 查询，又称为<strong>QBC</strong>查询（Query By Criteria），它是Hibernate的另一种对象检索方式。</p><p>通常，使用Criteria对象查询数据的主要步骤，具体如下：</p><ol><li>获得Hibernate的Session对象</li><li>通过Session获得Criteria对象</li><li>使用Restrictions的静态方法创建Criterion条件对象。Restrictions类中提供了一系列用于设定查询条件的静态方法，这些静态方法都返回Criterion实例，每个Criterion实例代表一个查询条件</li><li>向Criteria对象中添加Criterion 查询条件。Criteria的add()方法用于加入查询条件</li><li>执行Criterita的 list() 或uniqueResult() 获得结果</li></ol><p><strong>细节：</strong></p><p> HQL能查的，QBC都能查，反之亦然。</p><h3 id="5-2-2-常用查询"><a href="#5-2-2-常用查询" class="headerlink" title="5.2.2    常用查询"></a>5.2.2    常用查询</h3><h4 id="5-2-2-1-基本查询"><a href="#5-2-2-1-基本查询" class="headerlink" title="5.2.2.1    基本查询"></a>5.2.2.1    基本查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1. 获取Criteria对象</span></span><br><span class="line">    <span class="comment">//它就相当于HQL的from Customer</span></span><br><span class="line">    Criteria c = s.createCriteria(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//2. 获取结果集</span></span><br><span class="line">    List list = c.list();</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-2-条件查询"><a href="#5-2-2-2-条件查询" class="headerlink" title="5.2.2.2    条件查询"></a>5.2.2.2    条件查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 条件查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1. 获取Criteria对象</span></span><br><span class="line">    Criteria c = s.createCriteria(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//使用criteria对象的add方法来添加条件</span></span><br><span class="line">    c.add(Restrictions.eq(<span class="string">"custLevel"</span>, <span class="string">"23"</span>));</span><br><span class="line">    c.add(Restrictions.like(<span class="string">"custName"</span>, <span class="string">"%集%"</span>));</span><br><span class="line">    <span class="comment">//2. 获取结果集</span></span><br><span class="line">    List list = c.list();</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-3-分页查询"><a href="#5-2-2-3-分页查询" class="headerlink" title="5.2.2.3    分页查询"></a>5.2.2.3    分页查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询</span></span><br><span class="line"><span class="comment"> * QBC的分页查询和HQL的分页查询所用的方法和方法的含义都是一模一样的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1. 获取Criteria对象</span></span><br><span class="line">    Criteria c = s.createCriteria(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//设置分页条件</span></span><br><span class="line">    c.setFirstResult(<span class="number">2</span>);</span><br><span class="line">    c.setMaxResults(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//2. 获取结果集</span></span><br><span class="line">    List list = c.list();</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-4-排序查询"><a href="#5-2-2-4-排序查询" class="headerlink" title="5.2.2.4    排序查询"></a>5.2.2.4    排序查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1. 获取Criteria对象</span></span><br><span class="line">    Criteria c = s.createCriteria(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//添加排序</span></span><br><span class="line">    c.addOrder(Order.desc(<span class="string">"custId"</span>));</span><br><span class="line">    <span class="comment">//2. 获取结果集</span></span><br><span class="line">    List list = c.list();</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-5-统计查询"><a href="#5-2-2-5-统计查询" class="headerlink" title="5.2.2.5    统计查询"></a>5.2.2.5    统计查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计（投影）查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    <span class="comment">//1. 获取Criteria对象</span></span><br><span class="line">    Criteria c = s.createCriteria(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//设置聚合函数</span></span><br><span class="line">    <span class="comment">//c.setProjection(Projections.rowCount());</span></span><br><span class="line">    c.setProjection(Projections.count(<span class="string">"custId"</span>));</span><br><span class="line">    <span class="comment">//2. 获取结果集</span></span><br><span class="line">    Long count = (Long)c.uniqueResult();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-6-离线查询"><a href="#5-2-2-6-离线查询" class="headerlink" title="5.2.2.6    离线查询"></a>5.2.2.6    离线查询</h4><p><img src="https://ae01.alicdn.com/kf/H1af882e68622493f8061cbaa353dc9b2u.jpg" alt="image-20200528223420445"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 离线查询</span></span><br><span class="line"><span class="comment"> * 离线：</span></span><br><span class="line"><span class="comment"> *     它是和在线对应的。</span></span><br><span class="line"><span class="comment"> *     Criteria对象是一个在线对象，它是由一个可用的（活动的）Session对象获取的出来的。</span></span><br><span class="line"><span class="comment"> *     当session失效时，就无法再获取该对象了。</span></span><br><span class="line"><span class="comment"> *  有一个对象，它也可以用于设置条件，但是获取的时候并不需要Session对象。该对象就叫做离线对象：</span></span><br><span class="line"><span class="comment"> *  DetachedCriteria对象</span></span><br><span class="line"><span class="comment"> *      使用该对象进行的查询就叫做：离线查询</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何获取该对象</span></span><br><span class="line"><span class="comment"> * DetachedCriteria dCriteria = DetachedCriteria.forClass(要查询的实体类字节码);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.获取离线对象，不需要Session</span></span><br><span class="line">    DetachedCriteria dc = DetachedCriteria.forClass(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//2.封装查询条件</span></span><br><span class="line">    dc.add(Restrictions.eq(<span class="string">"custLevel"</span>, <span class="string">"23"</span>));</span><br><span class="line">    dc.add(Restrictions.like(<span class="string">"custName"</span>,<span class="string">"%集%"</span>));</span><br><span class="line"></span><br><span class="line">    List list = testService(dc);</span><br><span class="line">    <span class="keyword">for</span>(Object o : list)&#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List <span class="title">testService</span><span class="params">(DetachedCriteria dc)</span> </span>&#123;</span><br><span class="line">    Session s = <span class="keyword">null</span>;</span><br><span class="line">    Transaction tx  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        s = HibernateUtil.getCurrentSession();</span><br><span class="line">        tx = s.beginTransaction();</span><br><span class="line">        List list = testDao(dc);</span><br><span class="line">        tx.commit();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        tx.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List <span class="title">testDao</span><span class="params">(DetachedCriteria dc)</span> </span>&#123;</span><br><span class="line">    Session s = HibernateUtil.getCurrentSession();</span><br><span class="line">    <span class="comment">//把离线对象转成在线对象</span></span><br><span class="line">    Criteria c = dc.getExecutableCriteria(s);</span><br><span class="line">    <span class="keyword">return</span>  c.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-3-QBC常用查询条件说明"><a href="#5-2-3-QBC常用查询条件说明" class="headerlink" title="5.2.3    QBC常用查询条件说明"></a>5.2.3    QBC常用查询条件说明</h3><table><thead><tr><th>短语</th><th>含义</th></tr></thead><tbody><tr><td>Restrictions.eq</td><td>等于=</td></tr><tr><td>Restrictions.allEq</td><td>使用Map,使用key/value进行多个等于的判断</td></tr><tr><td>Restrictions.gt</td><td>大于&gt;</td></tr><tr><td>Restrictions.ge</td><td>大于等于&gt;=</td></tr><tr><td>Restrictions.lt</td><td>小于&lt;</td></tr><tr><td>Restrictions.le</td><td>小于等于&lt;=</td></tr><tr><td>Restrictions.between</td><td>对应sql的between子句</td></tr><tr><td>Restrictions.like</td><td>对应sql的like子句</td></tr><tr><td>Restrictions.in</td><td>对应sql的in子句</td></tr><tr><td>Restrictions.and</td><td>and 关系</td></tr><tr><td>Restrictions.or</td><td>or关系</td></tr><tr><td>Restrictions.sqlRestriction</td><td>Sql限定查询</td></tr><tr><td>Restrictions.asc()</td><td>根据传入的字段进行升序排序</td></tr><tr><td>Restrictions.desc()</td><td>根据传入的字段进行降序排序</td></tr></tbody></table><table>    <tr>        <th>运算类型</th>        <th>HQL运算符</th>        <th>QBC运算方法</th>      </tr >    <tr >        <td rowspan="7">type</td>        <td>=</td>        <td>Restrictions.eq()</td>    </tr>    <tr>        <td><></td>        <td>Restrictions.not(Restrictions.eq())</td>    </tr>    <tr>        <td>>=</td>        <td>Restrictions.ge()</td>    </tr>    <tr>        <td><</td>        <td>Restrictions.lt()</td>    </tr>    <tr>        <td><=</td>        <td>Restrictions.le()</td>    </tr>    <tr>        <td>is null</td>        <td>Restrictions.isNull()</td>    </tr>    <tr>        <td>is not null</td>        <td>Restrictions.isNotNull()</td>    </tr>    <tr>        <td rowspan="4">范围运算符</td>        <td>in</td>        <td>Restrictions.in()</td>    </tr>    <tr>        <td >not in</td>        <td>Restrictions.not(Restrictions.in())</td>    </tr>    <tr>        <td>between</td>        <td>Restrictions.between()</td>    </tr>    <tr>        <td >not between</td>        <td >Restrictions.not(Restrictions.between())</td>    </tr></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Hibernate的持久化类和对象标识符&quot;&gt;&lt;a href=&quot;#1-Hibernate的持久化类和对象标识符&quot; class=&quot;headerlink&quot; title=&quot;1.    Hibernate的持久化类和对象标识符&quot;&gt;&lt;/a&gt;1.    Hibernate的持久化类和对象标识符&lt;/h1&gt;&lt;h2 id=&quot;1-1-持久化类的编写规范&quot;&gt;&lt;a href=&quot;#1-1-持久化类的编写规范&quot; class=&quot;headerlink&quot; title=&quot;1.1    持久化类的编写规范&quot;&gt;&lt;/a&gt;1.1    持久化类的编写规范&lt;/h2&gt;&lt;h3 id=&quot;1-1-1-什么是持久化类&quot;&gt;&lt;a href=&quot;#1-1-1-什么是持久化类&quot; class=&quot;headerlink&quot; title=&quot;1.1.1    什么是持久化类&quot;&gt;&lt;/a&gt;1.1.1    什么是持久化类&lt;/h3&gt;&lt;p&gt;Hibernate是持久层的ORM映射框架，专注于数据的持久化工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持久化就是将内存中的数据永久存储到关系型数据库中。&lt;/li&gt;
&lt;li&gt;持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为是持久化类。其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Hibernate" scheme="https://wgy1993.gitee.io/tags/Hibernate/"/>
    
      <category term="ORM" scheme="https://wgy1993.gitee.io/tags/ORM/"/>
    
      <category term="框架" scheme="https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate(一)</title>
    <link href="https://wgy1993.gitee.io/archives/ef455019.html"/>
    <id>https://wgy1993.gitee.io/archives/ef455019.html</id>
    <published>2020-05-28T06:17:43.000Z</published>
    <updated>2020-06-01T05:39:23.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Hibernate和ORM的概念"><a href="#1-Hibernate和ORM的概念" class="headerlink" title="1.    Hibernate和ORM的概念"></a>1.    Hibernate和ORM的概念</h1><h2 id="1-1-Hibrenate概述"><a href="#1-1-Hibrenate概述" class="headerlink" title="1.1    Hibrenate概述"></a>1.1    Hibrenate概述</h2><p>它是一个轻量级，企业级，开源的ORM持久层框架。是可以操作数据库的框架。</p><ul><li>框架：它就是一个架构。</li><li>通常情况下，软件工程的持久层解决方案，一个为主一个为辅。两者并存（写SQL语句的和不写SQL语句的</li><li>轻量级：指的是使用时依赖的资源很少。（目前我们使用的阶段，只依赖log4j，c3p0连接池）</li><li>企业级：指的是在企业级应用中使用的比较多</li><li>开源的：开放源代码。</li><li>ORM的操作方式：建立对象关系映射，实现操作实体类就相当于操作数据库表。</li></ul><a id="more"></a><blockquote><p>Hibernate框架是当今主流的Java持久层框架之一，由于它具有简单易学、灵活性强、扩展性强等特点，能够大大地简化程序的代码量，提高工作效率，因此受到广大开发人员的喜爱。</p><p>Hibernate是一个开放源代码的ORM框架，它对JDBC进行了轻量级的对象封装，使得Java开发人员可以使用面向对象的编程思想来操作数据库。</p></blockquote><h2 id="1-2-ORM"><a href="#1-2-ORM" class="headerlink" title="1.2    ORM"></a>1.2    ORM</h2><p>Object Relational Mapping</p><ul><li>对象关系映射</li><li>就是建立实体类和数据库表的对应关系。</li><li>实现操作实体类对象就相当于操作数据库表</li></ul><blockquote><p>Object Relation Mapping 对象关系映射。</p><p>对象-关系映射（OBJECT/RELATIONALMAPPING，简称ORM），是随着面向对象的<a href="http://baike.baidu.com/view/1471861.htm" target="_blank" rel="noopener">软件开发方法</a>发展而产生的。用来把对象模型表示的对象映射到基于S Q L 的关系模型数据库结构中去。这样，我们在具体的操作实体对象的时候，就不需要再去和复杂的 SQ L 语句打交道，只需简单的操作实体对象的属性和方法[2] 。O R M 技术是在对象和关系之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化[1] 。</p><p><strong>简单的说就是把我们程序中的实体类和数据库表建立起来对应关系。</strong></p></blockquote><h2 id="1-3-为什么要学习Hibernate"><a href="#1-3-为什么要学习Hibernate" class="headerlink" title="1.3    为什么要学习Hibernate"></a>1.3    为什么要学习Hibernate</h2><p>与其它操作数据库的技术相比，Hibernate具有以下几点优势：</p><ul><li>Hibernate对JDBC访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率。</li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了DAO（Data Access Object，数据访问对象）层编码工作。</li><li>Hibernate的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。</li><li>可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。</li></ul><p><strong>明确：</strong></p><p>​    <strong>操作实体类就相当于操作数据库表</strong></p><blockquote><p>使用传统的JDBC开发应用系统时，如果是小型应用系统，并不觉得有什么麻烦，但是对于大型应用系统的开发，使用JDBC就会显得力不从心。例如对几十、几百张包含几十个字段的表进行插入操作时，编写的SQL语句不但很长，而且繁琐，容易出错；在读取数据时，需要写多条getXxx语句从结果集中取出各个字段的信息，不但枯燥重复，并且工作量非常大。为了提高数据访问层的编程效率，Gavin King开发出了一个当今最流行的的ORM框架，它就是Hibernate框架。</p><p>所谓的ORM就是利用描述对象和数据库表之间映射的元数据，自动把Java应用程序中的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库表的操作。可以把ORM理解为关系型数据和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。ORM原理如图所示。</p><p><img src="https://ae01.alicdn.com/kf/Hce6689de20a94fa09b8b22db035878ddF.jpg" alt="img"></p></blockquote><h1 id="2-CRM"><a href="#2-CRM" class="headerlink" title="2.    CRM"></a>2.    CRM</h1><p>CRM：客户关系管理系统</p><blockquote><p>CRM（Customer Relationship Management）客户关系管理，是利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，向客户提供创新式的个性化的客户交互和服务的过程。</p><p>其最终目标是将面向客户的各项信息和活动集成起来，组建一个以客户为中心的企业，实现对面向客户的活动的全面管理。</p></blockquote><h1 id="3-Hibernate快速入门"><a href="#3-Hibernate快速入门" class="headerlink" title="3.    Hibernate快速入门"></a>3.    Hibernate快速入门</h1><h2 id="3-1-需求介绍"><a href="#3-1-需求介绍" class="headerlink" title="3.1    需求介绍"></a>3.1    需求介绍</h2><p>保存一个客户到数据库的客户表中。</p><h2 id="3-2-搭建Hibernate开发环境"><a href="#3-2-搭建Hibernate开发环境" class="headerlink" title="3.2    搭建Hibernate开发环境"></a>3.2    搭建Hibernate开发环境</h2><h3 id="3-2-1-第一步：拷贝必备的jar包到开发目录"><a href="#3-2-1-第一步：拷贝必备的jar包到开发目录" class="headerlink" title="3.2.1    第一步：拷贝必备的jar包到开发目录"></a>3.2.1    第一步：拷贝必备的jar包到开发目录</h3><p>数据库驱动包，如下图：</p><p><img src="https://ae01.alicdn.com/kf/H42f3639350de4c93b6ea7af89ff4e03eg.jpg" alt="image-20200528110301508"></p><p>Hibernate/lib/required/*.jar，如下图：</p><p><img src="https://ae01.alicdn.com/kf/H235e8a817a344ae88666f2481d83a670J.jpg" alt="image-20200528110244430"></p><p>日志记录的包，如下图:</p><p><img src="https://ae01.alicdn.com/kf/H3d632a5388b445b6a0ecacd24cdbfe2fD.jpg" alt="image-20200528110345308"></p><h3 id="3-2-2-第二步：创建数据库和实体类"><a href="#3-2-2-第二步：创建数据库和实体类" class="headerlink" title="3.2.2    第二步：创建数据库和实体类"></a>3.2.2    第二步：创建数据库和实体类</h3><p>持久化类是应用程序中的业务实体类，这里的持久化是指类的对象能够被持久化保存到数据库中。Hibernate使用普通Java对象（Plain Old Java Object），即POJO的编程模式来进行持久化。POJO类中包含的是与数据库表相对应的各个属性，这些属性通过getter和setter方法来访问，对外部隐藏了内部的实现细节。下面就来编写Customer持久化类。</p><p>在项目src目录下，创建cn.wgy.domain包，并在包中创建实体类Customer（对应数据库表cst_customer），Customer类包含与cst_customer数据表字段对应的属性，以及相应的getXxx ()和setXxx ()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*创建客户表*&#x2F;</span><br><span class="line">CREATE TABLE &#96;cst_customer&#96; (</span><br><span class="line">  &#96;cust_id&#96; bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#39;客户编号(主键)&#39;,</span><br><span class="line">  &#96;cust_name&#96; varchar(32) NOT NULL COMMENT &#39;客户名称(公司名称)&#39;,</span><br><span class="line">  &#96;cust_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户信息来源&#39;,</span><br><span class="line">  &#96;cust_industry&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户所属行业&#39;,</span><br><span class="line">  &#96;cust_level&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户级别&#39;,</span><br><span class="line">  &#96;cust_address&#96; varchar(128) DEFAULT NULL COMMENT &#39;客户联系地址&#39;,</span><br><span class="line">  &#96;cust_phone&#96; varchar(64) DEFAULT NULL COMMENT &#39;客户联系电话&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;cust_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;94 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wgy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long custId;</span><br><span class="line">    <span class="keyword">private</span> String custName;</span><br><span class="line">    <span class="keyword">private</span> String custSource;</span><br><span class="line">    <span class="keyword">private</span> String custIndustry;</span><br><span class="line">    <span class="keyword">private</span> String custLevel;</span><br><span class="line">    <span class="keyword">private</span> String custAddress;</span><br><span class="line">    <span class="keyword">private</span> String custPhone;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-第三步：编写映射配置文件（xml）"><a href="#3-2-3-第三步：编写映射配置文件（xml）" class="headerlink" title="3.2.3    第三步：编写映射配置文件（xml）"></a>3.2.3    第三步：编写映射配置文件（xml）</h3><p>实体类Customer目前还不具备持久化操作的能力，而Hibernate需要知道实体类Customer映射到数据库Hibernate中的哪个表，以及类中的哪个属性对应数据库表中的哪个字段，这些都需要在映射文件中配置。</p><p>在实体类Customer所在的包中，创建一个名称为Customer.hbm.xml的映射文件，在该文件中定义了实体类Customer的属性是如何映射到cst_customer表的列上的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 导入约束:dtd约束</span><br><span class="line">        位置：在Hibernate的核心jar包中名称为hibernate-mapping-3.0.dtd</span><br><span class="line">        明确该文件中的内容：</span><br><span class="line">            实体类和表的对应关系</span><br><span class="line">            实体类中属性和表的字段的对应关系</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC </span><br><span class="line">    &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- package属性用于设定包的名称，接下来该配置文件中凡是用到此包中的对象时都可以省略包名 --&gt;</span><br><span class="line">&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!-- class标签</span><br><span class="line">                作用：建立实体类和表的对应关系</span><br><span class="line">                属性：</span><br><span class="line">                    name：指定实体类的名称</span><br><span class="line">                    table：指定数据库表的名称</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot;&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- id标签</span><br><span class="line">                        作用：用于映射主键</span><br><span class="line">                        属性：</span><br><span class="line">                            name：指定的是属性名称。也就是get&#x2F;set方法后面的部分，并且首字母要转小写。</span><br><span class="line">                            column:指定的是数据库表的字段名称</span><br><span class="line">--&gt;</span><br><span class="line">&lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt;</span><br><span class="line">            </span><br><span class="line">                        &lt;!-- generator标签：</span><br><span class="line">                                作用：配置主键的生成策略。</span><br><span class="line">                                属性：</span><br><span class="line">                                    class:指定生成方式的取值。</span><br><span class="line">                                    取值之一：native。使用本地数据库的自动增长能力。</span><br><span class="line">                                    mysql数据库的自动增长能力是让某一列自动+1。但是不是所有数据库都支持这种方式。</span><br><span class="line">                        --&gt;</span><br><span class="line">&lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">&lt;&#x2F;id&gt;</span><br><span class="line">        </span><br><span class="line">&lt;!-- property标签：</span><br><span class="line">                        作用：映射其他字段</span><br><span class="line">                        属性：</span><br><span class="line">                            name：指定属性的名称。和id标签的name属性含义一致</span><br><span class="line">                            column：指定数据库表的字段名称</span><br><span class="line">--&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-第四步：编写主配置文件（hibernate-cfg-xml）"><a href="#3-2-4-第四步：编写主配置文件（hibernate-cfg-xml）" class="headerlink" title="3.2.4    第四步：编写主配置文件（hibernate.cfg.xml）"></a>3.2.4    第四步：编写主配置文件（hibernate.cfg.xml）</h3><p>Hibernate的映射文件反映了持久化类和数据库表的映射信息，而Hibernate的配置文件则主要用来配置数据库连接以及Hibernate运行时所需要的各个属性的值。在项目的src下创建一个名称为hibernate.cfg.xml的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!-- 在类的根路径下创建名称为hibernate.cfg.xml的配置文件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 导入dtd约束：</span><br><span class="line">        位置：在核心jar包中的名称为hibernate-configuration-3.0.dtd中</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">&quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line">&lt;!-- 配置SessionFactory</span><br><span class="line">                SessionFactory的作用就是用于创建Session对象的。</span><br><span class="line">                Session对象就是hibernate中操作数据库的核心对象。</span><br><span class="line">此处的配置不要求背，但是要求记住创建SessionFactory必须的三部分信息</span><br><span class="line">                    第一部分：</span><br><span class="line">                        连接数据库的信息</span><br><span class="line">                    第二部分：</span><br><span class="line">                        hibernate的可选配置</span><br><span class="line">                    第三部分：</span><br><span class="line">                        映射文件的位置</span><br><span class="line">--&gt;</span><br><span class="line">&lt;session-factory&gt;</span><br><span class="line">&lt;!-- 第一部分：连接数据库的信息 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&lt;&#x2F;property&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 数据库的方言 --&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二部分：hibernate的可选配置 --&gt;</span><br><span class="line">                &lt;!-- 是否显示hibernate生成的SQL语句 --&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">                &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 是否让hibernate根据表结构的变化来生成DDL语句</span><br><span class="line"> DDL:数据定义语言</span><br><span class="line"> hibernate可以根据映射文件来为我们生成数据库的表结构。但是他不能生成数据库。</span><br><span class="line">                         hbm2ddl.auto的取值</span><br><span class="line">                            * none:不用Hibernate自动生成表.</span><br><span class="line">                            * create:每次都会创建一个新的表.(测试)</span><br><span class="line">                            * create-drop:每次都会创建一个新的表，执行程序结束后删除这个表.(测试)</span><br><span class="line">                            * update:如果数据库中有表，使用原来的表，如果没有表，创建一个新表.可以更新表结构。</span><br><span class="line">                            * validate:只会使用原有的表.对映射关系进行校验.</span><br><span class="line">--&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第三部分：映射配置文件的位置 --&gt;</span><br><span class="line">                &lt;mapping resource&#x3D;&quot;com&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;session-factory&gt;</span><br><span class="line">&lt;&#x2F;hibernate-configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="3-4-实现保存操作"><a href="#3-4-实现保存操作" class="headerlink" title="3.4    实现保存操作"></a>3.4    实现保存操作</h2><p>在项目中新建一个名称为cn.wgy.test的包，然后在包中建立一个名为HibernateDemo1Test.java的文件，该文件是用来测试的类文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hibernate的入门案例</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> * 实现保存一个客户到数据库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wgy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateDemo1Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 步骤分析</span></span><br><span class="line"><span class="comment">     * 1、解析主配置文件</span></span><br><span class="line"><span class="comment">     * 2、根据配置文件创建SessionFactory</span></span><br><span class="line"><span class="comment">     * 3、根据SessionFactory创建Session</span></span><br><span class="line"><span class="comment">     * 4、开启事务</span></span><br><span class="line"><span class="comment">     * 5、执行操作（保存）</span></span><br><span class="line"><span class="comment">     * 6、提交事务</span></span><br><span class="line"><span class="comment">     * 7、释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        customer.setCustName(<span class="string">"测试1"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1、解析主配置文件</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        configuration.configure();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、根据配置文件创建SessionFactory</span></span><br><span class="line">        SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、根据SessionFactory创建Session</span></span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、开启事务</span></span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、执行操作（保存）</span></span><br><span class="line">        session.save(customer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、提交事务</span></span><br><span class="line">        transaction.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、释放资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        sessionFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-入门案例的执行过程"><a href="#3-5-入门案例的执行过程" class="headerlink" title="3.5    入门案例的执行过程"></a>3.5    入门案例的执行过程</h2><p>首先创建Configuration类的实例，并通过它来读取并解析配置文件hibernate.cfg.xml。然后创建SessionFactory读取解析映射文件信息，并将Configuration对象中的所有配置信息拷贝到SessionFactory内存中。接下来，打开Session，让SessionFactory提供连接，并开启一个事务，之后创建对象，向对象中添加数据，通过session.save()方法完成向数据库中保存数据的操作。最后提交事务，并关闭资源。</p><p><img src="https://ae01.alicdn.com/kf/He495e9b8fdec49f6951d0289a3535993j.jpg" alt="img"></p><h1 id="4-Hibernate中API介绍"><a href="#4-Hibernate中API介绍" class="headerlink" title="4.    Hibernate中API介绍"></a>4.    Hibernate中API介绍</h1><h2 id="4-1-Configuration对象"><a href="#4-1-Configuration对象" class="headerlink" title="4.1    Configuration对象"></a>4.1    Configuration对象</h2><h3 id="4-1-1-作用"><a href="#4-1-1-作用" class="headerlink" title="4.1.1    作用"></a>4.1.1    作用</h3><p>在使用Hibernate时，首先要创建Configuration实例，Configuration实例主要用于启动、加载、管理hibernate的配置文件信息。在启动Hibernate的过程中，Configuration实例首先确定Hibernate配置文件的位置，然后读取相关配置，最后创建一个唯一的SessionFactory实例。Configuration对象只存在于系统的初始化阶段，它将SessionFactory创建完成后，就完成了自己的使命。</p><p>Hibernate通常使用<code>Configuration config = new Configuration().configure();</code>的方式创建实例，此种方式默认会去src下读取 hibernate.cfg.xml配置文件。如果不想使用默认的hibernate.cfg.xml配置文件，而是使用指定目录下（或自定义）的配置文件，则需要向configure()方法中传递一个文件路径的参数，其代码写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration config &#x3D; new Configuration().configure(&quot;xml文件位置&quot;);</span><br></pre></td></tr></table></figure><p>此种写法hibernate会去指定位置查找配置文件，例如，想要使用src下config包中的 hibernate.cfg.xml文件，只需将文件位置加入configure()中即可，其代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration config = <span class="keyword">new</span> Configuration().configure(<span class="string">"/config/hibernate.cfg.xml"</span>);</span><br></pre></td></tr></table></figure><p>【加载映射文件】</p><p>Hibernate除了可以使用Configuration对象加载核心配置文件以外，还可以利用该对象加载映射文件。因为如何使用properties文件作为Hibernate的核心配置文件，其他的属性可以使用key=value的格式来设置，但是映射没有办法加载。这时这个对象就有了用武之地。可以在手动编写代码的时候去加载映射文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Configuration configuration &#x3D; new Configuration().configure(&quot;xml文件位置&quot;);</span><br><span class="line"></span><br><span class="line">configuration.addResource(&quot;cn&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;);</span><br></pre></td></tr></table></figure><h3 id="4-1-2-常用方法"><a href="#4-1-2-常用方法" class="headerlink" title="4.1.2    常用方法"></a>4.1.2    常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">默认构造函数：</span><br><span class="line">        它只能加载类的根路径下，名称为hibernate.properties的配置文件。不能加载xml</span><br><span class="line">configure()：</span><br><span class="line">        它用于加载类的根路径下，名称为hibernate.cfg.xml的配置文件。</span><br><span class="line">        configuration.configure();</span><br><span class="line">buildSessionFactory()：</span><br><span class="line">        根据配置文件，构建SessionFactory</span><br><span class="line">        SessionFactory sessionFactory &#x3D; configuration.buildSessionFactory();</span><br><span class="line">addResource(String url);</span><br><span class="line">        指定映射文件的位置</span><br><span class="line">        configuration.addResource(&quot;com&#x2F;itheima&#x2F;domain&#x2F;Customer.hbm.xml&quot;);</span><br><span class="line">addClass(Class clazz);</span><br><span class="line">        指定实体类的字节码</span><br><span class="line">        configuration.addClass(Customer.class);</span><br></pre></td></tr></table></figure><h2 id="4-2-SessionFactory"><a href="#4-2-SessionFactory" class="headerlink" title="4.2    SessionFactory"></a>4.2    SessionFactory</h2><h3 id="4-2-1-作用"><a href="#4-2-1-作用" class="headerlink" title="4.2.1    作用"></a>4.2.1    作用</h3><p>SessionFactory接口负责Hibernate的初始化和建立Session对象。它在Hibernate中起到一个缓冲区作用，Hibernate可以将自动生成的SQL语句、映射数据以及某些可重复利用的的数据放在这个缓冲区中。同时它还保存了对数据库配置的所有映射关系，维护了当前的二级缓存。</p><p>SessionFactory 实例是通过Configuration对象获取的，其获取方法如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SessionFactory sessionFactory = config.buildSessionFactory();</span><br></pre></td></tr></table></figure><h3 id="4-2-2-常用方法"><a href="#4-2-2-常用方法" class="headerlink" title="4.2.2    常用方法"></a>4.2.2    常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openSession()：每次都是生成一个新的Session</span><br></pre></td></tr></table></figure><h3 id="4-2-3-细节"><a href="#4-2-3-细节" class="headerlink" title="4.2.3    细节"></a>4.2.3    细节</h3><p>该对象维护了很多信息：</p><ul><li>连接数据库的信息</li><li>hibernate的基本配置</li><li>映射文件的位置，以及映射文件中的配置</li><li>一些预定义的SQL语句（这些语句都是通用的） 比如：全字段保存，根据id的全字段更新，根据id的全字段查询，根据id的删除等等。</li><li>hibernate的二级缓存（了解）</li></ul><p>同时，它是一个线程安全的对象，所有由该工厂生产的Session都共享工厂中维护的数据。</p><h3 id="4-2-4-使用原则"><a href="#4-2-4-使用原则" class="headerlink" title="4.2.4    使用原则"></a>4.2.4    使用原则</h3><p>由于SessionFactory维护了很多信息同时又是线程安全的，一般情况下，一个项目中只需要一个SessionFactory，只有当应用中存在多个数据源时，才为每个数据源建立一个SessionFactory实例。因此，不应该反复的创建和销毁。</p><p>原则：一个应用应该只有一个SessionFactory。在应用加载时创建，应用卸载时销毁。</p><h3 id="4-2-5-在hibernate中使用数据源-连接池"><a href="#4-2-5-在hibernate中使用数据源-连接池" class="headerlink" title="4.2.5    在hibernate中使用数据源(连接池)"></a>4.2.5    在hibernate中使用数据源(连接池)</h3><p>SessionFactory内部还维护了一个连接池，如果我们需要使用第三方的连接池如C3P0，那么需要我们自己手动进行配置</p><p>配置C3P0步骤如下：</p><ol><li><p>导入连接池的jar包</p><p><img src="https://ae01.alicdn.com/kf/Hed677a54476846a58b586d0f6eb6728cE.jpg" alt="image-20200528121944904"></p></li><li><p>在hibernate主配置文件中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置数据源的提供商 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt;</span><br><span class="line">org.hibernate.connection.C3P0ConnectionProvider</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-3-Session"><a href="#4-3-Session" class="headerlink" title="4.3    Session"></a>4.3    Session</h2><h3 id="4-3-1-作用"><a href="#4-3-1-作用" class="headerlink" title="4.3.1    作用"></a>4.3.1    作用</h3><p>Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。</p><p>创建SessionFactory实例后，就可以通过它获取Session实例。获取Session实例有两种方式，一种是通过openSession()方法，另一种是通过getCurrentSession()方法。两种方法获取session的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用openSession方法创建session</span></span><br><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用getCurrentSession()方法创建session</span></span><br><span class="line">Session session = sessionFactory.getCurrentSession();</span><br></pre></td></tr></table></figure><p>以上两种获取session实例方式的主要区别是，采用openSession方法获取Session实例时，SessionFactory直接创建一个新的Session实例，并且在使用完成后需要调用close方法进行手动关闭。而getCurrentSession方法创建的Session实例会被绑定到当前线程中，它在提交或回滚操作时会自动关闭。</p><h3 id="4-3-2-常用方法"><a href="#4-3-2-常用方法" class="headerlink" title="4.3.2    常用方法"></a>4.3.2    常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">save(Object entity);  ：保存一个实体到数据库</span><br><span class="line"></span><br><span class="line">update(Object entity);：更新一个实体</span><br><span class="line"></span><br><span class="line">delete(Object entity);：删除一个实体</span><br><span class="line"></span><br><span class="line">get(Class clazz,Serializable id);：根据id查询一个实体。参数的含义：Class表示要查询的实体类字节码。Serializable就是查询的条件。</span><br><span class="line"></span><br><span class="line">beginTransaction();：开启事务，并返回事务对象</span><br></pre></td></tr></table></figure><h3 id="4-3-3-细节"><a href="#4-3-3-细节" class="headerlink" title="4.3.3    细节"></a>4.3.3    细节</h3><p>由于SessionFactory已经维护了很多数据，所以Session就维护较少的内容。</p><p>它是一个轻量级对象。并且：它不是线程安全的！！！！！！！</p><p>它维护了hibernate的一级缓存。</p><p>它的反复创建销毁不会消耗太多资源。</p><h3 id="4-3-4-使用原则"><a href="#4-3-4-使用原则" class="headerlink" title="4.3.4    使用原则"></a>4.3.4    使用原则</h3><p>每个线程都只有一个Session对象。</p><h2 id="4-4-Transaction"><a href="#4-4-Transaction" class="headerlink" title="4.4    Transaction"></a>4.4    Transaction</h2><h3 id="4-4-1-作用"><a href="#4-4-1-作用" class="headerlink" title="4.4.1    作用"></a>4.4.1    作用</h3><p>Transaction接口主要用于管理事务，它是Hibernate的数据库事务接口，且对底层的事务接口进行了封装。Transaction接口的事务对象是通过Session对象开启的，其开启方式如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transaction transaction &#x3D; session.beginTransaction();</span><br></pre></td></tr></table></figure><h3 id="4-4-2-常用方法"><a href="#4-4-2-常用方法" class="headerlink" title="4.4.2    常用方法"></a>4.4.2    常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commit()：提交事务</span><br><span class="line"></span><br><span class="line">rollback()：回滚事务</span><br></pre></td></tr></table></figure><p>Session执行完数据库操作后，要使用Transaction接口的commit()方法进行事务提交，才能真正的将数据操作同步到数据库中。发生异常时，需要使用rollback()方法进行事务回滚，以避免数据发生错误。因此，在持久化操作后，必须调用Transaction接口的commit()方法和rollback()方法。如果没有开启事务，那么每个Session的操作，都相当于一个独立的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Customer c = <span class="keyword">new</span> Customer();</span><br><span class="line">    c.setCustName(<span class="string">"测试保存功能"</span>);</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    Session s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s = HibernateUtil.openSession();</span><br><span class="line">        tx = s.beginTransaction();</span><br><span class="line">        <span class="comment">//保存客户</span></span><br><span class="line">        s.save(c);</span><br><span class="line">        tx.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    tx.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-抽取HibernateUtil工具类"><a href="#5-抽取HibernateUtil工具类" class="headerlink" title="5.    抽取HibernateUtil工具类"></a>5.    抽取HibernateUtil工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hibernate的工具类</span></span><br><span class="line"><span class="comment"> * 用于生产一个Session对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wgy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">                cfg.configure();</span><br><span class="line">                factory = cfg.buildSessionFactory();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">"初始化SessionFactory失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个新的Session对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">openSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> factory.openSession();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-案例：使用Hibernate实现CRUD"><a href="#6-案例：使用Hibernate实现CRUD" class="headerlink" title="6.    案例：使用Hibernate实现CRUD"></a>6.    案例：使用Hibernate实现CRUD</h1><h2 id="6-1-保存操作"><a href="#6-1-保存操作" class="headerlink" title="6.1    保存操作"></a>6.1    保存操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Customer c = <span class="keyword">new</span> Customer();</span><br><span class="line">    c.setCustName(<span class="string">"测试保存功能"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.使用工具类获取一个Session</span></span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    <span class="comment">//2.开启事务</span></span><br><span class="line">    <span class="comment">//Transaction tx = session.beginTransaction();</span></span><br><span class="line">    <span class="comment">//3.保存客户</span></span><br><span class="line">    session.save(c);</span><br><span class="line">    <span class="comment">//4.提交事务</span></span><br><span class="line">    <span class="comment">//tx.commit();</span></span><br><span class="line">    <span class="comment">//5.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-查询一个实体"><a href="#6-2-查询一个实体" class="headerlink" title="6.2    查询一个实体"></a>6.2    查询一个实体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.使用工具类获取一个Session</span></span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    <span class="comment">//2.开启事务</span></span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">//3.查询id为2的客户</span></span><br><span class="line">    Customer c = session.get(Customer<span class="class">.<span class="keyword">class</span>, 2<span class="title">L</span>)</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    <span class="comment">//4.提交事务</span></span><br><span class="line">    tx.commit();</span><br><span class="line">    <span class="comment">//5.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-修改操作"><a href="#6-3-修改操作" class="headerlink" title="6.3    修改操作"></a>6.3    修改操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.使用工具类获取一个Session</span></span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    <span class="comment">//2.开启事务</span></span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">//3.查询id为2的客户</span></span><br><span class="line">    Customer c = session.get(Customer<span class="class">.<span class="keyword">class</span>, 2<span class="title">L</span>)</span>;</span><br><span class="line">    <span class="comment">//修改客户的地址为：湖北省</span></span><br><span class="line">    c.setCustAddress(<span class="string">"湖北省"</span>);</span><br><span class="line">    <span class="comment">//执行更新</span></span><br><span class="line">    session.update(c);</span><br><span class="line">    <span class="comment">//4.提交事务</span></span><br><span class="line">    tx.commit();</span><br><span class="line">    <span class="comment">//5.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-删除操作"><a href="#6-4-删除操作" class="headerlink" title="6.4    删除操作"></a>6.4    删除操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.使用工具类获取一个Session</span></span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    <span class="comment">//2.开启事务</span></span><br><span class="line">    Transaction tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">//3.查询id为1的客户</span></span><br><span class="line">    Customer c = session.get(Customer<span class="class">.<span class="keyword">class</span>, 1<span class="title">L</span>)</span>;</span><br><span class="line">    <span class="comment">//删除实体</span></span><br><span class="line">    session.delete(c);<span class="comment">//delete from cst_customer where cust_id = ?</span></span><br><span class="line">    <span class="comment">//4.提交事务</span></span><br><span class="line">    tx.commit();</span><br><span class="line">    <span class="comment">//5.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-实体查询get和load方法"><a href="#6-5-实体查询get和load方法" class="headerlink" title="6.5    实体查询get和load方法"></a>6.5    实体查询get和load方法</h2><h3 id="6-5-1-实体查询的概念"><a href="#6-5-1-实体查询的概念" class="headerlink" title="6.5.1    实体查询的概念"></a>6.5.1    实体查询的概念</h3><p>所谓实体查询即OID查询，就是使用主键作为条件来查询一个实体。其中涉及的方法是Session对象get方法和load方法。 </p><h3 id="6-5-2-方法的说明"><a href="#6-5-2-方法的说明" class="headerlink" title="6.5.2    方法的说明"></a>6.5.2    方法的说明</h3><p><strong>get方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id查询一个实体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entityType 指的是要查询的实体类字节码对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 查询的条件，即主键的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是实体类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; entityType, Serializable id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session s = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    Customer c = s.get(Customer<span class="class">.<span class="keyword">class</span>, 2<span class="title">L</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"get : "</span>+c.toString());</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>load方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id查询一个实体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> theClass 指的是要查询的实体类字节码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id查询的条件，即主键的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是实体类对象或者是实体类对象的代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">load</span><span class="params">(Class&lt;T&gt; theClass, Serializable id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoad</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session s = HibernateUtil.openSession();</span><br><span class="line">    Transaction tx = s.beginTransaction();</span><br><span class="line">    Customer c = s.load(Customer<span class="class">.<span class="keyword">class</span>, 2<span class="title">L</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"load : "</span>+c.toString());</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-3-get和load的区别"><a href="#6-5-3-get和load的区别" class="headerlink" title="6.5.3    get和load的区别"></a>6.5.3    get和load的区别</h3><ol><li><p>查询的时机不一样。</p><p>get的查询时机：每次调用get方法时，马上发起查询。       立即加载</p><p>load的查询时机：每次真正使用的时候，发起查询。        延迟加载   懒加载   惰性加载</p></li><li><p>返回的结果不一样。</p><p>get方法返回的对象是实体类类型</p><p>load方法返回的对象是实体类类型的代理对象</p></li></ol><p>load方法默认情况下是延迟，可以通过配置的方式改为立即加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 由于load方法是hibernate的方法所以只有XML的方式：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Customer"</span> <span class="attr">table</span>=<span class="string">"cst_customer"</span> <span class="attr">lazy</span>=<span class="string">"false"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Hibernate和ORM的概念&quot;&gt;&lt;a href=&quot;#1-Hibernate和ORM的概念&quot; class=&quot;headerlink&quot; title=&quot;1.    Hibernate和ORM的概念&quot;&gt;&lt;/a&gt;1.    Hibernate和ORM的概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-Hibrenate概述&quot;&gt;&lt;a href=&quot;#1-1-Hibrenate概述&quot; class=&quot;headerlink&quot; title=&quot;1.1    Hibrenate概述&quot;&gt;&lt;/a&gt;1.1    Hibrenate概述&lt;/h2&gt;&lt;p&gt;它是一个轻量级，企业级，开源的ORM持久层框架。是可以操作数据库的框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;框架：它就是一个架构。&lt;/li&gt;
&lt;li&gt;通常情况下，软件工程的持久层解决方案，一个为主一个为辅。两者并存（写SQL语句的和不写SQL语句的&lt;/li&gt;
&lt;li&gt;轻量级：指的是使用时依赖的资源很少。（目前我们使用的阶段，只依赖log4j，c3p0连接池）&lt;/li&gt;
&lt;li&gt;企业级：指的是在企业级应用中使用的比较多&lt;/li&gt;
&lt;li&gt;开源的：开放源代码。&lt;/li&gt;
&lt;li&gt;ORM的操作方式：建立对象关系映射，实现操作实体类就相当于操作数据库表。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Hibernate" scheme="https://wgy1993.gitee.io/tags/Hibernate/"/>
    
      <category term="ORM" scheme="https://wgy1993.gitee.io/tags/ORM/"/>
    
      <category term="框架" scheme="https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo+github搭建免费个人博客</title>
    <link href="https://wgy1993.gitee.io/archives/52429b60.html"/>
    <id>https://wgy1993.gitee.io/archives/52429b60.html</id>
    <published>2020-05-15T11:40:37.000Z</published>
    <updated>2020-06-01T05:39:23.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台</li></ol><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始一切之前，你必须已经：</p><ul><li>有一个github账号，没有的话去注册一个；</li><li>安装了node.js、npm，并了解相关基础知识；</li><li>安装了git for windows（或者其它git客户端）</li></ul><h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>新建一个名为<code>你的用户名.github.io</code>的仓库，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>几个注意的地方：</p><ol><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；</li></ol><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h1 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><p><img src="https://ae01.alicdn.com/kf/H0d40da5eee724569a8f2c279ac845f27l.jpg" alt="img"></p><p>将刚复制的内容粘贴到key那里，title随便填，保存。</p><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p><blockquote><p>Hi wgy1993! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>看到这个信息说明SSH已配置成功！</p><p>此时你还需要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;yourname&quot;&#x2F;&#x2F; 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;xxx@163.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><p>具体这个配置是干嘛的我没仔细深究。</p><h1 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h1><h2 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p><p>官网： <a href="http://hexo.io/" target="_blank" rel="noopener">http://hexo.io</a><br>github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>安装之前先来说几个注意事项：</p><ol><li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</li><li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li><li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>E:\MyGitWorkSpace\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /e/MyGitWorkSpace/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><p><img src="https://ae01.alicdn.com/kf/Hceb1f4a159e343c4bc0496745914a864C.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="https://ae01.alicdn.com/kf/Ha77a365fa6744a119c008199db98b27eN.jpg" alt="img"></p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了</p><h2 id="浏览目录"><a href="#浏览目录" class="headerlink" title="浏览目录"></a>浏览目录</h2><p><img src="https://ae01.alicdn.com/kf/H9b2007ae9dd041c1988780050b8c33e1K.jpg" alt="image-20200515192304796"></p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题</a>。</p><p>个人比较喜欢的2个主题：<a href="https://github.com/pinggod/hexo-theme-jekyll" target="_blank" rel="noopener">hexo-theme-jekyll</a> 和 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>。</p><p>首先下载这个主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /f/Workspaces/hexo/</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>下载后的主题都在这里：</p><p><img src="https://ae01.alicdn.com/kf/Hbb471835feb746f39cb6db2d7b0d8cf7C.jpg" alt="img"></p><p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p><h2 id="上传之前"><a href="#上传之前" class="headerlink" title="上传之前"></a>上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，<code>ssh key</code>肯定要配置好。</p><p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:wgy1993&#x2F;wgy1993.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>错误写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;wgy1993&#x2F;wgy1993.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行<code>hexo d</code>的话一般会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: github 或者 Deployer not found: git</span><br></pre></td></tr></table></figure><p>原因是还需要安装一个插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>其它命令不确定，部署这个命令一定要用git bash，否则会提示<code>Permission denied (publickey).</code></p><p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会：</p><p><img src="https://ae01.alicdn.com/kf/H3c094a9ce6e8438bbdd7dbeed07d40f48.jpg" alt="img"></p><h2 id="保留README-md等文件"><a href="#保留README-md等文件" class="headerlink" title="保留README.md等文件"></a>保留README.md等文件</h2><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的：</p><p><img src="https://ae01.alicdn.com/kf/H4ea0993cfae44c41bbf68297bc697ca07.jpg" alt="img"></p><p>由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。</p><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>常见命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><p>这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。</p><p>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>定位到我们的hexo根目录，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &#39;my-first-blog&#39;</span><br></pre></td></tr></table></figure><p>hexo会帮我们在<code>_posts</code>下生成相关md文件：</p><p><img src="https://ae01.alicdn.com/kf/H1736b5901cb646c7b007f1bcfdb4e82eY.jpg" alt="img"></p><p>我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：</p><p><img src="https://ae01.alicdn.com/kf/H7a41d5d7f9774850a9292072726612d5M.jpg" alt="img"></p><p>当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。</p><p>一般完整格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure><p>那么<code>hexo new page &#39;postName&#39;</code>命令和<code>hexo new &#39;postName&#39;</code>有什么区别呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;my-second-blog&quot;</span><br></pre></td></tr></table></figure><p>生成如下：</p><p><img src="https://ae01.alicdn.com/kf/Hfbc4fe32346e40ae95fb1a5ea52a69b4a.jpg" alt="img"></p><p>最终部署时生成：<code>hexo\public\my-second-blog\index.html</code>，但是它不会作为文章出现在博文目录。</p><h3 id="如何让博文列表不显示全部内容"><a href="#如何让博文列表不显示全部内容" class="headerlink" title="如何让博文列表不显示全部内容"></a>如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p><p>答案是在合适的位置加上``即可，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 前言</span></span><br><span class="line"></span><br><span class="line">使用github pages服务搭建博客的好处有：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>全是静态文件，访问速度快；</span><br><span class="line"><span class="bullet">2. </span>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line"><span class="bullet">3. </span>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">4. </span>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line"><span class="bullet">5. </span>博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line"><span class="bullet">6. </span>等等；</span><br></pre></td></tr></table></figure><p>最终效果：</p><p><img src="https://ae01.alicdn.com/kf/Hb69762d2d3164cc59a4313edfee04d17g.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用github pages服务搭建博客的好处有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全是静态文件，访问速度快；&lt;/li&gt;
&lt;li&gt;免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；&lt;/li&gt;
&lt;li&gt;可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;/li&gt;
&lt;li&gt;数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；&lt;/li&gt;
&lt;li&gt;博客内容可以轻松打包、转移、发布到其它平台&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="https://wgy1993.gitee.io/tags/Hexo/"/>
    
      <category term="GitHub" scheme="https://wgy1993.gitee.io/tags/GitHub/"/>
    
  </entry>
  
</feed>
