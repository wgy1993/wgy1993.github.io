[{"title":"SSH","date":"2020-06-16T05:58:26.000Z","path":"archives/782a8ece.html","text":"1. SSH三大框架整合1.1 整合说明 独立式整合指的是三个框架都使用自己的配置文件。 引入式整合指的是hibernate主配置文件中的内容都配置到spring配置文件中 在整合过程中，确保每步都运行成功，然后在继续往下做。 整合中使用的案例是客户的保存和列表查询操作。 后面的三种整合方式都基于1.2中的环境准备。 1.2 环境准备1.2.1 创建java web工程1.2.2 创建数据库和表结构1234567891011121314create database ssh;use ssh;&#x2F;*创建客户表*&#x2F;CREATE TABLE &#96;cst_customer&#96; ( &#96;cust_id&#96; bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#39;客户编号(主键)&#39;, &#96;cust_name&#96; varchar(32) NOT NULL COMMENT &#39;客户名称(公司名称)&#39;, &#96;cust_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户信息来源&#39;, &#96;cust_industry&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户所属行业&#39;, &#96;cust_level&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户级别&#39;, &#96;cust_address&#96; varchar(128) DEFAULT NULL COMMENT &#39;客户联系地址&#39;, &#96;cust_phone&#96; varchar(64) DEFAULT NULL COMMENT &#39;客户联系电话&#39;, PRIMARY KEY (&#96;cust_id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8; 1.2.3 编写实体类1234567891011121314/** * 客户的实体类（数据模型） */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; ...&#125; 1.2.4 编写业务层接口和实现类12345678910111213141516/** * 客户的业务层接口 */public interface ICustomerService &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer(); /** * @param customer */ void saveCustomer(Customer customer);&#125; 123456789101112131415161718192021/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao; public void setCustomerDao(ICustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125; @Override public void saveCustomer(Customer customer) &#123; customerDao.saveCustomer(customer); &#125;&#125; 1.2.5 编写持久层接口和实现类1234567891011121314151617/** * 客户的持久层接口 */public interface ICustomerDao &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer(); /** * 保存客户 * @param customer */ void saveCustomer(Customer customer);&#125; 12345678910111213141516/** * 客户的持久层实现类 */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; System.out.println(\"查询了所有用户\"); return null; &#125; @Override public void saveCustomer(Customer customer) &#123; System.out.println(\"保存了用户\"); &#125;&#125; 2. 基于XML的独立式整合2.1 保证spring框架在web工程中独立运行2.1.1 拷贝spring的ioc,aop和事务控制三组jar包ioc: aop: 事务控制: 2.1.2 编写spring配置文件并导入约束123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 2.1.3 把业务层和持久层配置到文件中123456789&lt;!-- 把资源交给spring来管理 --&gt;&lt;!-- 配置dao --&gt;&lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt;&lt;/bean&gt; &lt;!-- 配置service --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;!-- 注入dao --&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.1.4 测试spring能否独立运行12345678910111213/** * 测试类，测试spring框架可以独立运行 */public class SpringTest &#123; public static void main(String[] args) &#123; //1.获取spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.跟Id获取bean对象 ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); cs.findAllCustomer(); &#125;&#125; 2.2 保证hibernate框架能够在web工程中独立运行2.2.1 拷贝hibernate必备jar包hibernate基本jar包: c3p0: 2.2.2 编写实体类的映射文件1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping package=\"com.wgy.domain\"&gt; &lt;class name=\"Customer\" table=\"cst_customer\"&gt; &lt;id name=\"custId\" column=\"cust_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"custName\" column=\"cust_name\"/&gt; &lt;property name=\"custSource\" column=\"cust_source\"/&gt; &lt;property name=\"custIndustry\" column=\"cust_industry\"/&gt; &lt;property name=\"custLevel\" column=\"cust_level\"/&gt; &lt;property name=\"custAddress\" column=\"cust_address\"/&gt; &lt;property name=\"custPhone\" column=\"cust_phone\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 2.2.3 编写hibernate主配置文件12345678910111213141516171819202122232425262728293031&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory--&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/ssh&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name=\"hibernate.format_sql\"&gt;false&lt;/property&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name=\"hibernate.connection.provider_class\"&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;/property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping resource=\"com/wgy/domain/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 2.2.4 编写测试类-测试保存客户123456789101112131415161718192021222324252627/** * 保证hibernate框架能够独立在web工程中运行 * * @author wgy */public class HibernateTest &#123; public static void main(String[] args) &#123; Customer c = new Customer(); c.setCustName(\"ssh整合Customer\"); //1.加载配置文件 Configuration cfg = new Configuration(); cfg.configure(); //2.根据配置文件创建SessionFactory SessionFactory factory = cfg.buildSessionFactory(); //3.获取session Session session = factory.getCurrentSession(); //4.开启事务 Transaction tx = session.beginTransaction(); //5.执行操作 session.save(c); //6.提交/回滚事务 tx.commit(); //7.释放资源 factory.close(); &#125;&#125; 2.3 整合spring和hibernate框架2.3.1 明确 Spring和Hibernate的整合就是spring接管SessionFactory的创建 Spring针对Hiberante的操作有一个封装的对象HibernateTemplate 和JdbcTemplate一样，HibernateTemplate也有一个HibernateDaoSupport HibernateTemplate和HibernateDaoSupport都在spring-orm-4.2.4.RELEASE.jar中 我们Dao采用继承HiberanteDaoSupport的方式编写，它一样不能用于注解配置。 2.3.2 整合步骤2.3.2.1 在spring配置文件中配置SessionFactory12345678&lt;!-- 配置sessionFactory：让spring接管sessionFactory的创建 用spring提供的一个SessionFactory：LocalSessionFactoryBean 创建SessionFactory有三部分必不可少的信息。三部分信息在hibernate主配置文件中都有 把hibernate主配置文件的位置注入进来--&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\"/&gt;&lt;/bean&gt; 2.3.2.2 改造Dao继承HibernateDaoSupport123456789101112131415/** * 客户的持久层实现类 */public class CustomerDaoImpl extends HibernateDaoSupport implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return (List&lt;Customer&gt;) getHibernateTemplate().find(\"from Customer\"); &#125; @Override public void saveCustomer(Customer customer) &#123; getHibernateTemplate().save(customer); &#125;&#125; 2.3.2.3 在spring配置文件中给Dao注入SessionFactory1234&lt;!-- 配置dao --&gt;&lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.3.2.4 测试12345678910111213141516171819202122232425262728293031/** * 整合spring和hibernate的测试类 * spring整合Junit * 第一步：拷贝jar包 * spring-junit-4.2.4.jar * 第二步：使用注解替换运行器（原来junit的main方法） * @RunWith(支持spring的main方法) * @ContextConfiguration(指定spring的配置文件位置) */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:bean.xml\"&#125;)public class SpringHibernateTest &#123; @Autowired private ICustomerService cs; @Test public void testSave() &#123; Customer c = new Customer(); c.setCustName(\"spring hibernate customer123\"); cs.saveCustomer(c); &#125; @Test public void testFindAll() &#123; List list = cs.findAllCustomer(); for (Object o : list) &#123; System.out.println(o); &#125; &#125;&#125; 12345测试结果： 无论保存还是查询都运行失败！ 按常理来说，我们没有配置事务，保存失败是可以理解的。为什么查询也会失败呢？分析原因： 是由于spring的HibernateTemplate对象在使用Session时，spring创建了Session的代理对象，在这个过程中，spring对hibernate绑定Session到当前线程的配置不认识了，所以运行失败。 2.3.2.5 修改把Session绑定到当前线程上123456789&lt;!-- 是hibernate把session绑定到当前线程上的配置 &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt;--&gt;&lt;!-- 是spring把sesion绑定到当前线程上的配置 --&gt;&lt;property name=\"hibernate.current_session_context_class\"&gt; org.springframework.orm.hibernate5.SpringSessionContext&lt;/property&gt;此时再运行刚才的测试： 查询可以使用了。保存不能使用，原因是没有事务。 2.3.3 配置Spring的事务2.3.3.1 配置事务管理器并注入SessionFactory1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 2.3.3.2 配置事务的通知及通知的属性1234567&lt;!-- 配置事务的通知 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 2.3.3.3 配置AOP建立切入点表达式和事务通知的关系12345678910&lt;!-- 配置aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;!-- 建立切入点表达式和事务通知的关联 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt;&lt;/aop:config&gt;再次测试： 此时保存和查询都可以正常使用了。 2.4 保证struts2框架能够在web工程中独立运行2.4.1 拷贝struts2的必备jar包 2.4.2 编写struts.xml文件并导入约束123456789&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;struts&gt; 2.4.3 在web.xml中配置struts2的核心过滤器123456789&lt;!-- 配置struts2和核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.4.4 导入jsp页面 2.4.5 修改menu.jsp123&lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/addUICustomer.action\" target=main&gt;－ 新增客户&lt;/A&gt;&lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/findAllCustomer.action\" target=main&gt;－ 客户列表&lt;/A&gt; 2.4.6 在struts.xml中配置action12345678910&lt;!-- 配置动作 --&gt;&lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;action name&#x3D;&quot;addUICustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;addUICustomer&quot;&gt; &lt;result name&#x3D;&quot;addUICustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 2.4.7 编写动作类和方法12345678910111213141516171819202122232425262728/** * 客户的动作类*/public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); @Override public Customer getModel() &#123; return customer; &#125; /** * 获取添加客户页面 * @return */ public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 查询所有客户 * @return */ public String findAllCustomer() &#123; //调用业务层查询客户列表 &#125;&#125; 2.4.8 测试1运行结果：通过点击【新增客户】可以跳转到客户添加页面 2.5 整合spring和struts22.5.1 明确 spring整合struts2就是让spring接管action的创建 action是多例的，配置到spring中需要设置scope属性为多例 2.5.2 整合步骤2.5.2.1 拷贝spring整合struts的jar包 2.5.2.2 在action中使用构造函数获取Service对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 客户的动作类 */public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); private List&lt;Customer&gt; customers; private ICustomerService customerService; @Override public Customer getModel() &#123; return customer; &#125; public void setCustomerService(ICustomerService customerService) &#123; this.customerService = customerService; &#125;//此种方式根本不能用，因为由于动作类是多例的，每次都会创建新的容器，导致容器中的bean也会创建新的。// public CustomerAction()&#123;// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// System.out.println(ac);// ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\");// this.setCustomerService(cs);// &#125;//此种方式解决了容器多例的问题，保证了容器一个应用只有一个，但是我们的代码边臃肿了，每个action都需要这么写一下。 public CustomerAction()&#123; ServletContext application = ServletActionContext.getServletContext(); ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(application); System.out.println(ac); ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); this.setCustomerService(cs); &#125; /** * 获取添加客户页面 * * @return */ public String addUICustomer() &#123; return \"addUICustomer\"; &#125; /** * 查询所有客户 * @return */ public String findAllCustomer() &#123; //调用业务层查询客户列表 customers = customerService.findAllCustomer(); return \"findAllCustomer\"; &#125; public List&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers; &#125;&#125; 2.5.2.3 测试1运行结果：查询客户列表测试通过。 2.6 优化配置2.6.1 配置spring的监听器12345678910111213141516171819在上面2.5.2.2小节中有这么一句： 由于动作类是多例的，每次都会创建容器，导致资源的浪费。一个应用应该只有一个容器问题： 如何解决呢？答案： 只要让容器在应用加载时创建，应用卸载时销毁就可以。问题： 我们怎么知道应用何时加载了呢？答案： ServletContext对象创建了，就表示当前应用已经被服务器加载了。问题： 我们怎么知道ServletContext对象创建了呢？答案： ServletContextListener监听器可以监听到ServletContext对象的创建和销毁。Spring框架为我们提供了一个监听器：ContextLoaderListener。它是ServletContextListener接口的实现类，负责监听ServletContext对象的创建，为我们创建容器，监听ServletContext对象的销毁，销毁容器。我们只需要配置上即可。ContextLoaderListener在spring-web-4.2.4.RELEASE.jar中 在web.xml中配置监听器： 123456789&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;当配置了此监听器后，就不需要使用Action的构造函数了，可以把构造函数那段删除了。此监听器只能读取WEB-INF目录中的名称为applicationContext.xml的配置文件。这显然限制了我们的配置。我们可以通过配置全局初始化参数的方式，指定spring配置文件的位置. 2.6.2 配置指定spring配置文件的位置12345&lt;!-- 手动指定spring的配置文件位置，需要使用ServletContext的初始化参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 2.6.3 分文件编写spring配置我们写到这里，其实搭建环境已经基本结束了，但是发现spring的配置文件杂乱无章，使我们在找配置的时候，很难一下找到。所以我们采用分配置文件编写的方式。 2.6.3.1 编写主配置文件引入其他配置文件1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 引入其他spring配置文件 --&gt; &lt;import resource=\"applicationContext-customer.xml\"/&gt; &lt;import resource=\"applicationContext-jdbc.xml\"/&gt; &lt;import resource=\"applicationContext-tx.xml\"/&gt;&lt;/beans&gt; 2.6.3.2 编写针对需求的配置文件applicationContext-customer.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"/&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.6.3.3 编写数据库连接的配置文件applicationContext-jdbc.xml123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置SessionFactory --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 使用的是hibernate主配置文件中的内容，我们只需要指定hibernate配置文件的位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:config/hibernate/hibernate.cfg.xml\"&gt;/&gt; &lt;/bean&gt;&lt;/beans&gt; 2.6.3.4 编写事务控制的配置文件applicationContext-tx.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 和事务相关的配置 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务的通知 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 配置事务的属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置aop --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;!-- 建立切入点表达式和事务通知的关联 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.6.4 配置指定struts2配置文件位置我们的spring和hibernate配置文件都存到了src/config/的对应包中了，只有struts2配置文件还在类的根路径下，它也可以通过配置的方式指定struts.xml的位置。配置的是过滤器的初始化参数。初始化参数的name和value都是固定写法。 1234567891011121314&lt;!-- 配置struts2和核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;!-- 手动指定struts2配置文件的位置：此处的配置绝大多数都是固定的--&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;struts-default.xml,struts-plugin.xml,config/struts/struts.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.6.5 分文件编写struts2配置文件当我们后面做的模块越来越多，struts2一个配置文件写起来也会杂乱无章，所以我们也可以把struts2的配置文件分开编写。 2.6.5.1 编写struts2的主配置文件struts.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name=\"struts.devMode\" value=\"true\"/&gt; &lt;!-- 配置公共包，有公共的配置就写在此处--&gt; &lt;package name=\"myDefault\" extends=\"struts-default\" abstract=\"true\"&gt; &lt;/package&gt; &lt;!-- 引入其他struts2配置文件 --&gt; &lt;include file=\"config/struts/struts-customer.xml\"&gt;&lt;/include&gt;&lt;/struts&gt; 2.6.5.2 针对不同模块编写不同的配置文件struts-customer.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 配置和客户管理相关的动作 --&gt; &lt;package name=\"customer\" extends=\"myDefault\" namespace=\"/customer\"&gt; &lt;action name=\"addUICustomer\" class=\"com.wgy.web.action.CustomerAction\" method=\"addUICustomer\"&gt; &lt;result name=\"addUICustomer\"&gt;/jsp/customer/add.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"findAllCustomer\" class=\"com.wgy.web.action.CustomerAction\" method=\"findAllCustomer\"&gt; &lt;result name=\"findAllCustomer\"&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 2.6.6 管理Action的两种方式2.6.6.1 让struts2自己来管理此种方式就是在action标签的class属性中提供动作类的全限定类名。 123&lt;action name=\"addUICustomer\" class=\"com.wgy.web.action.CustomerAction\" method=\"addUICustomer\"&gt; &lt;result name=\"addUICustomer\"&gt;/jsp/customer/add.jsp&lt;/result&gt;&lt;/action&gt; 2.6.6.2 让spring来管理（实际开发中采用的方式）此种方式就是在spring配置文件中配置Action，在struts2配置文件action标签的class属性里写bean的id。 spring配置文件： 1234&lt;!-- 配置action --&gt;&lt;bean id=\"customerAction\" class=\"com.wgy.web.action.CustomerAction\" scope=\"prototype\"&gt; &lt;property name=\"customerService\" ref=\"customerService\"&gt;&lt;/property&gt;&lt;/bean&gt; struts2配置文件： 123&lt;action name&#x3D;&quot;addUICustomer&quot; class&#x3D;&quot;customerAction&quot; method&#x3D;&quot;addUICustomer&quot;&gt; &lt;result name&#x3D;&quot;addUICustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3. 基于XML的引入式整合3.1 明确引入式整合就是把hibernate.cfg.xml中的配置都挪到spring的配置文件中 3.2 配置方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 和jdbc配置相关的 --&gt;&lt;!-- 配置sessionFactory --&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 第一部分：连接数据库的 用连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;!-- 数据库的方言 --&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;prop key=\"hibernate.format_sql\"&gt;false&lt;/prop&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;prop key=\"hibernate.current_session_context_class\"&gt; org.springframework.orm.hibernate5.SpringSessionContext &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 第三部分：映射文件的位置 mappingResources：它是一个注入string数组类型的数据。提供的是映射文件的位置。有几个映射文件，就需要写几个。 mappingDirectoryLocations：它是注入一个Resource类型的数组。提供的是映射文件所在的目录。此属性一般多用于一个项目有多个地方存放映射配置。 //服务端 server_domain //移动端 mobile_domain mappingLocations：它是注入一个Resource类型的数组。提供的映射文件的位置。它可以使用通配符。 --&gt; &lt;property name=\"mappingLocations\"&gt; &lt;array&gt; &lt;value&gt;classpath:com/wgy/domain/*.hbm.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/ssh\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt;&lt;/bean&gt; 4. 基于注解的整合4.1 明确 注解整合仍然使用上面的环境，就是把xml的配置全部换成注解 spring的注解整合有两种方式，一种是用xml文件，一种是纯注解。 hibernate注解整合是把实体类映射改为JPA注解映射 4.2 整合步骤-spring使用xml文件4.2.1 spring配置使用注解实现4.2.1.1 在spring配置文件中配置要扫描的包12&lt;!-- 配置spring运行要扫描的包 --&gt;&lt;context:component-scan base-package=\"com.wgy\"/&gt; 4.2.1.2 把action,service和dao都用注解配置12345678910/** * 客户的动作类 */@Controller(\"customerAction\")@Scope(\"prototype\")public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; @Autowired private ICustomerService customerService; //action中的方法不变&#125; 123456789/** * 客户的业务层实现类 */@Service(\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Autowired private ICustomerDao customerDao; //service中的方法不变&#125; 12345678910/** * 客户的持久层实现类 */@Repository(\"customerDao\")public class CustomerDaoImpl implements ICustomerDao &#123; //dao中必须自己定义HibernateTemplate，不能继承HibernateDaoSupport了 @Autowired private HibernateTemplate hibernateTemplate; //dao中的方法不变&#125; 4.2.1.3 在spring配置文件中配置HiernateTemplate1234&lt;!-- 配置hibernateTemplate --&gt;&lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate5.HibernateTemplate\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 4.2.1.4 在spring配置文件中配置事务管理器1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 4.2.1.5 在spring配置文件中开启spring对注解事务的支持12&lt;!-- 开启spring对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 4.2.1.6 在客户的业务层实现类上使用@Transactional注解123456789101112131415161718192021222324/** * 客户的业务层实现类 * * @author wgy */@Service(\"customerService\")@Transactional(readOnly = false, propagation = Propagation.REQUIRED)public class CustomerServiceImpl implements ICustomerService &#123; @Resource(name = \"customerDao\") private ICustomerDao customerDao; @Override @Transactional(readOnly = true, propagation = Propagation.SUPPORTS) public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125; @Override public void saveCustomer(Customer customer) &#123; customerDao.saveCustomer(customer); &#125;&#125; 4.2.2 hibernate映射使用注解配置实现4.2.2.1 实体类映射注解配置1234567891011121314151617181920212223242526272829/** * 客户的实体类 * JPA规范：java 持久化规范 * 注解全都是JPA规范的。 * 导包都需要导入javax.persistence包下的 * */@Entity@Table(name=\"cst_customer\")public class Customer implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"cust_id\") private Long custId; @Column(name=\"cust_name\") private String custName; @Column(name=\"cust_source\") private String custSource; @Column(name=\"cust_industry\") private String custIndustry; @Column(name=\"cust_level\") private String custLevel; @Column(name=\"cust_address\") private String custAddress; @Column(name=\"cust_phone\") private String custPhone; ...&#125; 4.2.2.2 spring中SessionFactory配置修改123456789101112131415161718192021222324252627282930&lt;!-- 配置sessionFactory --&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 第一部分：连接数据库的 用连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;!-- 数据库的方言 --&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;prop key=\"hibernate.format_sql\"&gt;false&lt;/prop&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;prop key=\"hibernate.current_session_context_class\"&gt; org.springframework.orm.hibernate5.SpringSessionContext &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 第三部分：指定实体类所在的包，当创建SessionFactory,会去该包中扫描实体类上的注解，从而生成映射配置--&gt; &lt;property name=\"packagesToScan\"&gt; &lt;array&gt; &lt;value&gt;com.wgy.domain&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 4.2.3 struts2配置使用注解实现4.2.3.1 导入struts2注解的jar包 4.2.3.2 使用注解配置Action1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 客户的动作类 */@Controller(\"customerAction\")@Scope(\"prototype\")//-------以下都是struts2的注解-----------@ParentPackage(\"struts-default\")//指定当前包的父包@Namespace(\"/customer\")//指定名称空间，访问当前action的所有方法都需要有名称空间@Results(&#123; @Result(name = \"addUICustomer\", type = \"dispatcher\", location = \"/jsp/customer/add.jsp\"), @Result(name = \"findAllCustomer\", type = \"dispatcher\", location = \"/jsp/customer/list.jsp\"), @Result(name = \"listCustomer\", type = \"redirectAction\", location = \"findAllCustomer\")&#125;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); private List&lt;Customer&gt; customers; @Resource(name = \"customerService\") private ICustomerService customerService; @Override public Customer getModel() &#123; return customer; &#125; /** * 查询所有客户 * @return */ @Action(\"findAllCustomer\") public String findAllCustomer()&#123; //调用业务层查询客户列表 customers = customerService.findAllCustomer(); return \"findAllCustomer\"; &#125; /** * 获取添加客户页面 * @return */ @Action(\"addUICustomer\") public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 添加客户 * @return */ @Action(\"addCustomer\") public String addCustomer()&#123; customerService.saveCustomer(customer); return \"listCustomer\"; &#125; public List&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers; &#125;&#125; 4.2.3.3 指定struts2开发模式12345678910111213&lt;!-- 配置struts2和核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.devMode&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Spring(四)","date":"2020-06-14T09:18:35.000Z","path":"archives/924a9eab.html","text":"1. Spring中的JdbcTemplate1.1 JdbcTemplate概述它是spring框架中提供的一个对象，是对原始Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类，入下图所示： 我们今天的主角在spring-jdbc-4.24.RELEASE.jar中，我们在导包的时候，除了要导入这个jar包外，还需要导入一个spring-tx-4.2.4.RELEASE.jar（它是和事务相关的）。 1.2 JdbcTemplate对象的创建我们可以参考它的源码，来一探究竟： 12345678910111213public JdbcTemplate() &#123;&#125;public JdbcTemplate(DataSource dataSource) &#123; setDataSource(dataSource); afterPropertiesSet();&#125;public JdbcTemplate(DataSource dataSource, boolean lazyInit) &#123; setDataSource(dataSource); setLazyInit(lazyInit); afterPropertiesSet();&#125; 除了默认构造函数之外，都需要提供一个数据源。既然有set方法，依据我们之前学过的依赖注入，我们可不可以在配置文件中配置呢？ 答案是肯定的。 1.3 Spring中配置数据源1.3.1 环境搭建 1.3.2 编写Spring的配置文件1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; 1.3.3 配置数据源我们之前已经接触过了两个数据源，一个是C3P0，一个是DBCP。要想使用这两数据源都需要导入对应的jar包。 1.3.3.1 配置C3P0数据源导包: 在Spring的配置文件中配置： 123456&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.3.3.2 配置DBCP数据源导包: 在Spring的配置文件中配置： 123456&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.3.3.3 配置spring内置数据源spring框架也提供了一个内置数据源，我们也可以使用spring的内置数据源，它就在spring-jdbc-4.2.4.REEASE.jar包中： 123456&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.3.4 将数据库连接的信息配置到属性文件中:定义属性文件 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc.username=rootjdbc.password=root 引入外部的属性文件 12345678一种方式:&lt;!-- 引入外部属性文件： --&gt;&lt;bean class&#x3D;&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name&#x3D;&quot;location&quot; value&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;二种方式:&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt; 1.4 JdbcTemplate的增删改查操作1.4.1 前期准备12345678910创建数据库：create database spring;use spring;创建表：create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci; 1.4.2 在spring配置文件中配置JdbcTemplate12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.4.3 最基本使用1234567891011public class JdbcTemplateDemo2 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 jt.execute(\"insert into account(name,money)values('eee',500)\"); &#125;&#125; 1.4.4 保存操作123456789101112public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //保存 jt.update(\"insert into account(name,money)values(?,?)\",\"fff\",5000); &#125;&#125; 1.4.5 更新操作123456789101112public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //修改 jt.update(\"update account set money = money-? where id = ?\",300,6); &#125;&#125; 1.4.6 删除操作123456789101112public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //删除 jt.update(\"delete from account where id = ?\",6); &#125;&#125; 1.4.7 查询所有操作1234567891011121314151617181920212223242526public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询所有 List&lt;Account&gt; accounts = jt.query(\"select * from account where money &gt; ? \",new AccountRowMapper(), 500); for(Account o : accounts)&#123; System.out.println(o); &#125; &#125;&#125;public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(\"id\")); account.setName(rs.getString(\"name\")); account.setMoney(rs.getFloat(\"money\")); return account; &#125;&#125; 123456789101112131415public class JdbcTemplateDemo3 &#123; public static void main(String[] args)&#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.跟id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询所有 List&lt;Account&gt; accounts = jt.query(\"select * from account where money &gt; ?\",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),1000); for(Account account : accounts)&#123; System.out.println(account); &#125; &#125;&#125; 1.4.8 查询一个操作1234567891011121314151617181920212223242526272829//使用RowMapper的方式：常用的方式public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询一个 List&lt;Account&gt; as = jt.query(\"select * from account where id = ? \", new AccountRowMapper(), 55); System.out.println(as.isEmpty()?\"没有结果\":as.get(0)); &#125;&#125;//使用ResultSetExtractor的方式:不常用的方式public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询一个 Account account = jt.query(\"select * from account where id = ?\",new AccountResultSetExtractor(),3); System.out.println(account); &#125;&#125; 1.4.9 查询返回一行一列操作1234567891011121314public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询返回一行一列：使用聚合函数，在不使用group by字句时，都是返回一行一列。最长用的就是分页中获取总记录条数 //queryForObject是spring 3.x之后的新方法，在spring2.x的时候，它的方法是多个：queryForInt queryForLong queryForShort Integer total = jt.queryForObject(\"select count(*) from account where money &gt; ? \",Integer.class,500); System.out.println(total); &#125;&#125; 1.5 在dao中使用JdbcTemplate1.5.1 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 1.5.2 第一种方式：在dao中定义JdbcTemplate123456789101112131415161718192021222324252627282930313233343536/** * 账户的持久层实现类 * 此版本的dao，需要给dao注入JdbcTemplate */public class AccountDaoImpl implements IAccountDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ? \",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where name = ? \",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一，不是只有一个账户对象\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set money = ? where id = ? \",account.getMoney(),account.getId()); &#125;&#125; 配置文件： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置一个dao --&gt; &lt;bean id=\"accountDao\" class=\"com.wgy.dao.impl.AccountDaoImpl\"&gt; &lt;!-- 注入jdbcTemplate --&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.5.3 第二种方式：让dao继承JdbcDaoSupportJdbcDaoSupport是spring框架为我们提供的一个类，该类中定义了一个JdbcTemplate对象，我们可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源：具体源码如下： 12345678910111213141516171819202122232425public abstract class JdbcDaoSupport extends DaoSupport &#123; //定义对象 private JdbcTemplate jdbcTemplate; //set方法注入数据源，判断是否注入了，注入了就创建JdbcTemplate public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; //如果提供了数据源就创建JdbcTemplate this.jdbcTemplate = createJdbcTemplate(dataSource); initTemplateConfig(); &#125; &#125; //使用数据源创建JdcbTemplate protected JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; //当然，我们也可以通过注入JdbcTemplate对象 public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; initTemplateConfig(); &#125; //使用getJdbcTmeplate方法获取操作模板对象 public final JdbcTemplate getJdbcTemplate() &#123; return this.jdbcTemplate; &#125;&#125; 1234567891011121314151617181920212223242526272829303132/** * 账户的持久层实现类 * 此版本dao，只需要给它的父类注入一个数据源 */public class AccountDaoImpl2 extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where id = ? \",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where name = ? \",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一，不是只有一个账户对象\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 getJdbcTemplate().update(\"update account set money = ? where id = ? \",account.getMoney(),account.getId()); &#125;&#125; 配置文件： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置dao2 --&gt; &lt;bean id=\"accountDao2\" class=\"com.wgy.dao.impl.AccountDaoImpl2\"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.5.4 两种方式有什么区别呢？ 第一种在Dao类中定义JdbcTemplate的方式，适用于所有配置方式（xml和注解都可以）。 第二种让Dao继承JdbcDaoSupport的方式，只能用于基于XML的方式，注解用不了。 2. Spring中的事务控制2.1 Spring中事务控制的API介绍2.1.1 PlatformTransactionManager此接口是spring的事务管理器，它里面提供了我们常用的操作事务的方法，如下图： 我们在开发中都是使用它的实现类，如下图： 123真正管理事务的对象 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用Spring JDBC或iBatis 进行持久化数据时使用 org.springframework.orm.hibernate3.HibernateTransactionManager 使用Hibernate版本进行持久化数据时使用 2.1.2 TransactionDefinition它是事务的定义信息对象，里面有如下方法： 2.1.2.1 事务的隔离级别 2.1.2.2 事务的传播行为1234567REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起NEVER:以非事务方式运行，如果当前存在事务，抛出异常NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类似的操作。 2.1.2.3 超时时间默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 2.1.2.4 是否是只读事务建议查询时设置为只读 2.1.3 TransactionStatus此接口提供的是事务具体的运行状态，方法介绍如下图： 2.2 基于XML的声明式事务控制（配置方式）2.2.1 环境搭建2.2.1.1 拷贝必要的jar 2.2.1.2 创建spring的配置文件并导入约束123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;/beans&gt; 2.2.1.3 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 2.2.1.4 编写业务层接口和实现类1234567891011121314151617181920/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 根据id查询账户信息 * @param id * @return */ Account findAccountById(Integer id);//查 /** * 转账 * @param sourceName 转出账户名称 * @param targeName 转入账户名称 * @param money 转账金额 */ void transfer(String sourceName,String targeName,Float money);//增删改&#125; 123456789101112131415161718192021222324252627282930/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 2.2.1.5 编写Dao接口和实现类123456789101112131415161718192021222324/** * 账户的持久层接口 */public interface IAccountDao &#123; /** * 根据id查询账户信息 * @param id * @return */ Account findAccountById(Integer id); /** * 根据名称查询账户信息 * @return */ Account findAccountByName(String name); /** * 更新账户信息 * @param account */ void updateAccount(Account account);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 账户的持久层实现类 * 此版本dao，只需要给它的父类注入一个数据源 */public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where id = ? \",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where name = ? \",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一，不是只有一个账户对象\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; getJdbcTemplate().update(\"update account set money = ? where id = ? \",account.getMoney(),account.getId()); &#125;&#125;/** * 账户的封装类RowMapper的实现类 */public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(\"id\")); account.setName(rs.getString(\"name\")); account.setMoney(rs.getFloat(\"money\")); return account; &#125;&#125; 2.2.1.6 在配置文件中配置业务层和持久层123456789101112131415161718&lt;!-- 配置service --&gt;&lt;bean id=\"accountService\" class=\"com.wgy.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 配置dao --&gt;&lt;bean id=\"accountDao\" class=\"com.wgy.dao.impl.AccountDaoImpl\"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 配置数据源 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.2 配置步骤2.2.2.1 配置事务管理器12345&lt;!-- 配置一个事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入DataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.2.2 配置事务的通知引用事务管理器123&lt;!-- 事务的配置 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt;&lt;/tx:advice&gt; 2.2.2.3 配置事务的属性12345678910111213&lt;!--在tx:advice标签内部 配置事务的属性 --&gt;&lt;tx:attributes&gt; &lt;!-- 指定方法名称：是业务核心方法 read-only：是否是只读事务。默认false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。 --&gt; &lt;tx:method name=\"*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt;&lt;/tx:attributes&gt; 2.2.2.4 配置AOP-切入点表达式12345&lt;!-- 配置aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt;&lt;/aop:config&gt; 2.2.2.5 配置切入点表达式和事务通知的对应关系12&lt;!-- 在aop:config标签内部：建立事务的通知和切入点表达式的关系 --&gt;&lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; 2.2.2.6 完整配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"accountService\" class=\"com.wgy.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id=\"accountDao\" class=\"com.wgy.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SPRING内置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring基于XML的声明式事务控制 --&gt; &lt;!-- 第一步：配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第二步：配置事务的通知 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 第四步：配置事务的属性 isolation：配置事务的隔离级别。默认值：DEFAULT，使用数据库的默认隔离级别。mysql是REPEATABLE_READ propagation：配置事务的传播行为。默认值是：REQUIRED。 一般的选择。（增删改方法）。当是查询方法时，选择SUPPORTS timeout：指定事务的超时时间。默认值是：-1，永不超时。当指定其他值时，以秒为单位 read-only：配置是否只读事务。默认值是：false，读写型事务。 当指定为true时，表示只读，只能用于查询方法。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常时，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当执行产生该异常时，事务不回滚。产生其他异常时，事务回滚。没有默认值，任何异常都回滚。 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 第三步：配置aop 要配的是：切入点表达式 通知和切入点表达式的关联 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt; &lt;!-- 配置事务通知和切入点表达式的关联 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.3 基于XML和注解组合使用的整合方式2.3.1 环境搭建2.3.1.1 拷贝必备的jar 2.3.1.2 spring的配置文件导入约束并配置扫描的包1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置spring要扫描的包 --&gt; &lt;context:component-scan base-package=\"com.wgy\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 2.3.1.3 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 2.3.1.4 业务层实现类使用注解让spring管理123456789101112131415161718192021222324252627/** * 账户的业务层实现类 */@Service(\"accountService\")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 2.3.1.5 Dao实现类使用注解让spring管理1234567891011121314151617181920212223242526272829303132@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountId); return list.isEmpty() ? null : list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where name = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (list.isEmpty()) &#123; //没有这个名称的账户 return null; &#125; if (list.size() &gt; 1) &#123; //结果集不唯一，不符合我们的约定 throw new RuntimeException(\"结果集不唯一，请检查数据\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set name=?,money=? where id=?\", account.getName(), account.getMoney(), account.getId()); &#125;&#125; 2.3.2 配置步骤2.3.2.1 配置数据源和JdbcTemplate123456789101112&lt;!-- 配置jdbcTemplate --&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置SPRING内置数据源 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.3.2.2 配置事务管理器并注入数据源1234&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.3.2.3 在业务层使用@Transactional注解1234567&lt;!-- 在需要事务的地方使用@Transactional注解 该注解可以写在接口上，类上和方法上。 写在接口上，表示该接口的所有实现类都有事务。 写在类上，表示该类中所有方法都有事务。 写在方法，表示该方法有事务。 优先级：就近原则。方法&gt;类&gt;接口--&gt; 12345678910111213141516171819202122232425262728@Service(\"accountService\")@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)//只读型public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; @Override @Transactional(propagation=Propagation.REQUIRED,readOnly=false)//读写型 public void transfer(String sourceName, String targetName, Float money) &#123; //1.根据名称查询账户信息 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); //2.转出账户减钱，转入账户加钱 source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); //3.更新账户信息 accountDao.updateAccount(source); int i = 1 / 0; accountDao.updateAccount(target); &#125;&#125; 2.3.2.4 在配置文件中开启spring对注解事务的支持12&lt;!-- 开启spring对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 2.4 基于纯注解的声明式事务控制（配置方式）2.4.1 环境搭建2.4.1.1 拷贝必备的jar包 2.4.1.2 创建一个类用于加载spring的配置并指定要扫描的包12345678/** * 用于初始化spring容器的配置类 */@Configuration@ComponentScan(basePackages=\"com.wgy\")public class SpringConfiguration &#123;&#125; 2.4.1.3 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 2.4.1.4 业务层实现类使用注解让spring管理123456789101112131415161718192021222324252627/** * 账户的业务层实现类 */@Service(\"accountService\")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 2.4.1.5 Dao实现类使用注解让spring管理1234567891011121314151617181920212223242526272829303132@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountId); return list.isEmpty() ? null : list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where name = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (list.isEmpty()) &#123; //没有这个名称的账户 return null; &#125; if (list.size() &gt; 1) &#123; //结果集不唯一，不符合我们的约定 throw new RuntimeException(\"结果集不唯一，请检查数据\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set name=?,money=? where id=?\", account.getName(), account.getMoney(), account.getId()); &#125;&#125; 2.4.2 配置步骤2.4.2.1 使用@Bean注解配置数据源和JdbcTemplate12345678910111213141516171819202122/** * 连接数据库的配置类 * * @author wgy */public class JdbcConfig &#123; @Bean(name = \"jdbcTemplate\") public JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = \"dataSource\") public DataSource createDataSource() &#123; DriverManagerDataSource ds = new DriverManagerDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; &#125;&#125; 2.4.2.2 使用@Bean注解配置配置事务管理器123456789101112/** * 事务控制的配置类 * * @author wgy */public class TransactionManager &#123; @Bean(name = \"transactionManager\") public PlatformTransactionManager createTransactionManager(DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 2.4.2.3 在业务层使用@Transactional注解1234567&lt;!-- 在需要事务的地方使用@Transactional注解 该注解可以写在接口上，类上和方法上。 写在接口上，表示该接口的所有实现类都有事务。 写在类上，表示该类中所有方法都有事务。 写在方法，表示该方法有事务。 优先级：就近原则。方法&gt;类&gt;接口--&gt; 12345678910111213141516171819202122232425262728@Service(\"accountService\")@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)//只读型public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; @Override @Transactional(propagation=Propagation.REQUIRED,readOnly=false)//读写型 public void transfer(String sourceName, String targetName, Float money) &#123; //1.根据名称查询账户信息 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); //2.转出账户减钱，转入账户加钱 source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); //3.更新账户信息 accountDao.updateAccount(source); int i = 1 / 0; accountDao.updateAccount(target); &#125;&#125; 2.4.2.4 使用@EnableTransactionManagement开启spring对注解事务的的支持123456789101112/** * spring的配置类，作用就是当bean.xml用 * * @author wgy */@Configuration@ComponentScan(\"com.wgy\")@Import(&#123;JdbcConfig.class, TransactionManager.class&#125;)@EnableTransactionManagementpublic class SpringConfiguration &#123;&#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Spring(三)","date":"2020-06-13T10:27:26.000Z","path":"archives/680971a4.html","text":"1. AOP的相关概念1.1 AOP概述1.1.1 什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.1.2 AOP的作用及优势作用： 在程序运行期间，不修改源码对已有方法进行增强。 优势： 减少重复代码 提高开发效率 维护方便 1.1.3 AOP的实现方式使用动态代理技术 1.2 AOP的具体应用1.2.1 案例中问题这是我们之前在struts2课程中做的一个完整的增删改查例子。下面是客户的业务层接口和实现类。 通过下面的代码，我们能看出什么问题吗? 123456789101112131415161718/** * 客户的业务层接口 */public interface ICustomerService &#123; /** * 保存客户 * @param customer */ void saveCustomer(Customer customer); /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 客户的业务层实现类 * 事务必须在此控制 * 业务层都是调用持久层的方法 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public void saveCustomer(Customer customer) &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); customerDao.saveCustomer(customer); tx.commit(); &#125;catch(Exception e)&#123; tx.rollback(); throw new RuntimeException(e); &#125; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); List&lt;Customer&gt; customers = customerDao.findAllCustomer(); tx.commit(); return customers; &#125;catch(Exception e)&#123; tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 上面代码的问题就是：我们的事务控制是重复性的代码。这还只是一个业务类，如果有多个业务了，每个业务类中都会有这些重复性的代码。 1.2.2 动态代理回顾1.2.2.1 动态代理的特点123字节码随用随创建，随用随加载。它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。装饰者模式就是静态代理的一种体现。 1.2.2.2 动态代理常用的有两种方式123456基于接口的动态代理 提供者：JDK官方的Proxy类。 要求：被代理类最少实现一个接口。基于子类的动态代理 提供者：第三方的CGLib，如果报asmxxxx异常，需要导入asm.jar。 要求：被代理类不能用final修饰的类（最终类）。 1.2.2.3 使用JDK官方的Proxy类创建代理对象 此处我们使用的是一个演员的例子： 在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。 而随着时间的推移，产生了一个新兴职业：经纪人（中间人），这个时候剧组再想找演员就需要通过经纪人来找了。下面我们就用代码演示出来。 1234567891011121314151617/** * 一个经纪公司的要求: * 能做基本的表演和危险的表演 */public interface IActor &#123; /** * 基本演出 * @param money */ public void basicAct(float money); /** * 危险演出 * @param money */ public void dangerAct(float money);&#125; 1234567891011121314/** * 一个演员 * 实现了接口，就表示具有接口中的方法实现。即：符合经纪公司的要求 */public class Actor implements IActor&#123; public void basicAct(float money)&#123; System.out.println(\"拿到钱，开始基本的表演：\"+money); &#125; public void dangerAct(float money)&#123; System.out.println(\"拿到钱，开始危险的表演：\"+money); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 模拟一个剧组 * * @author wgy */public class Client &#123; public static void main(String[] args) &#123; //一个剧组找演员 final Actor actor = new Actor(); /** * 动态代理： * 作用：不改变源码的基础上，对已有方法增强。（它是AOP思想的实现技术） * 分类： * 基于接口的动态代理： * 要求：被代理类最少实现一个接口 * 提供者：JDK官方 * 涉及的类：Proxy * 创建代理对象的方法：newProxyInstance(ClassLoader,Class[],InvocationHandler) * 参数的含义： * ClassLoader：类加载器。和被代理对象使用相同的类加载器。一般都是固定写法。 * Class[]：字节码数组。被代理类实现的接口。（要求代理对象和被代理对象具有相同的行为）。一般都是固定写法。 * InvocationHandler：它是一个接口，就是用于我们提供增强代码的。我们一般都是些一个该接口的实现类。实现类可以是匿名内部类。 * 它的含义就是：如何代理。此处的代码只能是谁用谁提供。 * 策略模式： * 使用要求：数据已经有了 * 目的明确 * 达成目标的过程就是策略。 * 在dbutils中的ResultSetHandler就是策略模式的具体应用。 * * 基于子类的动态代理 * */ IActor proxyActor = (IActor) Proxy.newProxyInstance(actor.getClass().getClassLoader(), actor.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 执行被代理对象的任何方法都会经过该方法，该方法有拦截的功能 * 方法的参数 * Object proxy：代理对象的引用。不一定每次都会有。 * Method method：当前执行的方法 * Object[] args：当前执行方法所需的参数 * 返回值： * 当前执行方法的返回值 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object rtValue = null; //1.取出执行方法中的参数：给的多少钱 Float money = (Float)args[0]; //2.判断当前执行的是什么方法：每个经纪公司对不同演出收费不一样，此处开始判断 if(\"basicAct\".equals(method.getName()))&#123; //基本演出，没有10000不演 if(money &gt; 10000)&#123; //执行方法（开始表演） //看上去剧组是给了20000，实际到演员手里只有10000 //这就是我们没有修改原来basicAct方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; if(\"dangerAct\".equals(method.getName()))&#123; //危险演出，没有50000不演 if(money &gt; 50000)&#123; //执行方法 //看上去剧组是给了60000，实际到演员手里只有30000 //这就是我们没有修改原来dangerAct方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;);// 没有经纪公司的时候，直接找演员。// actor.basicAct(1000f);// actor.dangerAct(5000f);// 剧组无法直接联系演员，而是由经纪公司找的演员 proxyActor.basicAct(20000); proxyActor.dangerAct(60000); &#125;&#125; 1.2.2.4 使用CGLib的Enhancer类创建代理对象还是那个演员的例子，只不过不让他实现接口。 12345678910111213141516171819202122232425/** * 一个演员 * * @author wgy */public class Actor &#123; /** * 基本的演出 * * @param money */ public void basicAct(float money) &#123; System.out.println(\"CGLIB拿到钱，开始基本的表演：\" + money); &#125; /** * 危险的表演 * * @param money */ public void dangerAct(float money) &#123; System.out.println(\"CGLIB拿到钱，开始危险的表演：\" + money); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 模拟一个剧组 * * @author wgy */public class Client &#123; public static void main(String[] args) &#123; final Actor actor = new Actor(); /** * 动态代理： * 作用：不改变源码的基础上，对已有方法增强。（它是AOP思想的实现技术） * 分类： * 基于接口的动态代理： * * 基于子类的动态代理： * 要求：被代理类不能是最终类。不能被final修饰 * 提供者：第三方CGLib * 涉及的类：Enhancer * 创建代理对象的方法：create(Class,Callback); * 参数的含义： * Class：被代理对象的字节码 * Callback：如何代理。它和InvocationHandler的作用是一样的。它也是一个接口，我们一般使用该接口的子接口MethodInterceptor * 在使用时我们也是创建该接口的匿名内部类。 * */ Actor cglibActor = (Actor) Enhancer.create(actor.getClass(), new MethodInterceptor() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。它和基于接口动态代理的invoke方法的作用是一模一样的。 * 方法的参数; * 前面三个和invoke方法的参数含义和作用都一样。 * MethodProxy methodProxy：当前执行方法的代理对象。一般不用 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object rtValue = null; //1.取出执行方法中的参数：给的多少钱 Float money = (Float)args[0]; //2.判断当前执行的是什么方法 if(\"basicAct\".equals(method.getName()))&#123; //基本演出 if(money &gt; 10000)&#123; //执行方法（开始表演） rtValue = method.invoke(actor, money/2); &#125; &#125; if(\"dangerAct\".equals(method.getName()))&#123; //危险演出 if(money &gt; 50000)&#123; //执行方法 rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;); cglibActor.basicAct(50000); cglibActor.dangerAct(100000); &#125;&#125; 1.2.3 解决案例中的问题思路只有一个：使用动态代理技术创建客户业务层的代理对象，在执行CustomerServiceImpl时，对里面的方法进行增强，加入事务的支持。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 用于创建客户业务层对象工厂（当然也可以创建其他业务层对象，只不过我们此处不做那么繁琐）*/public class BeanFactory &#123; /** * 获取客户业务层对象的代理对象 * @return */ public static ICustomerService getCustomerService() &#123; //定义客户业务层对象 final ICustomerService customerService = new CustomerServiceImpl(); //生成它的代理对象 ICustomerService proxyCustomerService = (ICustomerService) Proxy.newProxyInstance(customerService.getClass().getClassLoader() ,customerService.getClass().getInterfaces(), new InvocationHandler() &#123; //执行客户业务层任何方法，都会在此处被拦截，我们对那些方法增强，加入事务。 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String name = method.getName(); Object rtValue = null; try&#123; //开启事务 HibernateUtil.beginTransaction(); //执行操作 rtValue = method.invoke(customerService, args); //提交事务 HibernateUtil.commit(); &#125;catch(Exception e)&#123; //回滚事务 HibernateUtil.rollback(); e.printStackTrace(); &#125;finally&#123; //释放资源.hibernate在我们事务操作（提交/回滚）之后，已经帮我们关了。 //如果他没关，我们在此处关 &#125; return rtValue; &#125; &#125;); return proxyCustomerService; &#125;&#125; 1.3 Spring中的AOP1.3.1 关于代理的选择在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.3.2 AOP相关术语123456789101112131415161718Joinpoint(连接点): 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。Pointcut(切入点): 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。Advice(通知&#x2F;增强): 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。Introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。Target(目标对象): 代理的目标对象。Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。Proxy（代理）: 一个类被AOP织入增强后，就产生一个结果代理类。Aspect(切面): 是切入点和通知（引介）的结合。 1.3.3 学习spring中的AOP要明确的事123456a、开发阶段（我们做的） 编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。 把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP编程人员来做。 在配置文件中，声明切入点与通知间的关系，即切面。：AOP编程人员来做。b、运行阶段（Spring框架完成的） Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 2. 基于XML的AOP配置2.1 环境搭建2.1.1 准备客户的业务层和接口（需要增强的类）12345678910111213141516/** * 客户的业务层接口*/public interface ICustomerService &#123; /** * 保存客户 */ void saveCustomer(); /** * 修改客户 * @param i */ void updateCustomer(int i);&#125; 123456789101112131415/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"调用持久层，执行保存客户\"); &#125; @Override public void updateCustomer(int i) &#123; System.out.println(\"调用持久层，执行修改客户\"); &#125;&#125; 2.1.2 拷贝必备的jar包 2.1.3 创建spring的配置文件并导入约束12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 2.1.4 把客户的业务层配置到spring容器中12&lt;!-- 把资源交给spring来管理 --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"/&gt; 2.1.5 制作通知（增强的类）123456789101112131415/** * 一个用于记录日志的类 * * @author wgy */public class Logger &#123; /** * 记录日志的操作 * 计划让其在业务核心方法（切入点方法）执行之前执行 */ public void beforePrintLog() &#123; System.out.println(\"Logger中的printLog方法开始记录日志了。。。。\"); &#125;&#125; 2.2 配置步骤2.2.1 把通知类用bean标签配置起来12&lt;!-- 把通知类也交给spring来管理 --&gt;&lt;bean id=\"logger\" class=\"com.wgy.util.Logger\"&gt;&lt;/bean&gt; 2.2.2 使用aop:config声明aop配置1234&lt;!-- aop的配置 --&gt;&lt;aop:config&gt; &lt;!-- 配置的代码都写在此处 --&gt; &lt;/aop:config&gt; 2.2.3 使用aop:aspect配置切面1234567&lt;!-- 配置切面 ：此标签要出现在aop:config内部 id：给切面提供一个唯一标识 ref：引用的是通知类的bean的id--&gt;&lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!--配置通知的类型要写在此处--&gt;&lt;/aop:aspect&gt; 2.2.4 使用aop:before配置前置通知12345&lt;!-- 用于配置前置通知：指定增强的方法在切入点方法之前执行 method:用于指定通知类中的增强方法名称 ponitcut-ref：用于指定切入点的表达式的引用 --&gt;&lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"/&gt; 2.2.5 使用aop:pointcut配置切入点表达式1&lt;aop:pointcut expression=\"execution(public void com.wgy.service.impl.CustomerServiceImpl.saveCustomer())\" id=\"pt1\"/&gt; 2.3 切入点表达式说明123456789101112131415161718192021222324252627execution: 匹配方法的执行(常用) execution(表达式)表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))写法说明： 全匹配方式： public void com.wgy.service.impl.CustomerServiceImpl.saveCustomer() 访问修饰符可以省略 void com.wgy.service.impl.CustomerServiceImpl.saveCustomer() 返回值可以使用*号，表示任意返回值 * com.wgy.service.impl.CustomerServiceImpl.saveCustomer() 包名可以使用*号，表示任意包，但是有几级包，需要写几个* * *.*.*.*.CustomerServiceImpl.saveCustomer() 使用..来表示当前包，及其子包 * com..CustomerServiceImpl.saveCustomer() 类名可以使用*号，表示任意类 * com..*.saveCustomer() 方法名可以使用*号，表示任意方法 * com..*.*() 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数 * com..*.*(*) 参数列表可以使用..表示有无参数均可，有参数可以是任意类型 * com..*.*(..) 全通配方式： * *..*.*(..) 实际开发中，我们一般情况下，我们都是对业务层方法进行增强： 所以写法：* com.wgy.service.impl.*.*(..) 2.4 完整配置123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt;&lt;/bean&gt; &lt;!-- 基于xml的aop配置步骤 ：要想使用spring的aop，必须导入aop的jar包--&gt; &lt;!-- 第一步：把通知类交给spring来管理 --&gt; &lt;bean id=\"logger\" class=\"com.wgy.utils.Logger\"&gt;&lt;/bean&gt; &lt;!-- 第二步：导入aop名称空间，并且使用aop:config开始aop的配置 --&gt; &lt;aop:config&gt; &lt;!-- 定义通用的切入点表达式，如果写在aop:aspct标签外部，则表示所有切面可用 --&gt; &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt; &lt;!-- 第三步：使用aop:aspect配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 第四步：配置通知的类型，指定增强的方法何时执行。--&gt; &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:before&gt; &lt;!-- 定义通用的切入点表达式：如果是写在了aop:aspect标签内部，则表示只有当前切面可用 &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt;--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.5 通知的类型2.5.1 类型说明1234567891011121314151617&lt;!-- 配置通知的类型 aop:before： 用于配置前置通知。前置通知的执行时间点：切入点方法执行之前执行 aop:after-returning： 用于配置后置通知。后置通知的执行时间点：切入点方法正常执行之后。它和异常通知只能有一个执行 aop:after-throwing 用于配置异常通知。异常通知的执行时间点：切入点方法执行产生异常后执行。它和后置通知只能执行一个。 aop:after 用于配置最终通知。最终通知的执行时间点：无论切入点方法执行时是否有异常，它都会在其后面执行。 aop:around 用于配置环绕通知。他和前面四个不一样，他不是用于指定通知方法何时执行的。--&gt; &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:around method=\"aroundPringLog\" pointcut-ref=\"pt1\"/&gt; 2.5.2 环绕通知的特殊说明1234567891011121314151617181920212223242526272829/** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而环绕通知里的代码执行了。 * 分析： * 由动态代理可知，环绕通知指的是invoke方法，并且里面有明确的切入点方法调用。而我们现在的环绕通知没有明确切入点方法调用。 * 解决： * spring为我们提供了一个接口：ProceedingJoinPoint。该接口可以作为环绕通知的方法参数来使用。 * 在程序运行时，spring框架会为我们提供该接口的实现类，供我们使用。 * 该接口中有一个方法，proceed()，它的作用就等同于method.invoke方法，就是明确调用业务层核心方法（切入点方法） * * 环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制通知方法什么时候执行的方式。 */public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。前置\"); rtValue = pjp.proceed(); System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。后置\"); &#125; catch (Throwable e) &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。异常\"); e.printStackTrace(); &#125;finally&#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。最终\"); &#125; return rtValue;&#125; 3. 基于注解的AOP配置3.1 环境搭建3.1.1 准备客户的业务层和接口（需要增强的类）12345678910111213141516/** * 客户的业务层接口*/public interface ICustomerService &#123; /** * 保存客户 */ void saveCustomer(); /** * 修改客户 * @param i */ void updateCustomer(int i);&#125; 123456789101112131415/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"调用持久层，执行保存客户\"); &#125; @Override public void updateCustomer(int i) &#123; System.out.println(\"调用持久层，执行修改客户\"); &#125;&#125; 3.1.2 拷贝必备的jar包 3.1.3 创建spring的配置文件并导入约束12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;/beans&gt; 3.1.4 把资源使用注解让spring来管理123456789101112131415/** * 客户的业务层实现类 */@Service(\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"调用持久层，执行保存客户\"); &#125; @Override public void updateCustomer(int i) &#123; System.out.println(\"调用持久层，执行修改客户\"); &#125;&#125; 3.1.5 在配置文件中指定spring要扫描的包12&lt;!-- 告知spring，在创建容器时要扫描的包 --&gt;&lt;context:component-scan base-package=\"com.wgy\"&gt;&lt;/context:component-scan&gt; 3.2 配置步骤3.2.1 把通知类也使用注解配置1234567/** * 一个记录日志的工具类 */@Component(\"logger\")public class Logger &#123;&#125; 3.2.2 在通知类上使用@Aspect注解声明为切面12345678/** * 一个记录日志的工具类 */@Component(\"logger\")@Aspect//表明当前类是一个切面类public class Logger &#123; &#125; 3.2.3 在增强的方法上使用注解配置通知1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 一个用于记录日志的类 * * @author wgy */@Component(\"logger\")@Aspect//配置了切面public class Logger &#123; /** * 指定切入点表达式 */ @Pointcut(\"execution(* com.wgy.service.impl.*.*(..))\") private void pt1()&#123;&#125; /** * 前置通知 */// @Before(\"execution(* com.wgy.service.impl.*.*(..))\") public void beforePrintLog() &#123; System.out.println(\"前置：Logger中的beforePrintLog方法开始记录日志了。。。。\"); &#125; /** * 后置通知 */// @AfterReturning(\"pt1()\") public void afterReturningPrintLog() &#123; System.out.println(\"后置：Logger中的afterReturningPrintLog方法开始记录日志了。。。。\"); &#125; /** * 异常通知 */// @AfterThrowing(\"pt1()\") public void afterThrowingPrintLog() &#123; System.out.println(\"异常：Logger中的afterThrowingPrintLog方法开始记录日志了。。。。\"); &#125; /** * 最终通知 */// @After(\"pt1()\") public void afterPrintLog() &#123; System.out.println(\"最终：Logger中的afterPrintLog方法开始记录日志了。。。。\"); &#125; /** * 环绕通知 */ @Around(\"pt1()\") public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。前置\"); rtValue = pjp.proceed(); System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。后置\"); &#125; catch (Throwable e) &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。异常\"); e.printStackTrace(); &#125;finally&#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。最终\"); &#125; return rtValue; &#125;&#125; 3.2.4 在spring配置文件中开启spring对注解AOP的支持12&lt;!-- 开启spring对注解AOP的支持 --&gt;&lt;aop:aspectj-autoproxy/&gt; 3.3 不使用XML的配置方式123456@Configuration@ComponentScan(basePackages=\"com.wgy\")@EnableAspectJAutoProxypublic class SpringConfiguration &#123; &#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Spring(二)","date":"2020-06-11T06:53:10.000Z","path":"archives/16fa518f.html","text":"1. 基于注解的IOC配置1.1 写在最前学习基于注解的IoC配置，大家脑海里首先得有一个认知，即注解配置和xml配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 关于实际的开发中到底使用xml还是注解，每家公司有着不同的使用习惯。所以这两种配置方式我们都需要掌握。 1.2 环境搭建1.2.1 拷贝必备jar包注意：在基于xml的配置中，多拷贝一个aop的jar包。如下图： 1.2.2 在类的根路径下创建任意名称的xml文件12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 1.2.3 使用@Component注解配置管理的资源12345678910111213/** * 客户的业务层实现类 * * @author wgy */@Component(value=\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"执行了保存客户\"); &#125;&#125; 1.2.4 在Spring的配置文件中开启Spring对注解ioc的支持12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 告知spring在创建容器时要扫描的包。当配置了此标签之后，spring创建容器就会去指定的包及其子包下找对应的注解 标签是在一个context的名称空间里，所以必须先导入context名称空间 --&gt; &lt;context:component-scan base-package=\"com.wgy\"/&gt;&lt;/beans&gt; 1.3 常用注解1.3.1 用于创建bean对象1234567891011121314相当于：&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot;&gt;@Component 作用：就相当于配置了一个bean标签。 它能出现的位置：类上面 属性： value：含义是指定bean的id。当不写时，它有默认值，默认值是：当前类的短名首字母改小写。 由此注解衍生的三个注解： @Controller 一般用于表现的注解 @Service 一般用于业务层 @Repository 一般用于持久层 他们和@Component的作用及属性都是一模一样 细节：如果注解中有且只有一个属性要赋值时，且名称是value，value在赋值是可以不写。 1.3.2 用于注入数据的1234567891011121314151617181920212223242526相当于：&lt;property name&#x3D;&quot;&quot; ref&#x3D;&quot;&quot;&gt; &lt;property name&#x3D;&quot;&quot; value&#x3D;&quot;&quot;&gt;@Autowired 作用：自动按照类型注入。只要有唯一的类型匹配就能注入成功。 如果注入的bean在容器中类型不唯一时，它会把变量名称作为bean的id，在容器中查找，找到后也能注入成功。 如果没有找到一致的bean的id，则报错。 当我们使用注解注入时，set方法就不是必须的了。 @Qualifier 作用：在自动按照类型注入的基础之上，再按照bean的id注入。 它在给类成员注入数据时，不能独立使用。但是再给方法的形参注入数据时，可以独立使用。 属性： value：用于指定bean的id。 @Resource 作用：直接按照bean的id注入。 属性： name：用于指定bean的id。 以上三个注解都是用于注入其他bean类型的。用于注入基本类型和String类型需要使用Value@Value: 作用：用于注入基本类型和String类型数据。它可以借助Spring的el表达式读取properties文件中的配置。 属性： value：用于指定要注入的数据 1.3.3 用于改变作用范围的1234567相当于：&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot; scope&#x3D;&quot;&quot;&gt;@Scope 作用：用于改变bean的作用范围 属性： value：用于指定范围的取值。 取值和xml中scope属性的取值是一样的。singleton prototype request session globalsession 1.3.4 和生命周期相关的123456789相当于：&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot; init-method&#x3D;&quot;&quot; destroy-method&#x3D;&quot;&quot; &#x2F;&gt;@PostConstruct 作用： 用于指定初始化方法。@PreDestroy 作用： 用于指定销毁方法。 1.3.5 代码示例持久层 123456789101112131415161718192021222324/** * 客户的业务层实现类 * * @author wgy */@Service(\"customerService\")@Scope(\"singleton\")public class CustomerServiceImpl implements ICustomerService &#123; @Value(\"泰斯特\") private String name;// @Autowired// @Qualifier(\"customerDao1\") @Resource(name=\"customerDao\") private ICustomerDao customerDao = null; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层......\"+name); customerDao.saveCustomer(); &#125;&#125; 持久层 1234567891011121314/** * 模拟客户的持久层实现类 * * @author wgy */@Repository(\"customerDao\")public class CustomerDaoImpl implements ICustomerDao &#123; @Override public void saveCustomer() &#123; System.out.println(\"持久层保存了客户\"); &#125;&#125; 1.3.6 关于Spring注解和XML的选择问题1234注解的优势： 配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。XML的优势： 修改时，不用改源码。不涉及重新编译和部署。 Spring管理Bean方式的比较： 1.4 Spring的纯注解配置1.4.1 待改造的问题我们发现，之所以我们现在离不开xml配置文件，是因为我们有一句很关键的配置： 1234&lt;!-- 告知spring在创建容器时要扫描的包。当配置了此标签之后，spring创建容器就会去指定的包及其子包下找对应的注解 标签是在一个context的名称空间里，所以必须先导入context名称空间--&gt;&lt;context:component-scan base-package&#x3D;&quot;com.wgy&quot;&#x2F;&gt; 如果他要也能用注解配置，那么我们就可以脱离xml文件了。 1.4.2 使用注解配置要扫描的包创建配置类： 1234567891011/** * 一个spring的配置类 * 它的作用就相当于bean.xml * * @author wgy */@Configuration//它就是把当前类看成是spring的配置类@ComponentScan(&#123;\"com.wgy\"&#125;)//配置要扫描的包public class SpringConfiguration &#123; &#125; 测试类获取容器: 123456789public static void main(String[] args) &#123; //1.获取容器：由于我们已经没有了xml文件，所以再用读取xml方式就不能用了。 //这时需要指定加载哪个类上的注解 ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); //2.根据id获取对象 ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); cs.saveCustomer();&#125; 1.4.3 新注解说明1.4.3.1 @Configuration12345@Configuration 作用： 用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class)。 属性： value:用于指定配置类的字节码 1.4.3.2 @ComponentScan123456@ComponentScan 作用： 用于指定spring在初始化容器时要扫描的包。作用和在spring的xml配置文件中的： &lt;context:component-scan base-package&#x3D;&quot;com.wgy&quot;&#x2F;&gt;是一样的。 属性： basePackages：用于指定要扫描的包。和该注解中的value属性作用一样。 1.4.3.3 @PropertySource12345@PropertySource 作用： 用于加载.properties文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties配置文件中，就可以使用此注解指定properties配置文件的位置。 属性： value[]：用于指定properties文件位置。如果是在类路径下，需要写上classpath: 1.4.3.4 @Import12345@Import 作用： 用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration注解。当然，写上也没问题。 属性： value[]：用于指定其他配置类的字节码。 1.4.3.5 @Bean12345@Bean 作用： 该注解只能写在方法上，表明使用此方法创建一个对象，并且放入spring容器。它就相当于我们之前在xml配置中介绍的factory-bean和factory-method。 属性： name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id）。 1.4.3.6 代码示例jdbcConfig.properties: 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc.username=rootjdbc.password=root Jdbc的配置类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Jdbc的配置类 * * @author wgy */public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean(name = \"runner\")//它是把方法的返回值存入Spring容器中。该注解有一个属性，name：用于指定bean的id。当不指定时它有默认值，默认值是方法的名称。 public QueryRunner createQueryRunner(@Qualifier(\"ds1\") DataSource dataSource) &#123; return new QueryRunner(dataSource); &#125; @Bean(name = \"ds\") public DataSource createDataSource() &#123; try &#123; System.out.println(driver);//com.mysql.jdbc.Driver ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; @Bean(name = \"ds1\") public DataSource createDataSource1() &#123; try &#123; System.out.println(url); ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 配置类: 123456789101112131415161718192021222324252627/** * 一个spring的配置类 * 它的作用就相当于bean.xml * * @author wgy */@Configuration//它就是把当前类看成是spring的配置类@ComponentScan(&#123;\"com.wgy\"&#125;)@Import(&#123;JdbcConfig.class&#125;)//导入其他配置类@PropertySource(&#123;\"classpath:config/jdbcConfig.properties\"&#125;)public class SpringConfiguration &#123; /** * Spring EL表达式失效问题： * 目前使用的版本是4.2.4,在spring4.3以前都需要提供一个占位符配置器： * PropertySourcesPlaceholderConfigurer * 而在spring4.3以后，则不需要提供。 * 提供的方式如下：（在SpringConfiguration或JdbcConfig中配置均可） * * @return */ @Bean public static PropertySourcesPlaceholderConfigurer createPropertySourcesPlaceholderConfigurer()&#123; return new PropertySourcesPlaceholderConfigurer(); &#125;&#125; 2. Spring整合Junit2.1 准备测试环境2.1.1 创建业务层接口实现类123456789101112/** * 客户的业务层接口 */public interface ICustomerService &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao; public void setCustomerDao(ICustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125;&#125; 2.1.2 创建持久层接口实现类123456789101112/** * 客户的持久层接口 */public interface ICustomerDao &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 123456789101112/** * 客户的持久层实现类 */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; System.out.println(\"查询了所有客户\"); return null; &#125;&#125; 2.1.3 导入junit的jar包 2.1.4 编写测试类123456789101112/** * 测试客户的业务层和持久层 */public class CustomerServiceTest &#123; private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125;&#125; 2.2 使用xml配置步骤2.2.1 xml文件中的配置123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 把资源交给spring来管理 --&gt; &lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.2.2 拷贝整合junit的必备jar包 2.2.3 使用@RunWith注解替换原有运行器1234567891011@RunWith(SpringJUnit4ClassRunner.class)public class CustomerServiceTest &#123; private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125; &#125; 2.2.4 使用@ContextConfiguration指定spring配置文件的位置123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:bean.xml\"&#125;)public class CustomerServiceTest &#123; private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125; &#125; 2.2.5 使用@Autowired给测试类中的变量注入数据12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:bean.xml\"&#125;)public class CustomerServiceTest &#123; @Autowired private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125;&#125; 2.3 使用纯注解配置步骤2.3.1 拷贝整合junit的必备jar 2.3.2 把资源都用注解管理123456789101112131415/** * 客户的业务层实现类 */@Service(\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Autowired private ICustomerDao customerDao; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125;&#125; 12345678910111213/** * 客户的持久层实现类 */@Repository(\"customerDao\")public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; System.out.println(\"查询了所有客户\"); return null; &#125;&#125; 2.3.3 使用注解配置方式创建Spring容器12345678910111213@Configuration@ComponentScan(basePackages=&#123;\"com.wgy\"&#125;)public class CustomerServiceTest &#123; @Autowired private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125;&#125; 2.3.4 使用RunWith注解和ContextConfiguration注解配置123456789101112131415@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=&#123;CustomerServiceTest.class&#125;)@Configuration@ComponentScan(basePackages=&#123;\"com.wgy\"&#125;)public class CustomerServiceTest &#123; @Autowired private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125; &#125; 2.4 为什么不把测试类配到xml中 当我们在xml中配置了一个bean，Spring加载配置文件创建容器时，就会创建对象。 测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Spring(一)","date":"2020-06-10T15:26:00.000Z","path":"archives/b9cbcaed.html","text":"1. Spring概述1.1 Spring概述1.1.1 Spring介绍Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 1.1.2 Spring的发展历程1997年IBM提出了EJB的思想 1998年，SUN制定开发标准规范EJB1.0 1999年，EJB1.1发布 2001年，EJB2.0发布 2003年，EJB2.1发布 2006年，EJB3.0发布 Rod Johnson（spring之父） ​ Expert One-to-One J2EE Design and Development(2002) ​ 阐述了J2EE使用EJB开发设计的优点及解决方案 ​ Expert One-to-One J2EE Development without EJB(2004) ​ 阐述了J2EE开发不使用EJB的解决方式（Spring雏形） 1.1.3 Spring的优势方便解耦，简化开发 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀框架 Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。 降低JavaEE API的使用难度 Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 Java源码是经典学习范例 Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。 1.1.4 Spring的体系结构 1.2 程序的耦合和解耦1.2.1 什么是程序的耦合我们在开发中，会写很多的类，而有些类之间不可避免的产生依赖关系，这种依赖关系称之为耦合。 有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。请看下面的示例代码： 1234567/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); &#125; 上面的代码表示：业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。这种依赖关系就是我们可以通过优化代码解决的。 再比如： 下面的代码中，我们的类依赖了MySQL的具体驱动类，如果这时候更换了数据库品牌，我们需要改源码来修改数据库驱动。这显然不是我们想要的。 12345678910111213141516171819202122232425public class JdbcDemo1 &#123; /** * JDBC操作数据库的基本入门中存在什么问题？ * 导致驱动注册两次是个问题，但不是严重的。 * 严重的问题：是当前类和mysql的驱动类有很强的依赖关系。 * 当我们没有驱动类的时候，连编译都不让。 * 那这种依赖关系，就叫做程序的耦合 * * 我们在开发中，理想的状态应该是： * 我们应该尽力达到的：编译时不依赖，运行时才依赖。 * * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接 //3.获取预处理sql语句对象 //4.获取结果集 //5.遍历结果集 &#125;&#125; 1.2.2 解决程序耦合的思路当是我们讲解jdbc时，是通过反射来注册驱动的，代码如下： 1Class.forName(\"com.mysql.jdbc.Driver\"); 这时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除mysql的驱动jar包，依然可以编译。但是因为没有驱动类，所以不能运行。 不过，此处也有个问题，就是我们反射类对象的全限定类名字符串是在java类中写死的，一旦要改还是要修改源码。 解决这个问题也很简单，使用配置文件配置。 1.2.3 工厂模式解耦在实际开发中我们可以把所有的dao和service和action对象使用配置文件配置起来，当启动服务器应用加载的时候，通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 1.2.4 控制反转-Inversion Of Control上面解耦的思路有2个问题： 1、存哪去？ 分析：由于我们是很多对象，肯定要找个集合来存。这时候有Map和List供选择。 ​ 到底选Map还是List就看我们有没有查找需求。有查找需求，选Map。 所以我们的答案就是： ​ 在应用加载时，创建一个Map，用于存放action，Service和dao对象。 ​ 我们把这个map称之为容器。 2、还是没解释什么是工厂？ 工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 原来： ​ 我们在获取对象时，都是采用new的方式。是主动的。 现在： ​ 我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。 这种被动接收的方式获取对象的思想就是控制反转，它是Spring框架的核心之一。 它的作用只有一个：削减计算机程序的耦合。 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 2. 使用Spring的IOC解决程序耦合2.1 案例的前期准备本章我们使用的案例是，客户的业务层和持久层的依赖关系解决。在开始Spring的配置之前，我们要先准备一下环境。由于我们是使用Spring解决依赖关系，并不是真正的要做增伤改查操作，所以此时我们没必要写实体类。并且我们在此处使用的是java工程，不是java web工程。 2.1.1 准备Spring的开发包1234567官网：http:&#x2F;&#x2F;spring.io&#x2F; 下载地址：http:&#x2F;&#x2F;repo.springsource.org&#x2F;libs-release-local&#x2F;org&#x2F;springframework&#x2F;spring解压:(Spring目录结构:) * docs :API和开发规范. * libs :jar包和源码. * schema :约束. 2.1.2 创建业务层接口和实现类123456789101112/** * 模拟：客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 保存客户 */ void saveCustomer();&#125; 12345678910111213141516/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl();//此处有依赖关系 @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\"); customerDao.saveCustomer(); &#125;&#125; 2.1.3 创建持久层接口和实现类12345678910111213/** * 模拟一个客户dao * * @author wgy */public interface ICustomerDao &#123; /** * 保存客户 */ void saveCustomer();&#125; 12345678910111213/** * 模拟客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public void saveCustomer() &#123; System.out.println(\"持久层保存了客户\"); &#125;&#125; 2.2 基于XML的配置（入门案例）2.2.1 拷贝必备的jar包 2.2.2 在类根路径下创建任意名称的xml文件12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 导入schema约束约束的位置在: ..\\spring-framework-4.2.4.RELEASE\\docs\\spring-framework-reference\\html\\xsd-configuration.html文件中。--&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 2.2.3 把资源交给spring来管理12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置资源：把对象的创建交给spring来管理 --&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"/&gt; &lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"/&gt;&lt;/beans&gt; 2.2.4 测试配置是否成功123456789101112131415161718192021/** * spring的入门案例 * * @author wgy */public class Client &#123; /** * ClassPahtXmlApplicationContext：它是只能加载类路径下的配置文件 我们用这个 * FileSystemXmlApplicationContext：它是可以加载磁盘任意位置的配置文件 * * @param args */ public static void main(String[] args) &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据bean的id获取对象 ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); cs.saveCustomer(); &#125;&#125; 2.3 Spring基于XML的IOC细节2.3.1 Spring中工厂的类结构图 2.3.1.1 Bean创建的两种规则1234BeanFactory: 提供的是一种延迟加载思想来创建bean对象。bean对象什么时候用什么时候创建ApplicationContext 提供的是一种立即加载思想来创建bean对象。只要一解析完配置文件，就立马创建bean对象。 123456789public static void main(String[] args) &#123; //1.获取容器 Resource resource = new ClassPathResource(\"bean.xml\"); BeanFactory factory = new XmlBeanFactory(resource); //2.根据bean的id获取对象 ICustomerService cs = (ICustomerService) factory.getBean(\"customerService\"); cs.saveCustomer();&#125; 2.3.2 IOC中bean标签和管理对象细节2.3.2.1 bean标签12345678910111213作用： 用于配置对象让Spring来创建的。 默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。属性： id：给对象在容器中提供一个唯一标识。用于获取对象。 class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。 scope：指定对象的作用范围。 init-method：指定类中的初始化方法名称。 destroy-method：指定类中销毁方法名称。 &lt;bean id&#x3D;&quot;customerService&quot; class&#x3D;&quot;com.wgy.service.impl.CustomerServiceImpl&quot; scope&#x3D;&quot;singleton&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destroy&quot;&gt;&lt;&#x2F;bean&gt; 12345678910111213141516171819202122232425/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; public CustomerServiceImpl() &#123; System.out.println(\"bean对象创建了\"); &#125; public void init()&#123; System.out.println(\"对象初始化了\"); &#125; public void destroy()&#123; System.out.println(\"对象销毁了\"); &#125; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\"); &#125;&#125; 2.3.2.2 Bean的作用范围123456789Bean的作用范围： 它是可以通过配置的方式来调整作用范围。 配置的属性：bean标签的scope属性。 属性的取值： singleton：单例的（默认值） prototype：多例的（当我们让spring接管struts2的action创建时，action必须配置此值） request：作用范围是一次请求，和当前请求的转发。 session：作用范围是一次会话。 globalsession ：作用范围是一次全局会话。 2.3.2.3 Bean的生命周期123456789101112Bean的生命周期： 涉及bean标签的两个属性： init-method destroy-method 单例： 出生：容器创建，对象就出生了。 活着：只要容器在，对象就一直存在。 死亡：容器销毁，对象消亡。 多例： 出生：每次使用时，创建对象 活着：只要对象在使用中，就一直活着 死亡：当对象长时间不使用，并且也没有别的对象引用时，由java的垃圾回收器回收。 2.3.2.4 Bean的三种创建方式第一种方式：调用默认无参构造函数创建 此种方式用的最多 1234&lt;!--在默认情况下： 它会根据默认无参构造函数来创建类对象。如果bean中没有默认无参构造函数，则创建失败，会报异常 --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"/&gt; 第二种方式：使用静态工厂中的方法创建对象 1234567891011/** * 模拟一个静态工厂 * * @author wgy */public class StaticFactory &#123; public static ICustomerService getCustomerService() &#123; return new CustomerServiceImpl(); &#125;&#125; 123456789&lt;!-- 此种方式是: 使用StaticFactory类中的静态方法getCustomerService创建对象，并存入Spring容器 id属性：指定bean的id，用于从容器中获取 class属性：指定静态工厂的全限定类名 factory-method属性：指定生产对象的静态方法 --&gt;&lt;bean id=\"staticCustomerService\" class=\"com.wgy.factory.StaticFactory\" factory-method=\"getCustomerService\"&gt;&lt;/bean&gt; 第三种方式：使用实例工厂中的方法创建 1234567891011/** * 模拟一个实例工厂 * * @author wgy */public class InstanceFactory &#123; public ICustomerService getCustomerService() &#123; return new CustomerServiceImpl(); &#125;&#125; 12345678910&lt;!-- 此种方式是： 先把工厂的创建交给Spring来管理。 然后在使用工厂的bean来调用里面的方法 factory-bean属性：用于指定实例工厂bean的id。 factory-method属性：用于指定实例工厂中创建对象的方法。--&gt;&lt;bean id=\"instancFactory\" class=\"com.wgy.factory.InstanceFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"instanceCustomerService\" factory-bean=\"instancFactory\" factory-method=\"getCustomerService\"&gt;&lt;/bean&gt; 2.3.3 Spring的依赖注入它是spring框架核心ioc的具体实现方式。简单的说，就是坐等框架把对象传入，而不用我们自己去获取。 123456789Spring的依赖注入： 注入的方式有3三种： 第一种：使用构造函数注入 第二种：使用set方法注入 第三种：使用注解注入 注入的数据类型有3类： 第一类：基本类型和String类型 第二类：其他bean类型（必须是在spring的配置文件中出现过的bean） 第三类：复杂类型（集合类型） 2.3.3.1 构造函数注入就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置的方式，让Spring框架来为我们注入。具体代码如下： 123456789101112131415161718192021222324/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private String driver; private Integer port; private Date today; //以上三个类成员，没有具体的实际意义，只是用于演示注入。 public CustomerServiceImpl(String driver, Integer port, Date today) &#123; this.driver = driver; this.port = port; this.today = today; &#125; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\"+driver+\",\"+port+\",\"+today); &#125;&#125; 12345678910111213141516171819&lt;!-- 构造函数注入： 涉及的标签：constructor-arg 标签的属性： type:指定参数的类型。 index:指定参数的索引位置，从0开始。 name:指定参数的名称。 一般用它 ========上面三个属性是指定给哪个参数赋值的，下面两个属性是指定赋什么值的============== value:指定基本数据类型或String类型的数据 ref:指定其他bean类型数据 标签出现的位置： 写在bean标签内部 --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;constructor-arg name=\"driver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"port\" value=\"3306\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"today\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 2.3.3.2 set方法注入就是在类中提供需要注入成员的set方法。具体代码如下： 12345678910111213141516171819202122232425262728293031/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl2 implements ICustomerService &#123; private String driver; private Integer port; private Date today; //以上三个类成员，没有具体的实际意义，只是用于演示注入。 public void setDriver(String driver) &#123; this.driver = driver; &#125; public void setPort(Integer port) &#123; this.port = port; &#125; public void setToday(Date today) &#123; this.today = today; &#125; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\" + driver + \",\" + port + \",\" + today); &#125;&#125; 1234567891011121314151617&lt;!-- set方法注入 涉及的标签：property 标签的属性： name:指定参数的set方法名称。 =========上面三个属性是指定给哪个参数赋值的，下面两个属性是指定赋什么值的============ value:指定基本数据类型或String类型的数据 ref:指定其他bean类型数据 标签出现的位置： 写在bean标签内部 --&gt;&lt;bean id=\"customerService2\" class=\"com.wgy.service.impl.CustomerServiceImpl2\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"port\" value=\"3307\"&gt;&lt;/property&gt; &lt;property name=\"today\" ref=\"now\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 2.3.3.3 复杂类型的注入就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List,Set,Map,Properties。具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl3 implements ICustomerService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String, String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveCustomer() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 复杂类型的注入 结构相同，标签可以互换 List结构的： array,list,set Map结构的 map,entry,props,prop --&gt;&lt;bean id=\"customerService3\" class=\"com.wgy.service.impl.CustomerServiceImpl3\"&gt; &lt;property name=\"myStrs\"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;props&gt; &lt;prop key=\"testF\"&gt;FFF&lt;/prop&gt; &lt;prop key=\"testG\"&gt;GGG&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;map&gt; &lt;entry key=\"testD\" value=\"DDD\"&gt;&lt;/entry&gt; &lt;entry key=\"testE\"&gt; &lt;value&gt;EEE&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Struts2(四)","date":"2020-06-08T07:27:44.000Z","path":"archives/bb3a06c4.html","text":"1. Struts2中的拦截器1.1 Struts2的拦截器基本概念1.1.1 拦截器概述在Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者在定义的action执行的前后加入执行的代码，也可以在一个action执行前阻止其执行。也就是说它提供了一种可以提取action中可重用代码，统一管理和执行的方式。 拦截器链 （Interceptor Chain，在Struts 2中称为拦截器栈Interceptor Stack）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 拦截器和过滤器是有几分相似，但是也有区别： 过滤器是servlet规范中的一部分，任何java web工程都可以使用。 拦截器是struts2框架自己的，只有使用了struts2框架的工程才能用。 过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只有进入struts2核心内部之后，才会起作用，如果访问的是jsp，html,css,image或者js是不会进行拦截的。 同时，拦截器还是AOP编程思想的具体体现形式。AOP（Aspect-Oriented Programming）简单的说就是： 在不修改源码的基础上，已有的方法进行动态增强。 在struts2中，拦截器它就是对我们的动作方法进行增强。（其实就是把重复性的代码提取出来，然后放到拦截器中，统一管理，统一调用） 1.1.2 拦截器的执行时机在访问struts2核心内部时，在动作方法执行之前先正序执行，然后执行动作方法，执行完动作方法和结果视图之后，再倒序执行。所以它是先进后出，是个栈的结构。具体可参考下图： 1.2 自定义拦截器直接或间接的实现Interceptor接口 12345public interface Interceptor extends Serializable &#123; void init(); void destroy(); String intercept(ActionInvocation invocation) throws Exception;&#125; 该接口提供了三个方法，其具体介绍如下。 void init()：该方法在拦截器被创建后会立即被调用, 它在拦截器的生命周期内只被调用一次. 可以在该方法中对相关资源进行必要的初始化。 void destroy()：该方法与init方法相对应，在拦截器实例被销毁之前，将调用该方法来释放和拦截器相关的资源。它在拦截器的生命周期内，也只被调用一次。 String intercept(ActionInvocation invocation) throws Exception：该方法是拦截器的核心方法，用来添加真正执行拦截工作的代码，实现具体的拦截操作。它返回一个字符串作为逻辑视图，系统根据返回的字符串跳转到对应的视图资源。每拦截一个动作请求, 该方法就会被调用一次。该方法的ActionInvocation参数包含了被拦截的Action的引用，可以通过该参数的invoke()方法，将控制权转给下一个拦截器或者转给Action的execute()方法。 继承抽象拦截器类AbstractIntercepter 12345public abstract class AbstractInterceptor implements Interceptor &#123; public void init() &#123;&#125; public void destroy() &#123;&#125; public abstract String intercept(ActionInvocation invocation) throws Exception;&#125; AbstractInterceptor有一个子类MethodFilterInterceptor，该类中提供了两个属性，可以告知拦截器对哪些方法进行拦截或者对哪些方法排除。 1.2.1 第一步：编写普通java类，继承AbstractInterceptor123456789101112131415161718192021222324252627282930313233/** * 自定义拦截器 * 步骤： * 第一步：编写一个普通类，继承AbstractInterceptor（也可以实现Interceptor接口） * 第二步：配置拦截器 * &lt;!-- 声明一个拦截器 --&gt; * &lt;interceptors&gt; * &lt;interceptor name=\"myInterceptor\" class=\"com.itheima.web.interceptors.MyInterceptor\"&gt;&lt;/interceptor&gt; * &lt;/interceptors&gt; * &lt;!-- 引用拦截器：写在action标签的内部。当我们写了自己的拦截器引用时，默认的拦截器栈就失效了 --&gt; * &lt;interceptor-ref name=\"myInterceptor\"&gt;&lt;/interceptor-ref&gt; * 拦截器的放行： * invocation.invoke(); * 返回值的内容是： * 动作方法的返回值 * 关于结果视图的执行时机以及拦截器的返回值问题 * 在放行之前，拦截器的返回值可以控制显示哪个结果视图。一旦放行之后，它一定会显示动作方法返回值所匹配的结果视图，此时已经不管拦截器返回什么内容。 * 多个拦截器的执行顺序问题： * 是由引用顺序决定的，与声明顺序无关 * * @author wgy */public class MyInterceptor extends AbstractInterceptor &#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"访问Action之前：MyInterceptor拦截了。。。。\"); //放行 String rtValue = invocation.invoke(); System.out.println(\"访问Action之后：MyInterceptor拦截了。。。。\"); return rtValue; &#125;&#125; 1.2.2 第二步：在struts.xml中配置拦截器1234567891011121314151617181920&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;!-- 声明一个拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name&#x3D;&quot;myIntercepter&quot; class&#x3D;&quot;com.wgy.web.interceptors.MyInterceptor&quot;&#x2F;&gt; &lt;&#x2F;interceptors&gt; &lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;!-- 引用拦截器：当我们写了自己的拦截器引用时，默认的拦截器栈就失效了 --&gt; &lt;interceptor-ref name&#x3D;&quot;myIntercepter&quot;&#x2F;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 1.3 案例-检查登录拦截器1.3.1 定义拦截器123456789101112131415161718/** * 检查登录拦截器 * * @author wgy */public class CheckLoginInterceptor2 extends MethodFilterInterceptor &#123; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; Object obj = ServletActionContext.getRequest().getSession().getAttribute(\"userinfo\"); if(obj == null)&#123; //没登录，去登录 return \"login\"; &#125; //已登录，就放行 return invocation.invoke(); &#125;&#125; 1.3.2 配置拦截器12345678910111213141516171819&lt;package name&#x3D;&quot;myDefault&quot; extends&#x3D;&quot;struts-default&quot; abstract&#x3D;&quot;true&quot;&gt; &lt;!-- 声明拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name&#x3D;&quot;checkLogin&quot; class&#x3D;&quot;com.wgy.web.interceptors.CheckLoginInterceptor2&quot;&#x2F;&gt; &lt;!-- 定义一个自己的拦截器栈 --&gt; &lt;interceptor-stack name&#x3D;&quot;myDefaultStack&quot;&gt; &lt;interceptor-ref name&#x3D;&quot;checkLogin&quot;&gt; &lt;!-- 告知拦截器，哪些方法需要拦截，哪些方法不需要拦截 --&gt; &lt;param name&#x3D;&quot;excludeMethods&quot;&gt;userLogin&lt;&#x2F;param&gt; &lt;&#x2F;interceptor-ref&gt; &lt;interceptor-ref name&#x3D;&quot;defaultStack&quot;&#x2F;&gt; &lt;&#x2F;interceptor-stack&gt; &lt;&#x2F;interceptors&gt; &lt;!-- 把我们自定义的拦截器栈声明为默认拦截器栈 --&gt; &lt;default-interceptor-ref name&#x3D;&quot;myDefaultStack&quot;&#x2F;&gt; &lt;global-results&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt; &lt;&#x2F;global-results&gt;&lt;&#x2F;package&gt; 1.3.3 编写和配置Action动作类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BBSAction extends ActionSupport implements ServletRequestAware &#123; private HttpServletRequest request; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; /** * 娱乐 * @return */ public String demo1()&#123; System.out.println(request); return SUCCESS; &#125; /** * 体育 * @return */ public String demo2()&#123; System.out.println(request); return SUCCESS; &#125; /** * 军事 * @return */ public String demo3()&#123; System.out.println(request); return SUCCESS; &#125; /** * 登录方法 * @return */ public String userLogin()&#123; //往session域中存入一个登录标记 ServletActionContext.getRequest().getSession().setAttribute(\"userinfo\", \"\"); return SUCCESS; &#125;&#125; 配置 1234567891011121314151617&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;myDefault&quot;&gt; &lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;demo1.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;demo2&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;demo2&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;demo2.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;demo3&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;demo3&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;demo3.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;login&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;userLogin&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;redirect&quot;&gt;&#x2F;main.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 2. Struts2的注解配置2.1 使用前提Struts2框架，它不仅支持基于XML的配置方式，同时也支持基于注解配置的方式。 注解和XML的配置，都是告知struts2框架，当我们jsp页面发送请求，根据配置执行对应动作类的方法，并根据返回值，前往指定的结果视图（jsp页面或者其他动作）。它们只是配置的形式不一样。 其次要想使用struts2的注解，必须要导入一个新的jar包。该jar包是： struts2-convention-plugin-2.3.24.jar 2.2 常用注解2.2.1 @NameSpace1234567891011121314151617出现的位置： 它只能出现在package上或者Action类上。一般情况下都是写在Action类上。作用： 指定当前Action中所有动作方法的名称空间。属性： value：指定名称空间的名称。写法和xml配置时一致。不指定的话，默认名称空间是&quot;&quot;。示例：@Namespace(&quot;&#x2F;customer&quot;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.2.2 @ParentPackage1234567891011121314151617出现的位置： 它只能出现在package上或者Action类上。一般情况下都是写在Action类上。作用： 指定当前动作类所在包的父包。由于我们已经是在类中配置了，所以无需在指定包名了。属性： value：指定父包的名称。示例：@ParentPackage(&quot;struts-default&quot;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.2.3 @Action12345678910111213141516171819出现的位置： 它只能出现在Action类上或者动作方法上。一般情况下都是写在动作方法上。作用： 指定当前动作方法的动作名称。也就是xml配置时action标签的name属性。属性： value：指定动作名称。 results[]：它是一个数组，数据类型是注解。用于指定结果视图。此属性可以没有，当没有该属性时，表示不返回任何结果视图。即使用response输出响应正文。 interceptorRefs[]：它是一个数组，数据类型是注解。用于指定引用的拦截器。示例：&#x2F;** * 获取添加客户页面 * @return *&#x2F;@Action(value&#x3D;&quot;addUICustomer&quot;,results&#x3D;&#123; @Result(name&#x3D;&quot;addUICustomer&quot;,location&#x3D;&quot;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&quot;)&#125;)public String addUICustomer()&#123; return &quot;addUICustomer&quot;;&#125; 2.2.4 @Result123456789101112131415161718192021出现的位置： 它可以出现在动作类上，也可以出现在Action注解中。作用： 出现在类上，表示当前动作类中的所有动作方法都可以用此视图。 出现在Action注解中，表示当前Action可用此视图。属性： name：指定逻辑结果视图名称。 type：指定前往视图的方式。例如：请求转发，重定向，重定向到另外的动作。 location：指定前往的地址。可以是一个页面，也可以是一个动作。示例：&#x2F;** * 保存客户 * @return *&#x2F;@Action(value&#x3D;&quot;addCustomer&quot;,results&#x3D;&#123; @Result(name&#x3D;&quot;addCustomer&quot;,type&#x3D;&quot;redirect&quot;,location&#x3D;&quot;&#x2F;jsp&#x2F;success.jsp&quot;)&#125;)public String addCustomer()&#123; customerService.saveCustomer(customer); return &quot;addCustomer&quot;;&#125; 2.2.5 @Results1234567891011121314151617181920出现的位置： 它可以出现在动作类上，也可以出现在Action注解中。作用： 用于配置多个结果视图。属性： value：它是一个数组，数据类型是result注解。示例：@Results(&#123; @Result(name&#x3D;&quot;login&quot;,location&#x3D;&quot;&#x2F;login.jsp&quot;), @Result(name&#x3D;&quot;error&quot;,location&#x3D;&quot;&#x2F;error.jsp&quot;)&#125;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.2.6 @InterceptorRef123456789101112131415161718192021222324252627282930313233343536出现的位置： 它可以出现在动作类上或者Action注解中。作用： 用于配置要引用的拦截器或者拦截器栈属性： value：用于指定拦截器或者拦截器栈示例：出现在动作方法上：&#x2F;** * 查询所有客户 * @return *&#x2F;@Action(value&#x3D;&quot;findAllCustomer&quot;, results&#x3D;&#123; @Result(name&#x3D;&quot;findAllCustomer&quot;,location&#x3D;&quot;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&quot;) &#125;, interceptorRefs&#x3D;&#123; @InterceptorRef(&quot;myDefaultStack&quot;) &#125;)public String findAllCustomer()&#123; customers &#x3D; customerService.findAllCustomer(); return &quot;findAllCustomer&quot;;&#125;出现在动作类上：@InterceptorRef(&quot;myDefaultStack&quot;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.3 案例-注解实现客户保存和查询列表2.3.1 拷贝必备jar包导入jar包： struts2-convention-plugin-2.3.24.jar 2.3.2 使用注解配置Action1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 客户的动作类 * * @author wgy */@ParentPackage(\"struts-default\")//指定当前包的父包@Namespace(\"/customer\")@Results(&#123; @Result(name=\"customerList\",type=\"redirect\",location=\"findAllCustomer.action\"), @Result(name=\"error\",location=\"/jsp/error.jsp\"), @Result(name=\"addUICustomer\",location=\"/jsp/customer/add.jsp\"), @Result(name=\"findAllCustomer\",location=\"/jsp/customer/list.jsp\")&#125;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private ICustomerService customerService = new CustomerServiceImpl(); private Customer customer = new Customer(); private List&lt;Customer&gt; customers; @Override public Customer getModel() &#123; return customer; &#125; /** * 查询所有客户 * @return */ @Action(\"findAllCustomer\") public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.返回 return \"findAllCustomer\"; &#125; /** * 获取添加客户页面 * @return */ @Action(\"addUICustomer\") public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 添加客户 * @return */ @Action(\"addCustomer\") public String addCustomer()&#123; customerService.saveCustomer(customer); return \"customerList\"; &#125; /** * 删除客户 * @return */ @Action(\"deleteCustomer\") public String deleteCustomer()&#123; customerService.deleteCustomer(customer); return \"customerList\"; &#125; //------getters and setters-------------- public List&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers; &#125;&#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Struts2(三)","date":"2020-06-07T11:48:27.000Z","path":"archives/4179e9cb.html","text":"1. OGNL表达式1.1 OGNL表达式概述1.1.1 什么是OGNL表达式OGNL的全称是对象图导航语言（Object-Graph Navigation Language），它是一种功能强大的开源表达式语言，使用这种表达式语言，可以通过某种表达式语法，存取Java对象的任意属性，调用Java对象的方法，同时能够自动实现必要的类型转换。如果把表达式看作是一个带有语义的字符串，那么OGNL无疑成为了这个语义字符串与Java对象之间沟通的桥梁。 1.1.2 OGNL表达式的由来它原本是xwork2中的默认表达式语言，当年OpenSymphony和apache在合作开发struts2框架时，把这个表达式也引进来了，所以就变成了struts2的默认表达式语言。 1.1.3 OGNL表达式的使用要求要想使用ognl表达式，一般情况下都得需要使用struts2的标签库。 1&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt; 1.1.4 它的特点它不仅可以用于取值，显示。还可以赋值。取值是我们程序员使用框架做的事情。赋值是框架为我们做的。 1.2 OGNL表达式的基本用法1.2.1 s:property标签输出内容到浏览器1.2.1.1 s:property的用法12345678&lt;%--要想使用OGNL表达式获取数据，此时需要借助struts2的标签库 s:property标签实现把数据输出到浏览器上 &lt;s:property value=\"\"/&gt; value属性的取值是一个OGNL表达式。 标签会把value属性取值所对应的内容输出到浏览器上 如果没有任何对应内容，则什么都不显示--%&gt;OGNL的最基本用法：&lt;s:property value=\"OGNLExpression\"/&gt; 1.2.1.2 OGNL表达式和字符串的转换12345678910111213141516&lt;%--OGNL表达式和字符串的转换 表达式转成字符串 %&#123;''&#125; | %&#123;\"\"&#125; 可以把%&#123;&#125;去掉 --%&gt;OGNL转成一个普通的字符串：&lt;s:property value=\"%&#123;'OGNLExpression1'&#125;\"/&gt;&lt;br/&gt;OGNL转成一个普通的字符串：&lt;s:property value='%&#123;\"OGNLExpression2\"&#125;'/&gt;&lt;br/&gt;OGNL转成一个普通的字符串：&lt;s:property value='\"OGNLExpression3\"'/&gt;&lt;br/&gt;OGNL转成一个普通的字符串：&lt;s:property value=\"'OGNLExpression4'\"/&gt;&lt;br/&gt;&lt;!-- 字符串转成表达式 %&#123;&#125;把字符串套起来--&gt;&lt;!-- user.name 看上去是字符串，当它执行user对象的getName方法时，表示用OGNL表达式解释。 --&gt;字符串转成一个OGNL表达式：&lt;s:textfield name=\"username\" value=\"%&#123;user.name&#125;\"/&gt; 1.2.2 OGNL表达式访问对象的方法1234&lt;%--OGNL表达式访问对象的方法 --%&gt;调用字符串的长度方法：&lt;s:property value=\"'OGNLExpression1'.length()\"/&gt;&lt;br/&gt;调用字符串的转大写方法：&lt;s:property value=\"'OGNLExpression1'.toUpperCase()\"/&gt;&lt;br/&gt;调用字符串的分隔方法：&lt;s:property value=\"'OGNLExpression1'.split('E')\"/&gt;&lt;br/&gt; 1.2.3 OGNL表达式访问类的静态属性和静态方法123456&lt;%--OGNL表达式访问类的静态成员(静态属性) 访问静态属性需要按照固定的书写规范来写。 规范是： @包名.包名...类名@静态属性名称--%&gt;OGNL表达式访问静态属性：&lt;s:property value=\"@java.lang.Integer@MAX_VALUE\"/&gt; 123456&lt;%--OGNL表达式访问类的静态方法 访问静态方法需要按照固定的书写规范来写。 规范是： @包名.包名...类名@静态方法名称--%&gt;OGNL表达式访问静态方法：&lt;s:property value=\"@java.lang.Math@random()\"/&gt; 1.2.4 OGNL表达式操作集合1.2.4.1 list集合1234567891011&lt;%--操作List集合 s:radio标签的list取值就是一个OGNL表达式。 &#123;&#125;就表示创建了一个List集合 &#123;'男','女'&#125;=== List list = new ArrayList(); list.add(\"男\"); list.add(\"女\");--%&gt;Struts2的单选按钮：&lt;br/&gt;&lt;s:radio list=\"&#123;'男','女'&#125;\" name=\"gender2\" label=\"性别\"&gt;&lt;/s:radio&gt;HTML的单选按钮：&lt;br/&gt;性别：&lt;input type=\"radio\" name=\"gender1\" value=\"男\"&gt;男&lt;input type=\"radio\" name=\"gender1\" value=\"女\"&gt;女 1.2.4.2 map集合1234567891011&lt;%--操作Map集合 #&#123;&#125;就表示创建了一个Map集合。 #&#123;key:value,key:value&#125; #&#123;'male':'男','female':'女'&#125;=== Map map = new HashMap(); map.put(\"male\",\"男\"); map.put(\"female\",\"女\");--%&gt;Struts2的单选按钮：&lt;br/&gt;&lt;s:radio list=\"#&#123;'male':'男','female':'女'&#125;\" name=\"gender4\" label=\"性别\"&gt;&lt;/s:radio&gt;HTML的单选按钮：&lt;br/&gt;性别：&lt;input type=\"radio\" name=\"gender3\" value=\"male\"&gt;男&lt;input type=\"radio\" name=\"gender3\" value=\"female\"&gt;女 2. OGNL上下文2.1 ContextMap2.1.1 ContextMap概述它是OGNL上下文对象，是struts2中封装数据最大的对象。我们一次请求中所有用到的信息都可以在它里面找到。它是一个Map结构的对象，其中key是字符串，value是一个Object。 2.1.2 ContextMap中封装的数据 我们把这些内容拿出来逐个分析一下，得到下面的表格： Map的key（类型是String） Map的Value （类型是Object） 说明信息 application Java.util.Map&lt;String,Object&gt; 封装的应用域中的所有数据 session Java.util.Map&lt;String,Object&gt; 封装的会话域中的所有数据 request Java.util.Map&lt;String,Object&gt; 封装的请求域中的所有数据 valueStack(特殊) com.opensymphony.xwork2.ognl.OgnlValueStack 它是List结构 parameters Java.util.Map&lt;String,String[]&gt; 封装的是请求参数 attr Java.util.Map&lt;String,Object&gt; 封装的是四大域的组合数据，从最小的域开始搜索 action com.opensymphony.xwork2.ActionSupport 当前执行的动作类对象 2.2 ActionContext2.2.1 ActionContext对象概述它是一个工具类，是struts2框架提供给我们的，可以让我们调用其中的方法，快速的操作ContextMap。用它操作OGNL上下文对象，比直接操作ContextMap要方便很多。 2.2.2 ActionContext对象与ContextMap的关系ActionContext就相当于对ContextMap进行了一次再封装。 2.2.3 ActionContext何时创建由于ActionContext是操作的ContextMap，而ContextMap中封了我们一次请求的所有数据，所以它的创建应该是每次请求访问Action时，即核心控制器(StrutsPrepareAndExecuteFilter)的doFilter方法执行时，下图是代码截取： 2.2.4 ActionContext的线程安全我们都知道，java的web工程是多线程的，那么每个线程在访问Action时，都会创建自己的ActionContext,那么是如何保证在获取ActionContext时，每个线程都能获取到自己的那个呢？ 答案就是，每次创建ActionContext时，把对象绑定到当前线程上。下图是代码截取： 2.2.5 ActionContext的获取使用ActionContext类中的静态方法getContext()从当前线程上获取 2.2.6 获取ContextMap中的数据2.2.6.1 s:debug标签的使用123456&lt;%-- 引入标签库 --%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;%--1、struts2的debug标签 它是一个用于开发阶段的标签，查看我们OGNL上下文中内容的标签 --%&gt;&lt;s:debug/&gt; 2.2.6.2 使用OGNL表达式获取Map中的数据动作类存数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ActionContext的数据存取 * * @author wgy */public class Demo1Action extends ActionSupport &#123; /** * 通过ActionContext往ContextMap中存入数据 * contextMap hello context map * * 往应用域中存入数据：用两种方式实现 * applicationMap hello application map * applicationAttr hello application attr * * 往会话域中存入数据：同上用两种方式 * @return */ public String demo1()&#123; //1.获取ActionContext //从当前线程上获取 ActionContext context = ActionContext.getContext(); //2.存入数据 context.put(\"contextMap\", \"hello context map\"); //3.往应用域中存入数据 //第一种方式：使用原始ServletAPI对象ServletContext ServletContext applicationAttr = ServletActionContext.getServletContext(); applicationAttr.setAttribute(\"applicationAttr\", \"hello application attr\"); //第二种方式：根据key从ActionContext中获取应用域的map，往map中存入数据 Map&lt;String,Object&gt; applicationMap = context.getApplication(); applicationMap.put(\"applicationMap\",\"hello application map\"); //4.往会话域中存入数据 //第一种：使用ServletAPI的HttpSession HttpSession session = ServletActionContext.getRequest().getSession(); session.setAttribute(\"sessionAttr\", \"hello session attr\"); //第二种：获取key为session的map Map&lt;String,Object&gt; sessionMap = context.getSession(); sessionMap.put(\"sessionMap\",\"hello session map\"); return SUCCESS; &#125;&#125; 在页面中使用OGNL表达式获取： 1234567891011&lt;%--借助struts2的s:property标签和OGNL表达式获取ActionContext存入的数据 我们现在获取的数据，都是在map中。 获取Map中的数据，OGNL表达式的写法： #key 如果还想继续向下获取，使用.key的方式--%&gt;&lt;s:property value=\"#contextMap\"/&gt;&lt;br/&gt;&lt;s:property value=\"#application.applicationMap\"/&gt;&lt;br/&gt;&lt;s:property value=\"#session.sessionAttr\"/&gt;&lt;s:property value=\"#session.sessionMap\"/&gt; 2.3 ValueStack对象2.3.1 ValueStack对象概述ValueStack是Struts的一个接口，字面意义为值栈，OgnlValueStack是ValueStack的实现类，客户端发起一个请求struts2架构会创建一个action实例同时创建一个OgnlValueStack值栈实例，OgnlValueStack贯穿整个 Action 的生命周期。 它是ContextMap中的一部分，里面的结构是一个List，是我们可以快速访问数据一个容器。它的封装是由struts2框架完成的。 通常情况下我们是从页面上获取数据。它实现了栈的特性（先进后出）。 2.3.2 ValueStack的内部结构在 OnglValueStack 中包含了一个CompoundRoot的对象，该对象继承了ArrayList，并且提供了只能操作集合第一个元素的方法，所以我们说它实现了栈的特性。同时，它里面定义了一个ContextMap的引用，也就是说，我们有值栈对象，也可以通过值栈来获取ContextMap。 2.3.3 获取ValueStack中的数据2.3.3.1 值栈中都有什么首先我们要明确，值栈中存的都是对象。因为它本质就是一个List，List中只能存对象。 值栈中包含了我们通过调用push方法压栈的对象，当前执行的动作了和一个名称为DefaultTextProvider的类。值栈中的内容如下图： 2.3.3.2 在动作类中往值栈中存入数据12345678910111213141516171819202122232425262728293031/** * ValueStack的数据存取 * * @author wgy */public class Demo2Action extends ActionSupport &#123; //把私有成员放入值栈中 private String name = \"泰斯特\"; public String getName() &#123; return name; &#125; /** * 获取ValueStack，并且压栈操作 * @return */ public String demo2()&#123; //1.获取ActionContext //从当前线程上获取 ActionContext context = ActionContext.getContext(); //2.获取ValueStack对象 ValueStack vs = context.getValueStack(); //3.压栈操作 Student s = new Student(\"张三\",18,\"male\"); vs.push(s); return SUCCESS; &#125;&#125; 2.3.3.3 我们可以获取值栈中的什么一般情况下，我们都是根据debug标签中显示的Property Name来获取Property Value。 当然我们也可以获取栈顶对象。 2.3.3.5 在页面上使用OGNL表达式获取数据123456789101112131415&lt;%--获取值栈的数据也需要借助于struts2的标签库 使用s:property获取 获取值栈的数据，是直接写属性名称，得到的就是属性的值。 OGNL表达式的找法，是从栈顶逐个属性名称开始查找，只要找到之后，就不再继续查找，而是返回结果。 --%&gt;姓名：&lt;s:property value=\"name\"/&gt;&lt;br/&gt;年龄：&lt;s:property value=\"age\"/&gt;&lt;br/&gt;性别：&lt;s:property value=\"gender\"/&gt;&lt;br/&gt;&lt;%--获取指定位置的属性 --%&gt;获取第一个name:&lt;s:property value=\"[0].name\"/&gt;&lt;br/&gt;获取第二个name:&lt;s:property value=\"[1].name\"/&gt;&lt;%--如果使用s:property标签，没有写value属性，取的是栈顶对象 --%&gt;&lt;s:property/&gt; 2.3.3.6 OGNL表达式执行时调用的方法12345678910111213&lt;%--s:property在通过OGNL表达式获取数据时，所调用的方法：ValueStack中的findValue(String expr); --%&gt;&lt;% ActionContext context = ActionContext.getContext(); ValueStack vs = context.getValueStack(); Object o1 = vs.findValue(\"[0].name\"); out.println(o1); out.println(\"&lt;br/&gt;\"); Object o2 = vs.findValue(\"[1].name\"); out.print(o2); out.println(\"&lt;br/&gt;\"); Object o3 = vs.findValue(\"#application.applicationMap\"); out.print(o3);%&gt; 3. Struts2中使用EL表达式3.1 EL表达式回顾EL表达式的写法：${表达式}。 它是从四大域中，由小到大逐个域搜索，根据名称获取值。只要找到了，就不再继续搜索。 它的原理：使用的是PageContext类中的findValue方法。 3.2 Struts2对EL表达式的改变Struts2框架中对EL表达式做了如下改变： 1234EL表达式原来的搜素顺序： page Scope——&gt;request Scope——&gt;session Scope——&gt;application ScopeEL表达式改变后的搜索顺序： page Scope—&gt;request Scope—&gt;valueStack—&gt;contextMap—&gt;session Scope—&gt;application Scope struts2框架对request对象进行了包装，并且对getAttribute方法进行了增强，代码如下： 4. OGNL表达式中的各种符号总结4.1 %121、把OGNL表达式转成普通字符串 %&#123;&quot;&quot;&#125;2、把字符串转成OGNL表达式%&#123;&#125; 4.2 #121、获取ContextMap中的数据。#key2、在页面中可以创建Map集合。 #&#123;&#125; 4.3 $121、EL表达式使用2、可以在struts2的配置中使用OGNL表达式（配置可以是xml文件，也可以是注解）$&#123;&#125; 5. 案例-优化客户列表的展示5.1 改造Action我们把之前查询所有客户的动作方法改造一下，之前我们是把查询结果存入请求域中了，而此时我们只需要在Action中定义一个集合，并且提供get/set方法，它就会出现在值栈中。就可以在页面中使用OGNL表达式获取。 1234567891011121314151617181920/** * 查询所有客户 * @return */private List&lt;Customer&gt; customers;public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.返回 return \"findAllCustomer\";&#125;public List&lt;Customer&gt; getCustomers() &#123; return customers;&#125;public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers;&#125; 5.2 改造jsp在显示客户列表时，我们之前采用的是jstl标签库的c:forEach标签，今天我们将使用struts2提供的迭代标签s:iterator。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%-- &lt;c:forEach items=\"$&#123;customers&#125;\" var=\"customer\"&gt; &lt;TR&gt; &lt;TD&gt;$&#123;customer.custName &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custLevel &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custSource &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custIndustry &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custAddress &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custPhone &#125;&lt;/TD&gt; &lt;/TR&gt; &lt;/c:forEach&gt; --%&gt;&lt;%-- struts2中的迭代标签： 属性： value：它的取值是一个OGNL表达式 var：写了该属性：它会把var的值作为key，把当前遍历的对象作为value，存入contextMap中 没写该属性：它会把每次遍历的对象压入栈顶--%&gt;&lt;%-- &lt;s:iterator value=\"customers\" var=\"cust\"&gt; &lt;TR&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custName\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custLevel\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custSource\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custIndustry\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custAddress\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custPhone\"/&gt;&lt;/TD&gt; &lt;/TR&gt; &lt;/s:iterator&gt; --%&gt;&lt;s:iterator value=\"customers\"&gt; &lt;TR&gt; &lt;TD&gt;&lt;s:property value=\"custName\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custLevel\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custSource\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custIndustry\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custAddress\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custPhone\"/&gt;&lt;/TD&gt; &lt;/TR&gt;&lt;/s:iterator&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Struts2(二)","date":"2020-06-05T09:14:53.000Z","path":"archives/3f8ac9e0.html","text":"1. 结果视图的配置1.1 result标签在sturts.xml文件中，Result的配置非常简单，使用元素来配置Result逻辑视图与物理视图之间的映射，元素可以有name和type属性，但这两种属性都不是必选的。 1234567891011121314151617181920212223242526&lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;!-- result标签： 作用：用于配置结果视图（结果视图可以是一个jsp&#x2F;html，也可以是一个action） 属性： name：指定逻辑结果视图。作用就是和动作方法的返回值进行比较，当一致时，前往配置的页面或者action。不写的话:默认值是success——&gt;去哪 type：指定前往结果视图的方式。以何种方式前往。 ——&gt;怎么去 type取值都是来源于struts-default.xml文件中package名称是struts-default包中定义类型 常用的结果类型： dispatcher：请求转发 （默认值） redirect：重定向(可以是重定向到另外一个动作或者是重定向到一个jsp) redirectAction：重定向到另外一个动作(它由于会自动在后面为我们拼接url后缀，所以只能重定向到动作) 请求转发和重定向的区别： 请求转发：一次请求 地址栏不变 请求域中数据不丢失 服务器行为 只能是在当前应用中转发 重定向： 两次请求 地址栏改变 请求域中数据丢失 浏览器行为 可以定向到当前应用的外部 响应浏览器的三种方式： 请求转发 重定向 使用流输出（如果只有一种方式，那就是此种方式） --&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;redirectAction&quot;&gt;demo2&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;error&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;error.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt;&lt;action name&#x3D;&quot;demo2&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 1.2 配置全局结果视图1.2.1 局部结果视图和全局结果视图配置在action标签内的result，我们成为局部结果视图，它只能由当前action使用。 而在实际开发中，有很多页面，每个action可能都会用到。比如：success.jsp,error.jsp,login.jsp等等。当我们很多action都用到了login.jsp，在每个action标签中都配置一次，显然是不合理的，这个时候我们就用到了全局结果视图。 1.2.2 配置方式12345678910111213141516171819202122&lt;!-- 定义一个公共包 全局结果视图和局部结果视图 定义是放在action标签外面， 在global-results标签内部的结果视图。 可以在多个action中使用 优先级：先找局部，再找全局。--&gt;&lt;package name&#x3D;&quot;myDefault&quot; extends&#x3D;&quot;struts-default&quot; abstract&#x3D;&quot;true&quot;&gt; &lt;global-results&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt; &lt;&#x2F;global-results&gt;&lt;&#x2F;package&gt;&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;myDefault&quot;&gt; &lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;redirectAction&quot;&gt;demo2&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;demo2&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 2. 访问Servlet的API的两种方式2.1 使用ServletActionContext12345678910111213141516171819202122232425262728293031323334353637383940/** * 访问ServletAPI: * 有两种方式： * 第一种方式： * 使用struts2框架提供的一个工具类，该类中包含了相应的静态方法，可以直接获取 * 工具类是：ServletActionContext * 此种方式是我们实际开发中用的最多的方式 * * 输出结果之后，找出其中一个和其他三个不一样： * org.apache.struts2.dispatcher.StrutsRequestWrapper@1c6e453 它和其他三个不一样，它是struts2提供的 * org.apache.catalina.connector.ResponseFacade@b846ae * org.apache.catalina.core.ApplicationContextFacade@287809 * org.apache.catalina.session.StandardSessionFacade@e0d480 * * @author wgy */public class Demo1Action extends ActionSupport &#123; private HttpServletRequest request; private HttpServletResponse response; private HttpSession session; private ServletContext application; /** * 动作方法 * * @return */ public String demo1()&#123; request = ServletActionContext.getRequest(); response = ServletActionContext.getResponse(); application = ServletActionContext.getServletContext(); session = request.getSession(); System.out.println(request); System.out.println(response); System.out.println(application); System.out.println(session); return SUCCESS; &#125;&#125; 2.2 通过实现接口的方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 访问ServletAPI: * 有两种方式： * 第二种方式： * 通过实现不同的接口，获取不同的对象。 * 要想使用request，需要实现ServletRequestAware * 要想使用response，需要实现ServletResponseAware * 要想使用servletContext，需要实现SerlvetContextAware * 输出结果之后，找出其中一个和其他三个不一样： * org.apache.struts2.dispatcher.StrutsRequestWrapper@1c6e453 它和其他三个不一样，它是struts2提供的 * org.apache.catalina.connector.ResponseFacade@b846ae * org.apache.catalina.core.ApplicationContextFacade@287809 * org.apache.catalina.session.StandardSessionFacade@e0d480 * * * 如果说是一种方式获取ServletAPI对象：ActionContext中的get(key) * 如果说是三种方式获取ServletAPI对象，除了我们讲的两种之外，也可以使用ActionContext获取 * * 通过分析源码，我们得知，ActionContext看上去是一个类似Map的结构。 * map的key是String类型，Map的value是Object类型 * * @author wgy */public class Demo2Action extends ActionSupport implements ServletRequestAware, ServletResponseAware, ServletContextAware &#123; private HttpServletRequest request = null; private HttpServletResponse response = null; private ServletContext application = null; /** * 动作方法 * * @return */ public String demo2()&#123; System.out.println(request); System.out.println(response); System.out.println(application); return SUCCESS; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; @Override public void setServletResponse(HttpServletResponse response) &#123; this.response = response; &#125; @Override public void setServletContext(ServletContext application) &#123; this.application = application; &#125;&#125; 3. 请求参数的封装3.1 请求参数封装概述封装请求参数就是把我们通过浏览器发送请求时，要转递给服务器的数据封装到指定的对象中。这个对象一般都是实体类。但是有时就是Action中的一个属性。也就是说，我们封装请求参数时，可以有实体类，也可以没有。同时，我们还需要知道，请求参数的封装和请求方式无关。无论get还是post都可以封装。 3.2 属性驱动3.2.1 没有实体类此种情况，我们一般也称为动作类和模型在一起，也就是说我们在action中定义一些私有成员，并且提供它们的公有get/set方法。具体代码如下 动作类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 请求参数封装 * 第一种情况： * 属性驱动：没有实体类 * 表单数据的接收都定义在动作类中，所以称为动作类和模型数据写在一起 * 要想封装成功，需要按照要求书写： * 要求是：表单元素的name属性取值，必须和动作类中成员get/set方法后面的部分保持一致 * * 细节： * 1、struts2框架会我们解决post请求的中文乱码问题，但是get请求不解决。 * 2、struts2框架会自动为我们转换数据类型： * 基本类型自动转换 * 字符串数组会按照逗号+空格的方式拼接成字符串 * 日期类型会按照本地格式转成日期对象 * 本地格式：yyyy-MM-dd * * 执行参数封装，是一个名称为params的拦截器实现的。 * 封装的规则只有一个，它要去指定位置找属性，找到之后调用set方法赋值。 * * @author wgy */public class Demo1Action extends ActionSupport &#123; private String username; private Integer age; private Date birthday; private String hobby; /** * 动作方法 * * @return */ public String demo1()&#123; System.out.println(username+\"===\"+age+\"===\"+birthday+\"===\"+hobby); return SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125; jsp页面： 1234567891011&lt;%--请求参数封装：第一种情况：属性驱动-没有实体类 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo1.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.2.2 有实体类此种情况是，我们有独立的实体类，在action中定义的是实体类对象，并且提供get/set方法。代码如下： 动作类： 1234567891011121314151617181920212223242526272829303132333435363738/** * 请求参数封装 * 第二种情况： * 属性驱动：有实体类 * 表单数据的接收都定义在实体类中，把实体类定义在动作类中。 * 要想封装成功，需要按照要求书写： * 此时需要使用OGNL表达式来指定表单元素的name取值 * OGNL表达式全称：Object Graphic Navigation Language * 对象 图 导航 语言 * 写法： * user.username user.age * * 执行参数封装，是一个名称为params的拦截器实现的。 * 封装的规则只有一个，它要去指定位置找属性，找到之后调用set方法赋值。 * * @author wgy */public class Demo2Action extends ActionSupport &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; /** * 动作方法 * @return */ public String demo2()&#123; System.out.println(user); return SUCCESS; &#125;&#125; jsp页面： 1234567891011&lt;%--请求参数封装：第二种情况：属性驱动-有实体类 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo2.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"user.username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"user.birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"user.hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"user.hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"user.hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo2&quot; class&#x3D;&quot;com.wgy.web.action.Demo2Action&quot; method&#x3D;&quot;demo2&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3 模型驱动在Struts2中，Action处理请求参数还有另外一种方式，叫做模型驱动（ModelDriven）。通过实现ModelDriven接口来接收请求参数。 动作类： 12345678910111213141516171819202122232425262728293031323334/** * 请求参数封装 * 第三种情况： 我们在后面用的最多的方式 * 模型驱动 * 要想封装成功，需要按照要求书写： * 1、动作类必须实现ModelDriven接口 * 2、动作类中需要定义模型，并且必须实例化出来 * 3、提供接口抽象方法的实现，返回值必须是模型对象 * * 执行参数封装，是一个名称为params的拦截器实现的。 * 模型驱动的实现，除了params拦截器之外，还需要一个叫modelDriven的拦截器配合 * 封装的规则只有一个，它要去指定位置找属性，找到之后调用set方法赋值。 * * @author wgy */public class Demo3Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123; private User user = new User(); @Override public User getModel() &#123; return user; &#125; /** * 动作方法 * * @return */ public String demo3()&#123; System.out.println(user); return SUCCESS; &#125;&#125; jsp页面： 1234567891011&lt;%--请求参数封装：第三种情况：模型驱动 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo3.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo3&quot; class&#x3D;&quot;com.wgy.web.action.Demo3Action&quot; method&#x3D;&quot;demo3&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4 封装集合数据在实际的开发中，有些时候我们需要批量插入用户或者批量插入其他的对象，在Action中需要接受到这多个Action中封装的对象，然后传递给业务层。那么这个时候就需要将表单的数据封装到集合中。 3.4.1 封装到List动作类： 12345678910111213141516171819202122232425262728/** * 请求参数封装 * 复杂类型的封装：List集合封装 * 复杂类型的封装都需要基于第二种情况实现 * * @author wgy */public class Demo4Action extends ActionSupport &#123; private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; /** * 动作方法 * * @return */ public String demo4()&#123; System.out.println(users); return SUCCESS; &#125;&#125; jsp页面： 123456789101112131415161718&lt;%--请求参数封装：List集合类型的封装 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo4.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"users[0].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users[0].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users[0].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users[0].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users[0].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users[0].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; 姓名：&lt;input type=\"text\" name=\"users[1].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users[1].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users[1].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users[1].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users[1].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users[1].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo4&quot; class&#x3D;&quot;com.wgy.web.action.Demo4Action&quot; method&#x3D;&quot;demo4&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4.2 封装到Map动作类： 1234567891011121314151617181920212223242526272829/** * 请求参数封装 * 复杂类型的封装：Map集合封装 * 复杂类型的封装都需要基于第二种情况实现 * * @author wgy */public class Demo5Action extends ActionSupport &#123; private Map&lt;String, User&gt; users; public Map&lt;String, User&gt; getUsers() &#123; return users; &#125; public void setUsers(Map&lt;String, User&gt; users) &#123; this.users = users; &#125; /** * 动作方法 * * @return */ public String demo5()&#123; System.out.println(users); return SUCCESS; &#125;&#125; jsp页面： 123456789101112131415161718&lt;%--请求参数封装：Map集合类型的封装 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo5.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"users['key1'].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users['key1'].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users['key1'].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users['key1'].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users['key1'].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users['key1'].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; 姓名：&lt;input type=\"text\" name=\"users['abc'].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users['abc'].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users['abc'].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users['abc'].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users['abc'].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users['abc'].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo5&quot; class&#x3D;&quot;com.wgy.web.action.Demo5Action&quot; method&#x3D;&quot;demo5&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 4. 案例：Struts2+Hibernate实现保存删除客户4.1 Struts24.1.1 修改jspmenu.jsp 12345&lt;TR&gt; &lt;TD class=menuSmall&gt; &lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/addUICustomer.action\" target=main&gt;－ 新增客户&lt;/A&gt; &lt;/TD&gt;&lt;/TR&gt; add.jsp 123&lt;FORM id=form1 name=form1 action=\"$&#123;pageContext.request.contextPath &#125;/customer/addCustomer.action\" method=post&gt; ...&lt;/FORM&gt; list.jsp 123456789&lt;SCRIPT language=javascript&gt; function delOne(custId)&#123; var sure = window.confirm(\"确定删除吗？\"); if(sure)&#123; window.location.href = \"$&#123;pageContext.request.contextPath&#125;/customer/deleteCustomer?custId=\"+custId; &#125; &#125;&lt;/SCRIPT&gt;&lt;a href=\"javascript:delOne('$&#123;customer.custId&#125;')\" &gt;删除&lt;/a&gt; 4.1.2 配置xml并编写Actionstruts.xml的配置 12345678910111213141516171819202122232425262728293031&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; &lt;!-- 动作配置 --&gt; &lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;!-- 查询所有客户 --&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;!-- 获取添加客户页面 --&gt; &lt;action name&#x3D;&quot;addUICustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;addUICustomer&quot;&gt; &lt;result name&#x3D;&quot;addUICustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;!-- 添加客户 --&gt; &lt;action name&#x3D;&quot;addCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;addCustomer&quot;&gt; &lt;!-- &lt;result name&#x3D;&quot;addCustomer&quot; type&#x3D;&quot;redirect&quot;&gt;&#x2F;jsp&#x2F;success.jsp&lt;&#x2F;result&gt; --&gt; &lt;result name&#x3D;&quot;addCustomer&quot; type&#x3D;&quot;redirect&quot;&gt;findAllCustomer&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;!-- 删除客户 --&gt; &lt;action name&#x3D;&quot;deleteCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;deleteCustomer&quot;&gt; &lt;result name&#x3D;&quot;deleteCustomer&quot; type&#x3D;&quot;redirect&quot;&gt;findAllCustomer&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 动作类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 客户的动作类 * * @author wgy */public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private ICustomerService customerService = new CustomerServiceImpl(); private Customer customer = new Customer(); @Override public Customer getModel() &#123; return customer; &#125; /** * 查询所有客户 * @return */ public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //3.把查询的结果存入请求域中 request.setAttribute(\"customers\", customers); //4.返回 return \"findAllCustomer\"; &#125; /** * 获取添加客户页面 * @return */ public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 添加客户 * @return */ public String addCustomer()&#123; customerService.saveCustomer(customer); return \"addCustomer\"; &#125; /** * 删除客户 * @return */ public String deleteCustomer()&#123; customerService.deleteCustomer(customer); return \"deleteCustomer\"; &#125;&#125; 4.2 Hibernate4.2.1 编写业务层接口及实现类123456789101112131415161718192021222324252627/** * 客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer(); /** * 添加客户 * * @param customer */ void saveCustomer(Customer customer); /** * 删除客户 * @param customer */ void deleteCustomer(Customer customer);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 客户的业务层实现类 * 事务控制在业务层的 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 List&lt;Customer&gt; customers = customerDao.findAllCustomer(); //4.提交事务 tx.commit(); //5.返回结果 return customers; &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125; @Override public void saveCustomer(Customer customer) &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 customerDao.saveCustomer(customer); //4.提交事务 tx.commit(); &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125; @Override public void deleteCustomer(Customer customer) &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 customerDao.deleteCustomer(customer); //4.提交事务 tx.commit(); &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 4.2.2 编写持久层接口及实现类123456789101112131415161718192021222324252627282930313233/** * 客户的持久层接口 * * @author wgy */public interface ICustomerDao &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer(); /** * 添加客户 * @param customer */ void saveCustomer(Customer customer); /** * 删除客户 * @param customer */ void deleteCustomer(Customer customer); /** * 根据id查询客户 * @param custID * @return */ Customer findCustomerById(Long custID);&#125; 123456789101112131415161718192021222324252627/** * 客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return HibernateUtil.getCurrentSession().createQuery(\"from Customer\").list(); &#125; @Override public void saveCustomer(Customer customer) &#123; HibernateUtil.getCurrentSession().save(customer); &#125; @Override public void deleteCustomer(Customer customer) &#123; HibernateUtil.getCurrentSession().delete(findCustomerById(customer.getCustId())); &#125; @Override public Customer findCustomerById(Long custID) &#123; return HibernateUtil.getCurrentSession().get(Customer.class,custID); &#125;&#125; 5. 请求参数封装失败后处理办法5.1 配置input结果视图视图路径应该是从哪来回哪去 1234&lt;action name&#x3D;&quot;demo3&quot; class&#x3D;&quot;com.wgy.web.action.Demo3Action&quot; method&#x3D;&quot;demo3&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;input&quot;&gt;&#x2F;user.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 5.2 提示错误信息引入struts2标签库 1&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt; 1234567891011&lt;%--请求参数封装：类型转换失败的处理方式 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo3.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;s:fielderror fieldName=\"username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;s:fielderror fieldName=\"age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;s:fielderror fieldName=\"birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"hobby\" value=\"写代码\"/&gt;写代码 &lt;s:fielderror fieldName=\"hobby\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; 5.3 把提交的数据回显回来html标签和struts2标签都可以实现 123456&lt;s:form action=\"demo3\"&gt; &lt;s:textfield name=\"username\" label=\"姓名\"/&gt; &lt;s:textfield name=\"age\" label=\"年龄\"/&gt; &lt;s:textfield name=\"birthday\" label=\"生日\"/&gt; &lt;s:submit value=\"提交\"/&gt;&lt;/s:form&gt; 5.4 关于中文提示的问题I18N ： 国际化 Internationalization 同实体类创建.properties文件 1invalid.fieldvalue.birthday=请输入正确的日期格式。正确的格式是：yyyy-MM-dd","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Struts2(一)","date":"2020-06-04T15:33:21.000Z","path":"archives/90bb5282.html","text":"1. Struts2基本概念1.1 三层架构和三大框架各自的位置1.1.1 三层架构我们的开发架构一般都是基于两种形式，一种是C/S架构，也就是客户端/服务器，另一种是B/S架构，也就是浏览器/服务器。在JavaEE开发中，几乎全都是基于B/S架构的开发。那么在B/S架构中，系统标准的三层架构包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层： 也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web层，web需要接收http请求，完成http响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用MVC模型。（MVC是表现层的设计模型，和其他层没有关系） 业务层： 也就是我们常说的service层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web层依赖业务层，但是业务层不依赖web层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制） 持久层： 也就是我们是常说的dao层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。 通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。 1.1.2 三大框架和三层架构的关系 1.2 Struts2概述Struts2是一种基于MVC模式的轻量级Web框架，它自问世以来，就受到了广大Web开发者的关注，并广泛应用于各种企业系统的开发中。目前掌握Struts2框架几乎成为Web开发者的必备技能之一。 在介绍Struts2之前，先来认识一下Struts1。Struts1是最早的基于MVC模式的轻量级Web框架，它能够合理的划分代码结构，并包含验证框架、国际化框架等多种实用工具框架。但是随着技术的进步，Struts1的局限性也越来越多的暴露出来。为了符合更加灵活、高效的开发需求，Struts2框架应运而生。 Struts2是Struts1的下一代产品，是在 Struts1和WebWork技术的基础上进行合并后的全新框架（WebWork是由OpenSymphony组织开发的，致力于组件化和代码重用的J2EE Web框架，它也是一个MVC框架）。虽然Struts2的名字与Struts1相似，但其设计思想却有很大不同。实质上，Struts2是以WebWork为核心的，它采用拦截器的机制来处理用户的请求。这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts2可以理解为WebWork的更新产品。 Struts2拥有优良的设计和功能，其优势具体如下： 项目开源，使用及拓展方便，天生优势。 提供Exception处理机制。 Result方式的页面导航，通过Result标签很方便的实现重定向和页面跳转。 通过简单、集中的配置来调度业务类，使得配置和修改都非常容易。 提供简单、统一的表达式语言来访问所有可供访问的数据。 提供标准、强大的验证框架和国际化框架。 提供强大的、可以有效减少页面代码的标签。 提供良好的Ajax支持。 拥有简单的插件，只需放入相应的JAR包，任何人都可以扩展Struts2框架，比如自定义拦截器、自定义结果类型、自定义标签等，为Struts2定制需要的功能，不需要什么特殊配置，并且可以发布给其他人使用。 拥有智能的默认设置，不需要另外进行繁琐的设置。使用默认设置就可以完成大多数项目程序开发所需要的功能。 2. Struts2的入门2.1 Struts2环境搭建2.1.1 下载struts2开发包Struts2的官网: https://struts.apache.org/ 2.1.2 Struts2开发包目录介绍解压后的目录结构如下： 2.1.3 搭建步骤2.1.3.1 第一步：拷贝struts2必备jar包到web工程的lib目录要进行struts2的基本的开发，可以参考struts-2.3.24中的apps下的一些示例代码，其中struts2-blank.war是一个struts2的空的工程。我们只需要将struts2-blank.war解压后进入到WEB-INF下的lib中查看。 2.1.3.2 第二步：在类的根路径下创建一个名称为struts.xml的文件，并导入约束在开发中需要将struts.xml文件引入到工程的src下，因为src下内容发布到web服务器中就是WEB-INF下的classes中。 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 导入约束： 约束的位置：在struts2的核心jar包中 struts2-core-2.3.24.jar中包含一个名称为： struts-2.3.dtd的约束文件--&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt;&lt;&#x2F;struts&gt; 2.1.3.3 第三步：在web.xml配置struts2的核心控制器Struts2框架要想执行，所有的请求都需要经过这个前端控制器（核心过滤器） 12345678910111213141516&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot; version&#x3D;&quot;4.0&quot;&gt; &lt;!-- 配置struts2的核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;&lt;&#x2F;web-app&gt; 2.1.3.4 验证搭建成功与否把应用部署到tomcat中，启动tomcat，不报异常则表示搭建成功。 2.2 Struts2入门案例2.2.1 案例需求通过点击超链接发送请求，由Struts2中类来负责接收，并且在控制台输出接收到了的语句。 2.2.2 案例实现2.2.2.1 第一步：编写index.jsp 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;struts2的入门案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--struts2的核心控制默认会处理以.action为后缀的url，或者是没有任何后缀的url --%&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/hello\"&gt;访问第一个struts2应用&lt;/a&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/hello.action\"&gt;访问第一个struts2应用.action&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 2.2.2.2 第二步：编写Class12345678910111213141516171819202122232425/** * 我们的第一个动作类。 * 动作类： * 它就是一个概念。它就是struts2框架中用于处理请求的类。 * 我们以后处理请求都写动作类。 * * @author wgy */public class HelloAction &#123; /** * 我们的第一个动作方法 * 动作方法： * 动作类中用于处理请求的方法 * 动作方法有编写规范： * 1、访问修饰符都是public * 2、方法的返回值一般都是String(但是可以是void) * 3、方法都没有参数 * @return */ public String sayHello()&#123; System.out.println(\"HelloAction的sayHello方法执行了。。。。\"+this); return \"success\"; &#125;&#125; 2.2.2.3 第三步：在配置文件中配置我们的动作类123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.0.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 配置文件 --&gt; &lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 2.2.2.4 第四步：编写success.jsp1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;执行结果页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;执行成功！&lt;/body&gt;&lt;/html&gt; 2.2.2.5 第五步：启动tomcat测试访问结果2.3 Struts2的执行过程2.3.1 执行时序首先是，启动tomcat服务器，这时候会加载web.xml，当读到filter标签时，会创建过滤器对象。 Struts2的核心过滤器（StrutsPrepareAndExecuteFilter）会负责加载类路径下的struts.xml配置文件。 接下来，从客户端发送请求过来 先经过前端控制器（核心过滤器StrutsPrepareAndExecuteFilter），前端控制器会根据请求的名称在struts.xml中找到对应的配置，创建我们的动作类对象（每次访问时都会创建新的Action对象），然后执行指定的方法，根据方法的返回值找到Result的配置进行页面的跳转.最后响应浏览器。 2.3.2 内部执行流程Struts2框架在默认情况下核心控制器（StrutsPrepareAndExecuteFilter）默认会拦截以.action为后缀的请求，或者是没有任何后缀的请求。当拦截下来后，送入Struts2的核心内部。如下图所示： 我们通过上面的图解，应该明确在实际开发中我们用struts2要做哪些： 写动作类 写jsp 写配置文件 其中，又以配置文件为重。 3. Struts2的配置文件详解3.1 Struts2中的配置文件3.1.1 配置文件说明在struts2中给我们提供了6个配置文件。他们的加载时机是tomcat启动服务一加载我们的应用时，就加载struts2的配置文件。 他们的加载顺序入如下： 顺序 配置文件名 所在位置 说明 1 default.properties struts2-core-2.3.15.3.jar\\org\\apache\\struts2 不能修改 2 struts-default.xml struts2-core-2.3.15.3.jar 不能修改 3 strtuts-plugin.xml 在struts2提供的插件jar包中 不能修改 4 struts.xml 我们的应用中 我们修改的：推荐 5 struts.properties 我们的应用中 我们修改的 6 web.xml 我们的应用中 我们修改的，可以给过滤器配置参数 3.1.2 配置文件的注意事项 Struts2提供了两种配置的方式。一种是key=value的方式，即使用.properties文件。另一种是xml文件配置。我们推荐使用xml文件（它能描述层级关系）。 当多个配置文件中，有相同的参数，后加载的会把前面的值给覆盖了。 3.1.3 Struts2中的常用常量常量定义在了default.properties配置文件中，体现形式都是key=value。所有的struts2应用都会用到这些常量。 常用的： 常量名 常量值 说明 struts.i18n.encoding UTF-8 应用中使用的编码 struts.objectFactory.spring.autoWire name 和spring框架整合有关 struts.multipart.parser jakarta 指定文件上传用的组件 struts.multipart.maxSize 2097152 文件上传总文件大小限制：2M struts.action.extension action,, 能进入Struts2框架内部的url地址后缀名。多个值用逗号分隔 struts.enable.DynamicMethodInvocation false 是否允许动态方法调用 struts.devMode false 是否是开发模式。开发模式：改了配置文件，不需要重启。输出更多的错误信息。开发阶段建议为true struts.ui.theme xhtml 页面展示用的主题 3.2 Struts.xml中的标签详解3.2.1 constant标签123456789&lt;!-- constant标签： 作用： 用于修改struts2中的常量 属性： name：指定常量的key value：指定常量的值--&gt;&lt;!-- 开启开发者模式 --&gt;&lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; 3.2.2 package标签1234567891011121314151617181920&lt;!-- package标签： 作用：给访问的action进行分包管理。把配置文件按照面向对象的思想来管理。 属性： name：指定包的名称。必须写，并且必须唯一。 extends：指定当前包的父包。子包自动具备父包所定义的配置。我们的包一般都需要继承struts-default包。 该包在struts-defaul.xml文件中定义着。如果不继承该包，则不能使用struts2的核心功能。 abstract：把当前包声明为抽象包。抽象包就是用来被继承的。里面定义一般都是公共的配置。 只有没有action标签的包，才能定义为抽象包。 namespace：指定当前包的名称空间。它可以让我们的访问URL模块化。当我们指定了该属性，访问URL就变成了：名称空间+&#x2F;hello 名称空间的写法：第一个字符必须是&#x2F;，后面紧跟的字符必须是一个字母。其余内容可以是字母，也可以是数字。 例如：我们访问用户 &#x2F;user&#x2F;addUser.action &#x2F;user&#x2F;updateUser.action 名称空间有默认值。默认值是：&quot;&quot;--&gt;&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;n1&quot;&gt; &lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.2.3 action标签12345678910&lt;!-- action标签： 作用：建立动作名称，动作类和动作方法的对应关系 属性： name:指定动作名称。它是唯一的 class:指定动作类的全限定类名 method：指定动作方法名称--&gt;&lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3 action的三种创建方式3.3.1 第一种：无侵入式创建(实际开发中基本不用)12345678910111213/** * 我们的第一个动作类 * 动作类的第一种创建方式： * 无侵入式的创建。 */public class HelloAction &#123; public String sayHello()&#123; System.out.println(this); System.out.println(\"HelloAction中的sayHello方法执行了。。。。\"); return \"success\"; &#125;&#125; 123&lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3.2 第二种：实现Action接口的定义方式 (实际开发中用的也不多)12345678910111213/** * 通过实现接口的方式创建动作类 * * @author wgy */public class Hello2Action implements Action &#123; @Override public String execute() throws Exception &#123; System.out.println(\"Hello2Action的execute方法执行了。。。。\"); return SUCCESS; &#125;&#125; 1234&lt;!-- 默认动作方法：当我们要是执行的是execute方法时，method属性可以不写。 --&gt;&lt;action name&#x3D;&quot;hello2&quot; class&#x3D;&quot;com.wgy.web.action.Hello2Action&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; Action接口中的常量 SUCCESS：一般多用于成功 ERROR：一般多用于动作方法执行失败 LOGIN：一般多用于返回登录页面 NONE：一般用于不返回任何结果视图，和return null作用是一样的 INPUT：一般多用于数据回显，也是struts2中数据回显时的默认返回值。 3.3.3 第三种：继承ActionSupport (实际开发中采用的方式)12345678/** * 通过继承ActionSupport的方式创建动作类 * * @author wgy */public class Hello3Action extends ActionSupport &#123;&#125; 123&lt;action name&#x3D;&quot;hello3&quot; class&#x3D;&quot;com.wgy.web.action.Hello3Action&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3.4 默认动作类：ActionSupport类1234&lt;!-- 通过struts-default.xml中我们知道默认的动作类是ActionSupport，所以如果实现该类的execute方法，则可以不用指定class和method属性 --&gt;&lt;action name&#x3D;&quot;hello4&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4 action的三种访问方式12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 用户的动作类 * * @author wgy */public class UserAction extends ActionSupport &#123; /** * 保存 * @return */ public String addUser() &#123; System.out.println(\"保存了用户\"); return SUCCESS; &#125; /** * 更新 * @return */ public String updateUser() &#123; System.out.println(\"更新了用户\"); return SUCCESS; &#125; /** * 查询 * @return */ public String deleteUser() &#123; System.out.println(\"删除了用户\"); return SUCCESS; &#125; /** * 删除 * @return */ public String findUser() &#123; System.out.println(\"查询了用户\"); return SUCCESS; &#125;&#125; 3.4.1 第一种：全匹配配置访问方式1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUser\"&gt;查询用户&lt;/a&gt; 1234567891011121314&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;addUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;addUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;updateUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;updateUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;deleteUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;deleteUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;findUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;findUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.4.2 第二种：使用通配符的方式* 通配符基本用法 1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUser\"&gt;查询用户&lt;/a&gt; 123456&lt;!-- 通配符基本用法 --&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;*&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;&#123;1&#125;&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 通配符的高级用法 1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/add_User\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/update_User\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/delete_User\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/find_User\"&gt;查询用户&lt;/a&gt; 123456&lt;!-- 通配符的高级用法 --&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;*_*&quot; class&#x3D;&quot;com.wgy.web.action.&#123;2&#125;Action&quot; method&#x3D;&quot;&#123;1&#125;&#123;2&#125;&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.4.3 第三种：使用动态方法调用的方式1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!findUser\"&gt;查询用户&lt;/a&gt; 1234567&lt;!-- 使用动态方法调用的方式 --&gt;&lt;constant name&#x3D;&quot;struts.enable.DynamicMethodInvocation&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;user&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 4. 案例：Strut2+Hibernate查询客户列表4.1 第一步：搭建hibernate开发环境并准备实体类和映射配置可参考Hibernate环境搭建。 Hibernate开发环境 1234567891011121314151617181920212223242526272829303132&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory--&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;struts2&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;property&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;&#x2F;property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping class&#x3D;&quot;com.wgy.domain.Customer&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 实体类和映射配置 123456789101112131415161718192021222324252627282930313233/** * 客户的实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name = \"cust_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 4.2 第二步：搭建struts2环境参考2.1.3章节的步骤去做。 4.3 第三步：导入crm的jsp页面把下图中红框内文件夹下所有内容都拷贝到WebContent目录中 4.4 第四步：修改menu.jsp12345&lt;TR&gt; &lt;TD class=menuSmall&gt; &lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/findAllCustomer.action\" target=main&gt;－ 客户列表&lt;/A&gt; &lt;/TD&gt;&lt;/TR&gt; 4.5 第五步：在配置文件中配置findAllCustomer.action1234567891011121314&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; &lt;!-- 动作配置 --&gt; &lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 4.6 第六步：创建动作类并提供动作方法123456789101112131415161718192021222324/** * 客户的动作类 * * @author wgy */public class CustomerAction extends ActionSupport &#123; private ICustomerService customerService = new CustomerServiceImpl(); /** * 查询所有客户 * @return */ public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //3.把查询的结果存入请求域中 request.setAttribute(\"customers\", customers); //4.返回 return \"findAllCustomer\"; &#125;&#125; 4.7 第七步：编写service接口和实现类1234567891011121314/** * 客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617181920212223242526272829303132/** * 客户的业务层实现类 * 事务控制在业务层的 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 List&lt;Customer&gt; customers = customerDao.findAllCustomer(); //4.提交事务 tx.commit(); //5.返回结果 return customers; &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 4.8 第八步：编写dao接口和实现类1234567891011121314/** * 客户的持久层接口 * * @author wgy */public interface ICustomerDao &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 123456789101112/** * 客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return HibernateUtil.getCurrentSession().createQuery(\"from Customer\").list(); &#125;&#125; 4.9 第九步：页面展示jsp/customer/list.jsp12345678910&lt;c:forEach items=\"$&#123;customers&#125;\" var=\"customer\"&gt; &lt;TR&gt; &lt;TD&gt;$&#123;customer.custName &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custLevel &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custSource &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custIndustry &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custAddress &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custPhone &#125;&lt;/TD&gt; &lt;/TR&gt; &lt;/c:forEach&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Hibernate(四)","date":"2020-06-03T14:33:02.000Z","path":"archives/c4c4045f.html","text":"1. JPA相关概念1.1 JPA概述全称是：Java Persistence API。是SUN公司推出的一套基于ORM的规范。Hibernate框架中提供了JPA的实现。 JPA通过JDK 5.0注解或XML描述对象—关系表的映射关系，并将运行期的实体对象持久化到数据库中。 1.2 JPA的优势 标准化 JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。 容器级特性的支持 JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。 简单方便 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成。 查询能力 JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。 高级特性 JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。 1.3 学习JPA要明确的 JPA是一套ORM规范，Hibernate实现了JPA规范 hibernate中有自己的独立ORM操作数据库方式，也有JPA规范实现的操作数据库方式。 2. JPA入门2.1 需求介绍本章节我们实现基于JPA注解的对象关系映射，配置实体类和数据库表的对应关系。并且使用JPA规范中的方法实现CRUD操作。 2.2 JPA环境搭建2.2.1 第一步：拷贝jar包 2.2.2 第二步：创建配置文件在src下面的META-INF文件夹下面创建一个名称为persistence.xml的文件。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;persistence xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence&#x2F;persistence_2_0.xsd&quot; version&#x3D;&quot;2.0&quot;&gt; &lt;!-- 配置持久化单元，可以配置多个，但是名称不能重复 name:用于指定持久化单元名称 transaction-type:指定事务的类型。 JTA：Java Transaction API RESOURCE_LOCAL:指的是本地代码事务。（我们用这个） --&gt; &lt;persistence-unit name&#x3D;&quot;myJPAUnit&quot; transaction-type&#x3D;&quot;RESOURCE_LOCAL&quot;&gt; &lt;!-- JPA规范的提供商 可以不写。--&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;&#x2F;provider&gt; &lt;!-- 指定由Jpa注解的实体类位置 可以不写。--&gt; &lt;class&gt;com.wgy.domain.Customer&lt;&#x2F;class&gt; &lt;!-- 连接库相关的一些配置 --&gt; &lt;properties&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot; value&#x3D;&quot;org.hibernate.dialect.MySQLDialect&quot;&#x2F;&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot; value&#x3D;&quot;update&quot;&#x2F;&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;persistence-unit&gt;&lt;&#x2F;persistence&gt; 2.2.3 第三步：编写工具类，用于获取JPA的操作数据库对象1234567891011121314151617181920212223/** * JPA的工具类 * * @author wgy */public class JPAUtil &#123; //它就相当于SessionFactory private static EntityManagerFactory factory; static &#123; //注意：该方法参数必须和persistence.xml中persistence-unit标签name属性取值一致 factory = Persistence.createEntityManagerFactory(\"myJPAUnit\"); &#125; /** * 获取EntityManager对象 * * @return */ public static EntityManager createEntityManager() &#123; return em.createEntityManager(); &#125;&#125; 2.2.4 第四步：编写实体类并使用注解配置12345678910111213141516171819202122232425262728293031323334/** * 客户实体类 * 使用的注解都是JPA规范，所以导包，都需要导入javax.persistence包下的 * * @author wgy */@Entity//表明该类是一个实体类@Table(name = \"cst_customer\")//建立当前类和数据库表的对应关系public class Customer implements Serializable &#123; @Id//表明当前字段是主键 @Column(name = \"cust_id\")//表明对应数据库的主键字段是cust_id @GeneratedValue(strategy = GenerationType.IDENTITY)//指定主键生成策略。 private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 2.3 JPA的CRUD操作2.3.1 保存123456789101112131415161718192021/** * 保存 */@Testpublic void test1() &#123; //创建客户对象 Customer c = new Customer(); c.setCustName(\"JPA Customer\"); //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行保存操作 em.persist(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.2 快照更新12345678910111213141516171819/** * 更新操作 */@Testpublic void test3() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //修改客户的地址为：顺义区 c.setCustAddress(\"顺义区\"); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.3 merge更新12345678910111213141516171819202122/** * 更新的另一种操作方式 * merge是合并 （两个实体合并） */@Testpublic void test4() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //修改客户的地址为：顺义区 c.setCustAddress(\"北京市顺义区\"); em.merge(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.4 删除1234567891011121314151617181920/** * 删除操作 */@Testpublic void test5() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //删除操作 em.remove(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.5 查询一个12345678910111213141516171819202122232425262728293031323334353637/** * 查询一个实体 立即加载 */@Testpublic void test2() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); System.out.println(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125;/** * 查询一个实体 延迟加载 */@Testpublic void test2_1() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.getReference(Customer.class, 1L); System.out.println(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.6 查询所有12345678910111213141516171819202122232425262728293031323334353637/** * 查询所有 * * 涉及的对象是： * JPA的Query * 如何获取该对象： * EntityManager的createQuery(String jpql) * 参数含义： * JPQL：Java Persistence Query Language * 他的写法和HQL很相似。也是把表名换成类名，把字段名换成属性名称 * 它在写查询所有时，不能直接用 from 实体类 * 需要使用select关键字 * select c from Customer c */@Testpublic void test6() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.获取JPA的查询对象Query Query query = em.createQuery(\"select c from Customer c where custName like ? and custLevel = ? \"); //给占位符赋值 query.setParameter(1, \"%集%\"); query.setParameter(2, \"23\"); //执行方法获取结果集 //getSingleResult()：查询结果是一个对象 List list = query.getResultList(); for (Object o : list) &#123; System.out.println(o); &#125; //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 3. JPA的多表操作3.1 一对多关系配置及操作3.1.1 配置123456789101112131415161718192021222324252627282930313233343536373839404142/** * 客户实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name = \"cust_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; /** * 一对多关系映射：一个客户可以有多个联系人 * mappedBy 取消维护 * cascade 级联保存 * fetch 查询加载时机 */ @OneToMany(targetEntity = LinkMan.class,mappedBy = \"customer\",cascade = CascadeType.ALL,fetch = FetchType.EAGER) private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); ...&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 联系人的实体类 * * @author wgy */@Entity@Table(name = \"cst_linkman\")public class LinkMan implements Serializable &#123; @Id @Column(name = \"lkm_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long lkmId; @Column(name = \"lkm_name\") private String lkmName; @Column(name = \"lkm_gender\") private String lkmGender; @Column(name = \"lkm_phone\") private String lkmPhone; @Column(name = \"lkm_mobile\") private String lkmMobile; @Column(name = \"lkm_email\") private String lkmEmail; @Column(name = \"lkm_position\") private String lkmPosition; @Column(name = \"lkm_memo\") private String lkmMemo; /** * 一对多关系映射，多的一方。 * 从表实体包含主表实体的对象引用 */ @ManyToOne(targetEntity = Customer.class,fetch = FetchType.LAZY) @JoinColumn(name = \"lkm_cust_id\",referencedColumnName = \"cust_id\") private Customer customer; ...&#125; 3.1.2 操作3.1.2.1 保存123456789101112131415161718192021222324/** * 保存操作 * 创建一个客户和一个联系人 * 建立客户和联系人的双向关联关系 * 先保存客户，再保存联系人 */@Testpublic void test1() &#123; Customer c = new Customer(); LinkMan l = new LinkMan(); c.setCustName(\"JPA One To Many Customer\"); l.setLkmName(\"JPA One To Many LinkMan\"); c.getLinkmans().add(l); l.setCustomer(c); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); em.persist(c); em.persist(l); tx.commit(); em.close();&#125; 3.1.2.2 更新1234567891011121314151617181920212223/** * 更新操作 * 创建一个联系人 * 查询id为5的客户 * 为5这个客服分配该联系人 * 更新客户 */@Testpublic void test2() &#123; LinkMan l = new LinkMan(); l.setLkmName(\"JPA One To Many LinkMan 2\"); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer c = em.find(Customer.class, 5L); c.getLinkmans().add(l); l.setCustomer(c); tx.commit(); em.close();&#125; 3.1.2.3 删除123456789101112131415/** * 删除操作 */@Testpublic void test3() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer c = em.find(Customer.class, 5L); em.remove(c); tx.commit(); em.close();&#125; 3.1.2.4 查询12345678910111213141516171819202122232425262728293031323334353637/** * 根据客户查询客户下的联系人 */@Testpublic void test1() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //1.查询id为1的客户 Customer c = em.find(Customer.class, 1l); System.out.println(c); //查询当前客户下的联系人 Set&lt;LinkMan&gt; linkmans = c.getLinkmans(); System.out.println(linkmans); tx.commit(); em.close();&#125;/** * 根据联系人，查询联系人的所属客户 */@Testpublic void test2() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //1.查询id为1的客户 LinkMan l = em.find(LinkMan.class, 1l); System.out.println(l); //查询当前客户下的联系人 Customer c = l.getCustomer(); System.out.println(c); tx.commit(); em.close();&#125; 3.2 多对多关系配置及操作3.2.1 配置12345678910111213141516171819202122232425262728293031/** * 角色的实体类 * * @author wgy */@Entity@Table(name = \"sys_role\")public class SysRole implements Serializable &#123; @Id @Column(name = \"role_id\") @GenericGenerator(name = \"uuid\", strategy = \"uuid\")//声明一个主键生成器 name属性：给生成器起个名字。strategy：指定的就是hibernate中包含的生成策略 @GeneratedValue(generator = \"uuid\") private String roleId; @Column(name = \"role_name\") private String roleName; @Column(name = \"role_memo\") private String roleMemo; //多对多关系映射：一个角色可以赋予多个用户 @ManyToMany(cascade=CascadeType.ALL) //加入一张表 @JoinTable(name=\"user_role_ref\", joinColumns = &#123;@JoinColumn(name=\"role_id\",referencedColumnName=\"role_id\")&#125;,//写的是当前实体在中间表的外键字段 inverseJoinColumns=&#123;@JoinColumn(name=\"user_id\",referencedColumnName=\"user_id\")&#125;//写的是对方实体在中间表的外键字段 ) private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); ...&#125; 1234567891011121314151617181920212223242526272829/** * 用户的实体类 * * @author wgy */@Entity@Table(name = \"sys_user\")public class SysUser implements Serializable &#123; @Id @Column(name = \"user_id\") @GenericGenerator(name = \"uuid\", strategy = \"uuid\") @GeneratedValue(generator = \"uuid\") private String userId; @Column(name = \"user_name\") private String userName; @Column(name = \"user_password\") private String userPassword; @Column(name = \"user_state\") private Integer userState; //多对多关系映射：一个用户可以具备多个角色 @ManyToMany(mappedBy=\"users\",cascade= CascadeType.ALL) private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); ...&#125; 3.2.2 操作3.2.2.1 保存1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 保存操作 * 创建两个用户 * 创建三个角色 * 让1号用户具备1号和2号角色 * 让2号用户具备2号和3号角色 * 保存用户和角色 */@Testpublic void test1() &#123; SysUser u1 = new SysUser(); SysUser u2 = new SysUser(); u1.setUserName(\"JPA Many to Many u1\"); u2.setUserName(\"JPA Many to Many u2\"); SysRole r1 = new SysRole(); SysRole r2 = new SysRole(); SysRole r3 = new SysRole(); r1.setRoleName(\"JPA Many to Many r1\"); r2.setRoleName(\"JPA Many to Many r2\"); r3.setRoleName(\"JPA Many to Many r3\"); //建立用户和角色的关联关系 u1.getRoles().add(r1); u1.getRoles().add(r2); u2.getRoles().add(r2); u2.getRoles().add(r3); r1.getUsers().add(u1); r2.getUsers().add(u1); r2.getUsers().add(u2); r3.getUsers().add(u2); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //保存操作 em.persist(u1); tx.commit(); em.close();&#125; 3.2.2.2 删除123456789101112131415/** * 删除操作 * 双向级联删除，不管是hibernate还是Jpa,多对多中都不能配置 */@Testpublic void test2() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //查询用户 SysUser u1 = em.find(SysUser.class, \"8a7e83cc5fbf19b6015fbf19bada0000\"); em.remove(u1); tx.commit(); em.close();&#125; 4. JPA的其他说明4.1 JPA中使用C3P0连接池4.1.1 第一步：拷贝C3P0所必须的3个jar包 4.1.2 第二步：在persistence.xml配置文件中配置12&lt;!-- 配置使用C3P0数据源 --&gt;&lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot; value&#x3D;&quot;org.hibernate.connection.C3P0ConnectionProvider&quot;&#x2F;&gt; 4.1.3 验证是否配置成功1234567891011121314151617/** * 验证c3p0连接池是否配置成功 */@Testpublic void test1() &#123; //1.获取jpa中的操作对象 EntityManager em = JPAUtil.createEntityManager(); //2. Session session = em.unwrap(Session.class); //3.执行session的doWork方法 session.doWork(new Work() &#123; @Override public void execute(Connection conn) throws SQLException &#123; System.out.println(conn.getClass().getName()); &#125; &#125;);&#125; 12345678@Testpublic void test2() &#123; //1.获取jpa中的操作对象 EntityManager em1 = JPAUtil.createEntityManager(); EntityManager em2 = JPAUtil.createEntityManager(); //false System.out.println(em1 == em2);&#125; 4.2 JPA与Hibernate中操作数据的方法对照 5. Hibernate中使用JPA注解映射配置5.1 编写主配置文件(hibernate.cfg.xml)1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!-- 在类的根路径下创建名称为hibernate.cfg.xml的配置文件导入约束：dtd约束 --&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory SessionFactory的作用就是用于创建Session对象的。 Session对象就是hibernate中操作数据库的核心对象。 此处的配置不要求背，但是要求记住创建SessionFactory必须的三部分信息 第一部分： 连接数据库的信息 第二部分： hibernate的可选配置 第三部分： 映射文件的位置 --&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider &lt;&#x2F;property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping class&#x3D;&quot;com.wgy.domain.Customer&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 5.2 编写实体类并使用JPA注解配置123456789101112131415161718192021222324252627282930313233/** * 客户实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name=\"cust_id\") @GeneratedValue(strategy=GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 5.2 操作5.2.1 保存12345678910111213/** * 保存 */@Testpublic void test1() &#123; Customer c = new Customer(); c.setCustName(\"hibernate jpa customer\"); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); s.save(c); tx.commit();&#125; 5.2.2 查询1234567891011/** * 查询一个 */@Testpublic void test2() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); System.out.println(c); tx.commit();&#125; 5.2.3 修改1234567891011/** * 修改 */@Testpublic void test3() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); c.setCustAddress(\"顺义区\"); tx.commit();&#125; 5.2.4 删除1234567891011/** * 删除操作 */@Testpublic void test4() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); s.delete(c); tx.commit();&#125;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(三)","date":"2020-05-31T08:27:38.000Z","path":"archives/3e87eb50.html","text":"1. 多表设计1.1 表之间的关系划分 一对一 一对多（多对一） 多对多 2. 如何确立和实现数据库中的表关系2.1 一对多的表关系在数据库中如何实现?使用外键约束。我们一般习惯把一的方称为主表，把多的一方称为从表。 什么是外键： 从表中有一列，该列的取值除了null之外，只能来源于主表的主键。默认情况下，外键字段的值是可以重复的。 2.2 多对多的表关系在数据库中如何实现？使用中间表。中间表中只有两个外键，引用两个多对多表的主键。不能有其他字段信息，至于中间表的主键，应该采用联合主键。 任何一个多方的表和中间表去比较，都是一对多的关系。 2.3 一对一的表关系在数据库中如何实现？有两种： 第一种：建立外键的方式： 使用外键约束，唯一约束，非空约束。它是把外键字段加了非空和唯一约束。从而实现了一对一。 第二种：使用主键的方式： 让其中一张表既是主键，又是外键。 2.4 如何确立两张表之间的关系：找外键。 3. 学习多表映射配置要遵循的步骤 第一步：确定两张表之间的关系 第二步：在数据库中实现两张表之间的关系建立 第三步：在实体类中描述出两个实体之间的关系 第四步：在映射配置文件中建立两个实体和两张表之间的关系 4. 一对多关系映射配置示例：客户和联系人两张表 4.1 确定两张表之间的关系一个客户可以包含多个联系人，多个联系人可以属于同一个客户。所以：客户和联系人之间的关系是一对多。 4.2 在数据库中实现两张表之间的关系建立实现一对多的关系，靠外键。客户表是主表，联系人表是从表。我们需要在联系人表中添加外键。 4.3 在实体类中描述出两个实体之间的关系主表的实体类应该包含从表实体类的集合引用，从表的实体类应该包含主表实体类的对象引用 123456789101112131415161718192021/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; /** * 一对多关系映射：一的一方 * 主表实体应该包含从表实体的集合引用 */ private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); ...&#125; 1234567891011121314151617181920212223/** * 联系人的实体类 * * @author wgy */public class LinkMan implements Serializable &#123; private Long lkmId; private String lkmName; private String lkmGender; private String lkmPhone; private String lkmMobile; private String lkmEmail; private String lkmPosition; private String lkmMemo; /** * 一对多关系映射，多的一方。 * 从表实体包含主表实体的对象引用 */ private Customer customer; ...&#125; 4.4 在映射配置文件中建立两个实体和两张表之间的关系客户配置文件： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml导入约束：dtd约束 --&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot; lazy&#x3D;&quot;true&quot;&gt; &lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&#x2F;&gt; &lt;!-- 一对多关系映射：主表实体的映射配置 涉及的标签： set： 作用：用于配置set集合属性。 属性： name：指定实体类中set集合的属性名称。 table：指定从表的名称。在一对多配置时可以不写。 key: 作用：用于映射外键字段。 属性： column：指定外键字段名称 one-to-many: 作用：用于建立一对多的映射配置 属性： class：用于指定从表实体的名称 --&gt; &lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 联系人配置文件： 1234567891011121314151617181920212223242526272829&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;LinkMan&quot; table&#x3D;&quot;cst_linkman&quot;&gt; &lt;id name&#x3D;&quot;lkmId&quot; column&#x3D;&quot;lkm_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;lkmName&quot; column&#x3D;&quot;lkm_name&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmGender&quot; column&#x3D;&quot;lkm_gender&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmPhone&quot; column&#x3D;&quot;lkm_phone&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmMobile&quot; column&#x3D;&quot;lkm_mobile&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmEmail&quot; column&#x3D;&quot;lkm_email&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmPosition&quot; column&#x3D;&quot;lkm_position&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmMemo&quot; column&#x3D;&quot;lkm_memo&quot;&#x2F;&gt; &lt;!-- 一对多关系映射：从表实体的映射配置 涉及的标签： many-to-one： 作用：建立多对一的映射配置 属性： name：从表实体中引用主表实体对象引用的名称 class：指定属性所对应的实体类名称 column：指定从表中外键字段的名称 --&gt; &lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 5. 多对多关系映射配置示例：用户和角色 5.1 确定两张表之间的关系一个用户可以有多个角色，一个角色可以赋给多个用户，所以用户和角色之间是多对多。 5.2 在数据库中实现两张表之间的关系建立在数据库中实现多对多要靠中间表。中间表中只能出现用户和角色主键。 5.3 在实体类中描述出两个实体之间的关系各自包含对方一个集合引用 12345678910111213141516/** * 用户的实体类 * * @author wgy */public class SysUser implements Serializable &#123; private Long userId; private String userName; private String userPassword; private Integer userState; //多对多关系映射：一个用户可以具备多个角色 private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); ...&#125; 123456789101112131415/** * 角色的实体类 * * @author wgy */public class SysRole implements Serializable &#123; private Long roleId; private String roleName; private String roleMemo; //多对多关系映射：一个角色可以赋予多个用户 private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); ...&#125; 5.4 在映射配置文件中建立两个实体和两张表之间的关系用户配置文件： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;SysUser&quot; table&#x3D;&quot;sys_user&quot;&gt; &lt;id name&#x3D;&quot;userId&quot; column&#x3D;&quot;user_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;userName&quot; column&#x3D;&quot;user_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;userPassword&quot; column&#x3D;&quot;user_password&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;userState&quot; column&#x3D;&quot;user_state&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 多对多关系映射 涉及的标签： set: 作用：用于映射set集合属性 属性： name：指定集合的名称 table：指定的是中间表的名称 key: 作用：用于映射外键字段 属性： column：指定的是当前实体在中间表的外键字段名称 many-to-many 作用：用于映射多对多的关系 属性： class：对方的实体类名称 column：对方在中间表的外键字段名称 --&gt; &lt;set name&#x3D;&quot;roles&quot; table&#x3D;&quot;user_role_ref&quot;&gt; &lt;key column&#x3D;&quot;user_id&quot;&gt;&lt;&#x2F;key&gt; &lt;many-to-many class&#x3D;&quot;SysRole&quot; column&#x3D;&quot;role_id&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 角色配置文件： 12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;SysRole&quot; table&#x3D;&quot;sys_role&quot;&gt; &lt;id name&#x3D;&quot;roleId&quot; column&#x3D;&quot;role_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;roleName&quot; column&#x3D;&quot;role_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;roleMemo&quot; column&#x3D;&quot;role_memo&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 多对多关系映射 --&gt; &lt;set name&#x3D;&quot;users&quot; table&#x3D;&quot;user_role_ref&quot; inverse&#x3D;&quot;true&quot;&gt; &lt;key column&#x3D;&quot;role_id&quot;&gt;&lt;&#x2F;key&gt; &lt;many-to-many class&#x3D;&quot;SysUser&quot; column&#x3D;&quot;user_id&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 6. 多表增删改操作6.1 一对多关系的操作6.1.1 保存操作6.1.1.1 正常保存12345678910111213141516171819/** * 保存操作 * 正常的保存：创建一个新的联系人，需要关联一个客户 */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c1 = s.get(Customer.class, 1L); //2.创建一个新的联系人 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人\"); //3.建立客户和联系人的关联关系（让联系人知道属于哪个客户即可） l.setCustomer(c1); //4.保存联系人 s.save(l); tx.commit();&#125; 6.1.1.2 特殊情况1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 特殊的情况： * 创建一个客户和一个联系人 * 建立联系人和客户的双向关联关系 * 使用符合原则的保存 * 原则是：先保存主表实体，再保存从表实体 * * 此时保存会有问题： * 我们保存两个实体，应该只有两条insert语句。 * 而执行结果却是多了一条update的语句。 * * 解决办法： * 让客户在执行操作的时候，放弃维护关联关系的权利。 * 配置的方式： * 在Customer的映射配置文件中的set标签上使用inverse属性。 * inverse含义：是否放弃维护关联关系的权利 * true：放弃 * false：不放弃（默认值） * */@Testpublic void test2()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_4\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_4\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 //持久态 有一级缓存和快照 s.save(c1); //持久态 有一级缓存和快照 s.save(l); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 6.1.1.3 级联保存级联操作是指当主控方执行保存、更新或者删除操作时，其关联对象（被控方）也执行相同的操作。 保存客户 123456789101112131415161718192021222324252627282930/** * 保存操作： * 级联保存 * 使用级联保存，配置的方式，仍然是找到Customer的映射配置文件的Set标签， * 也可以配置在many-to-one上。 * 在上面加入cascade属性 * cascade：配置级联操作 * 级联保存更新的取值：save-update */@Testpublic void test3()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_5\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_5\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 s.save(c1); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 保存联系人 123456789101112131415161718192021@Testpublic void test4()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_6\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_6\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 s.save(l); tx.commit();&#125; 1&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot;&#x2F;&gt; 6.1.2 更新操作123456789101112131415161718192021222324/** * 更新操作 * 需求： * 创建一个新的联系人，查询一个已有客户 * 联系人新联系人和已有客户的双向关联关系 * 更新客户 */@Testpublic void test5()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c1 = s.get(Customer.class, 1L); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人\"); //3.建立客户和联系人的关联关系（双向） l.setCustomer(c1); c1.getLinkmans().add(l); //4.更新客户 s.update(c1); tx.commit();&#125; 6.1.3 删除操作123456789101112131415161718192021/** * 删除操作 * 删除从表数据就是单表 * 删除主表数据： * 看有没有从表数据引用 * 有引用： * 在删除是，hibernate会把从表中的外键字段置为null，然后再删除主表数据。 * 如果外键字段有非空约束，则hibernate不能更新外键字段为null，会报错。 * 如果仍然想删除，此时需要使用级联删除。同时必须配置inverse属性是true。 * 没有引用： 就是单表，直接删 */@Testpublic void test6()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c9 = s.get(Customer.class, 5L); //2.删除id为5的客户 s.delete(c9); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update,delete&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 6.2 多对多关系的操作6.2.1 保存操作12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 保存操作 * 需求： * 创建2个用户和3个角色 * 让1号用户具备1号和2号角色 * 让2号用户具备2号和3号角色 * 保存用户和角色 */@Testpublic void test1()&#123; SysUser u1 = new SysUser(); u1.setUserName(\"用户1\"); SysUser u2 = new SysUser(); u2.setUserName(\"用户2\"); SysRole r1 = new SysRole(); r1.setRoleName(\"角色1\"); SysRole r2 = new SysRole(); r2.setRoleName(\"角色2\"); SysRole r3 = new SysRole(); r3.setRoleName(\"角色3\"); //建立双向关联关系 //先建立用户的 u1.getRoles().add(r1); u1.getRoles().add(r2); u2.getRoles().add(r2); u2.getRoles().add(r3); //再建立角色 r1.getUsers().add(u1); r2.getUsers().add(u1); r2.getUsers().add(u2); r3.getUsers().add(u2); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); s.save(u1); s.save(u2); s.save(r1); s.save(r2); s.save(r3); tx.commit();&#125; 6.2.2 删除操作12345678910111213141516/** * 删除操作 * 实际开发中：多对多的双向级联删除是禁止使用的 */@Testpublic void test2()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1查询id为3的用户 SysUser u3 = s.get(SysUser.class, 3L); //删除 s.delete(u3); tx.commit();&#125; 7. Hibernate中的多表查询7.1 对象导航查询7.1.1 概述对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。 例如：我们通过OID查询方式查出一个客户，可以调用Customer类中的getLinkMans()方法来获取该客户的所有联系人。 对象导航查询的使用要求是：两个对象之间必须存在关联关系。 7.1.2 对象导航检索示例查询联系人 123456789101112131415/** * 查询id为1的客户下所属联系人 * 一对多时，根据一的一方查询多的一方时，需要使用延迟加载。（默认配置即可） */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //查询id为1的客户 Customer c = s.get(Customer.class, 1L); System.out.println(c); Set&lt;LinkMan&gt; linkmans = c.getLinkmans(); System.out.println(linkmans); tx.commit();&#125; 查询客户 12345678910111213141516171819/** * 查询id为5的联系人属于哪个客户 * 多对一时，根据多的一方查询一的一方时，不需要使用延迟加载，而是使用立即加载，需要配置一下 * 需要找到联系人的映射配置文件：在many-to-one标签上使用lazy属性。 * 取值有： * false：使用立即加载。 * proxy：是看load方法是延迟加载还是立即加载 * no-proxy：不管 */@Testpublic void test2()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); LinkMan l = s.get(LinkMan.class, 5L); System.out.println(l); Customer c = l.getCustomer(); System.out.println(c); tx.commit();&#125; 1&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot; lazy&#x3D;&quot;false&quot;&#x2F;&gt; load方法加载 1234567891011121314/** * 关于load方法改为立即加载的方式 * 找到查询实体的映射配置文件，它的class标签上也有一个lazy属性。含义是：是否延迟加载 * true：延迟加载(默认值) * false：立即加载 */@Testpublic void test3()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.load(Customer.class, 1L); System.out.println(c); tx.commit();&#125; class标签的lazy：它只能管load方法是否是延迟加载。 set标签的lazy：它管查询关联的集合对象是否是延迟加载。 many-to-one的lazy：它管查询关联的主表实体是否是立即加载。","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(二)","date":"2020-05-28T16:09:27.000Z","path":"archives/4074cb7b.html","text":"1. Hibernate的持久化类和对象标识符1.1 持久化类的编写规范1.1.1 什么是持久化类Hibernate是持久层的ORM映射框架，专注于数据的持久化工作。 持久化就是将内存中的数据永久存储到关系型数据库中。 持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为是持久化类。其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。 1.1.2 持久化类的编写规范应该遵循JavaBean的编写规范: Bean：在软件开发中是指的可重用的组件。 JavaBean：指的是用java语言编写的可重用组件。在我们的实际项目中：domain,service,dao都可以看成是JavaBean。 编写规范： 类都是public的 一般实现序列化接口 类成员（字段）都是私有的 私有类成员都有公有get/set方法 类都有默认无参构造函数 细节： 数据类型的选择问题： 基本类型和包装类，选择哪个？由于包装类可以有null值。所以实际开发中都是用包装类。 1.2 Hibernate中对象标识符（OID）OID全称是Object Identifier，又叫做对象标识符。 它是hibernate用于区分两个对象是否是同一个对象的标识。 我们都知道，虚拟机内存区分两个对象看的是内存的地址是否一致。数据库区分两个对象，靠的是表的主键。Hibernate负责把内存中的对象持久化到数据库表中，靠的就是对象标识符来区分两个对象是否是同一个。实体类中映射主键的字段就是OID，如下图所示： 1.3 Hibernate的主键生成策略 2. Hibernate的一级缓存和对象状态2.1 Hibernate的一级缓存什么缓存？ 它就是内存中的临时数据。 什么样的数据适用于缓存，什么样的数据不适用缓存？ 适用缓存的数据： 经常查询的，并且不经常修改的。同时数据一旦出现问题，对最终结果影响不大的。 不适用缓存的数据： 不管是否经常查询，只要是经常修改的，都可以不用缓存。并且如果数据由于使用缓存，产生了异常数据，对最终结果影响很大，则不能使用。例如：股市的牌价，银行的汇率，商品的库存等等。 2.1.1 Hibernate中的一级缓存Hibernate的一级缓存就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。Hibernate的一级缓存的作用就是减少对数据库的访问次数。 在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存。只要 Session 实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。 Hibernate的一级缓存有如下特点： 当应用程序调用Session接口的save()、update()、saveOrUpdate时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。 当调用Session接口的load()、get()方法，以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中。 当调用Session的close()方法时，Session缓存会被清空。 2.1.2 测试一级缓存123456789101112131415161718192021/** * 证明一级缓存确实存在 */@Testpublic void test1() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //1.根据id查询客户 //先去数据库查询，并且把查询的结果存入了一级缓存之中 Customer c1 = s.get(Customer.class, 1L); System.out.println(c1); //2.根据id再次查询客户 //先去一级缓存中看看有没有，如果有的话，直接拿过来用，如果没有的话，再去查询。 Customer c2 = s.get(Customer.class, 1L); System.out.println(c2); //true 一级缓存缓存的是对象的地址 System.out.println(c1 == c2); tx.commit(); //session关闭，一级缓存就消失了 s.close();&#125; 2.1.3 快照机制Hibernate 向一级缓存放入数据时，同时复制一份数据放入到Hibernate快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。 1234567891011121314151617181920212223@Testpublic void test2() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //1.根据id查询客户 Customer c5 = s.get(Customer.class, 2L); //输出客户的地址：北京市顺义区 System.out.println(c5.getCustAddress()); //2.修改客户的地址为 湖北省 c5.setCustAddress(\"湖北省\"); //输出客户的地址：湖北省 System.out.println(c5.getCustAddress()); //没有写update语句 tx.commit(); //session关闭，一级缓存就消失了 s.close(); //打印c5的address，这个c5能不能用 答案是可以使用。 //此时输出是什么 北京市顺义区 | 湖北省 System.out.println(c5.getCustAddress());&#125; 2.2 对象的状态2.2.1 对象的状态说明Hibernate为了更好的来管理持久化类，特将持久化类分成了三种状态。在Hibernate中持久化的对象可以划分为四种状态，分别是瞬时态、持久态、脱管态和删除状态，一个持久化类的实例可能处于四种不同状态中的某一种，四种状态的详细介绍如下。 瞬时态（transient） 瞬时态也称为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，不存在持久化标识OID（相当于主键值），尚未与Hibernate Session关联，在数据库中也没有记录，失去引用后将被JVM回收。瞬时状态的对象在内存中是孤立存在的，与数据库中的数据无任何关联，仅是一个信息携带的载体。 持久态（persistent） 持久态的对象存在持久化标识OID ，加入到了Session缓存中，并且相关联的Session没有关闭，在数据库中有对应的记录，每条记录只对应唯一的持久化对象，需要注意的是，持久态对象是在事务还未提交前变成持久态的。 脱管态（detached） 脱管态也称离线态或者游离态，当某个持久化状态的实例与Session的关联被关闭时就变成了脱管态。脱管态对象存在持久化标识OID，并且仍然与数据库中的数据存在关联，只是失去了与当前Session的关联，脱管状态对象发生改变时Hibernate不能检测到。 删除状态（了解） 2.2.2 学习对象状态我们要明确的 是为了更好的掌握hibernate中操作的方法。 区分状态只有两个标识：一是否有OID，二是否和Session建立的关系 瞬时状态（临时状态） 标志：没有OID，和Session没有关系。 持久化状态 标志：有OID，和Session有关系。只有持久化状态的对象才会有一级缓存的概念。 脱管状态（游离状态） 标志：有OID，和Session没有关系。 删除状态（了解）： 标志：有OID，和Session有关系。同时已经调用了删除方法，即将从数据库中把记录删除。但是事务还没有提交，此时的对象状态是删除态。 1234567891011@Testpublic void test2() &#123; //瞬时状态 Customer c = new Customer(); c.setCustName(\"测试_saveOrUpdate\"); Session s1 = HibernateUtil.openSession(); Transaction tx1 = s1.beginTransaction(); s1.saveOrUpdate(c); tx1.commit(); s1.close();&#125; 1234567891011121314151617181920@Testpublic void test3() &#123; Session s1 = HibernateUtil.openSession(); Transaction tx1 = s1.beginTransaction(); //持久化状态 Customer c = s1.get(Customer.class, 9L); tx1.commit(); s1.close(); c.setCustAddress(\"顺义校区\"); //脱管状态 System.out.println(c); Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); //持久化状态 session.saveOrUpdate(c); tx.commit(); session.close();&#125; 3. Hibernate的事务控制3.1 配置Session和线程绑定保证在Service中开启的事务时使用的Session对象和DAO中多个操作使用的是同一个Session对象。 在hibernate.cfg.xml文件中配置 12&lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt;&lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; 获取Session时使用的方法 1234567891011121314151617181920212223242526272829/** * 抽取hibernate的工具类 * * @author wgy */public class HibernateUtil &#123; private static SessionFactory factory; //了解：hibernate把可以预见的异常都转成了运行时异常 static &#123; try &#123; Configuration configuration = new Configuration(); configuration.configure(); factory = configuration.buildSessionFactory(); &#125; catch (ExceptionInInitializerError e) &#123; throw new ExceptionInInitializerError(\"初始化SessionFactory失败,请检查配置文件\"); &#125; &#125; /** * 从当前线程上获取Session对象 * @return session */ public static Session getCurrentSession()&#123; //只有配置了把session和线程绑定之后，才能使用此方法，否则返回值是null return factory.getCurrentSession(); &#125;&#125; 验证session和线程绑定的配置 12345678910111213141516171819202122@Testpublic void test1() &#123; Session s1 = HibernateUtil.getCurrentSession(); Session s2 = HibernateUtil.getCurrentSession(); // true System.out.println(s1 == s2);&#125;/** * 当我们把session和线程绑定之后，hibernate就会在提交或者回滚事务之后，自动帮我们关闭session */@Testpublic void test2() &#123; //瞬时状态 Customer c = new Customer(); c.setCustName(\"测试_getCurrentSession\"); Session s1 = HibernateUtil.getCurrentSession(); Transaction tx1 = s1.beginTransaction(); s1.saveOrUpdate(c); tx1.commit(); //s1.close();&#125; 4. Hibernate中的查询方式hibernate中一共有5种查询方式 OID查询： 根据id查询一个实体。涉及的方法：get和load SQL查询： 使用SQL语句查询数据库。涉及两种方式： 第一种：SQLQuery（一般不怎么用） 1234567891011121314151617@Testpublic void testFindAll() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //使用session对象，获取一个查询对象Query SQLQuery sqlquery = s.createSQLQuery(\"select * from cst_customer\"); //使用sqlquery对象获取结果集 List&lt;Object[]&gt; list = sqlquery.list(); for (Object[] os : list) &#123; System.out.println(\"------------数组中的内容-----------\"); for (Object o : os) &#123; System.out.println(o); &#125; &#125; tx.commit(); s.close();&#125; 第二种：session的doWork方法，它可以拿到Connection 1234567891011121314151617181920/** * hibernate中如何使用原始JDBC API * JDBC的API： * Connection * Statement * PreparedStatement * ResultSet */@Testpublic void test1() &#123; //1.获取Session对象 Session s = HibernateUtil.openSession(); //2.调用doWork方法 s.doWork(new Work() &#123; @Override public void execute(Connection conn) throws SQLException &#123; System.out.println(conn.getClass().getName()); &#125; &#125;);&#125; HQL查询： 使用HQL语句查询数据库 QBC查询： 使用Criteria对象查询数据库 对象导航查询： 对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。 5. Hibernate查询对象的API5.1 Query5.1.1 概述Query代表面向对象的一个Hibernate查询操作。 在Hibernate中，通常使用session.createQuery()方法接受一个HQL语句，然后调用Query的list()或uniqueResult()方法执行查询。 所谓的HQL是Hibernate Query Language缩写，其语法很像SQL语法，但它是完全面向对象的。 在Hibernate中使用Query对象的步骤，具体所示： 获得Hibernate的Session对象 编写HQL语句 调用session.createQuery 创建查询对象 如果HQL语句包含参数，则调用Query的setXxx设置参数 调用Query对象的方法执行查询 HQL的说明： ​ 把表的名称换成实体类名称。把表字段名称换成实体类属性名称。 例如： 12345SQL：select * from cst_customer where cust_name like ?HQL：select * from Customer where custName &#x3D; ?其中select * 可以省略，写为：from Customer where custName &#x3D; ? 5.1.2 常用查询5.1.2.1 基本查询12345678910111213141516/** * 基本查询 */@Testpublic void test1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.2 条件查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 条件查询 */@Testpublic void test2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer where custLevel = ? and custName like ?\"); //给参数占位符赋值 //hibernate的参数占位符是从0开始的 query.setString(0, \"23\"); query.setString(1, \"%集%\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125;/** * 条件查询 * 给参数占位符提供一个具体的名称 * 参数占位符的写法： * :名称 * 赋值的时候不需要写冒号，直接写名称 */@Testpublic void test3()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.获取Query对象 Query query = s.createQuery(\"from Customer where custName like :custName and custLevel = :custLevel\"); //2.给参数占位符赋值 //query.setString(\"custName\", \"%集%\"); //query.setString(\"custLevel\", \"普通客户\"); query.setParameter(\"custLevel\", \"23\"); query.setParameter(\"custName\", \"%集%\"); //3.执行对象的方法，获取结果集 List list = query.list(); for(Object o : list)&#123; System.out.println(o); &#125; tx.commit();&#125; 5.1.2.3 分页查询123456789101112131415161718192021222324252627282930/** * 分页查询 * mysql分页关键字 * limit * Limit的两个参数含义 * 第一个：查询的开始记录索引 * 第二个：每次查询的条数 * hibernate为我们提供了两个方法： * setFirstResult：设置查询的开始记录索引 * setMaxResults：设置每次查询的条数 * * 不管是用什么数据库，涉及分页的都是这两个方法。 * 因为SQL语句的生成已经是hibernate的事了。 */@Testpublic void test5() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer\"); //设置分页的方法 query.setFirstResult(2); query.setMaxResults(2); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.4 排序查询12345678910111213141516/** * 排序查询 */@Testpublic void test4() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer order by custId desc\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.5 统计查询12345678910111213141516171819202122232425/** * HQL使用聚合函数： * 统计查询 * 聚合函数： * count sum max min avg * * sql语句使用聚合函数时，在不使用group by子句的情况下，返回的结果，永远只有一行一列的情况。 * * 在SQL语句时： * select count(*) from table 它是统计所有字段，效率没有只统计主键字段高 * select count(主键) from table 它和第一个的结果是一样的，但是效率更高 * select count(非主键) from table 只统计不为null的字段 */@Testpublic void test1()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.获取Query对象 Query query = s.createQuery(\"select count(*) from Customer\"); //2.获取结果集 //当返回的结果唯一时，可以使用此方法。如果返回的结果不唯一，使用了此方法会抛异常。 Long total = (Long)query.uniqueResult(); System.out.println(total); tx.commit();&#125; 5.1.2.6 投影查询12345678910111213141516171819202122/** * 投影查询 * 当我们在查询实体时，只需要部分字段，而是全部。并且希望它的返回结果使用实体类来封装，而不是Object[] * 这个时候我们称之为创建实体类的投影 * * 投影查询的用法： * 1.查询语句需要时使用new关键字 * 2.在实体类中添加对应参数列表的构造函数 */@Testpublic void test7() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"select new com.wgy.domain.Customer(custId,custName) from Customer\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 123456789101112131415161718192021222324252627/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; public Customer() &#123; &#125; /** * //提供对应参数列表的构造函数 * @param custId * @param custName */ public Customer(Long custId, String custName) &#123; this.custId = custId; this.custName = custName; &#125; ..... 5.1.3 Query中的方法说明 list方法：该方法用于查询语句，返回的结果是一个list集合。 uniqueResult方法：该方法用于查询，返回的结果是一个Object对象。 setter方法：Query接口中提供了一系列的setter方法用于设置查询语句中的参数，针对不同的数据类型，需要用到不同的setter方法。 uniqueResult()方法：该方法用于返回唯一的结果，在确保只有一条记录的查询时可以使用该方法。 setFirstResult()方法：该方法可以设置获取第一个记录的位置，也就是它表示从第几条记录开始查询，默认从0开始计算。 setMaxResult()方法：该方法用于设置结果集的最大记录数，通常与setFirstResult()方法结合使用，用于限制结果集的范围，以实现分页功能。 5.2 Criteria5.2.1 概述Criteria是一个完全面向对象，可扩展的条件查询API，通过它完全不需要考虑数据库底层如何实现，以及SQL语句如何编写，它是Hibernate框架的核心查询对象。 Criteria 查询，又称为QBC查询（Query By Criteria），它是Hibernate的另一种对象检索方式。 通常，使用Criteria对象查询数据的主要步骤，具体如下： 获得Hibernate的Session对象 通过Session获得Criteria对象 使用Restrictions的静态方法创建Criterion条件对象。Restrictions类中提供了一系列用于设定查询条件的静态方法，这些静态方法都返回Criterion实例，每个Criterion实例代表一个查询条件 向Criteria对象中添加Criterion 查询条件。Criteria的add()方法用于加入查询条件 执行Criterita的 list() 或uniqueResult() 获得结果 细节： HQL能查的，QBC都能查，反之亦然。 5.2.2 常用查询5.2.2.1 基本查询1234567891011121314151617/** * 基本查询 */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 //它就相当于HQL的from Customer Criteria c = s.createCriteria(Customer.class); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.2 条件查询12345678910111213141516171819/** * 条件查询 */@Testpublic void test2() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //使用criteria对象的add方法来添加条件 c.add(Restrictions.eq(\"custLevel\", \"23\")); c.add(Restrictions.like(\"custName\", \"%集%\")); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.3 分页查询1234567891011121314151617181920/** * 分页查询 * QBC的分页查询和HQL的分页查询所用的方法和方法的含义都是一模一样的 */@Testpublic void test4() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //设置分页条件 c.setFirstResult(2); c.setMaxResults(2); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.4 排序查询123456789101112131415161718/** * 排序查询 */@Testpublic void test3() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //添加排序 c.addOrder(Order.desc(\"custId\")); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.5 统计查询1234567891011121314151617/** * 统计（投影）查询 */@Testpublic void test5() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //设置聚合函数 //c.setProjection(Projections.rowCount()); c.setProjection(Projections.count(\"custId\")); //2. 获取结果集 Long count = (Long)c.uniqueResult(); System.out.println(count); tx.commit();&#125; 5.2.2.6 离线查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 离线查询 * 离线： * 它是和在线对应的。 * Criteria对象是一个在线对象，它是由一个可用的（活动的）Session对象获取的出来的。 * 当session失效时，就无法再获取该对象了。 * 有一个对象，它也可以用于设置条件，但是获取的时候并不需要Session对象。该对象就叫做离线对象： * DetachedCriteria对象 * 使用该对象进行的查询就叫做：离线查询 * * 如何获取该对象 * DetachedCriteria dCriteria = DetachedCriteria.forClass(要查询的实体类字节码); */@Testpublic void testServlet()&#123; //1.获取离线对象，不需要Session DetachedCriteria dc = DetachedCriteria.forClass(Customer.class); //2.封装查询条件 dc.add(Restrictions.eq(\"custLevel\", \"23\")); dc.add(Restrictions.like(\"custName\",\"%集%\")); List list = testService(dc); for(Object o : list)&#123; System.out.println(o); &#125;&#125;private List testService(DetachedCriteria dc) &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); List list = testDao(dc); tx.commit(); return list; &#125;catch(Exception e)&#123; tx.rollback(); &#125; return null;&#125;private List testDao(DetachedCriteria dc) &#123; Session s = HibernateUtil.getCurrentSession(); //把离线对象转成在线对象 Criteria c = dc.getExecutableCriteria(s); return c.list();&#125; 5.2.3 QBC常用查询条件说明 短语 含义 Restrictions.eq 等于= Restrictions.allEq 使用Map,使用key/value进行多个等于的判断 Restrictions.gt 大于&gt; Restrictions.ge 大于等于&gt;= Restrictions.lt 小于&lt; Restrictions.le 小于等于&lt;= Restrictions.between 对应sql的between子句 Restrictions.like 对应sql的like子句 Restrictions.in 对应sql的in子句 Restrictions.and and 关系 Restrictions.or or关系 Restrictions.sqlRestriction Sql限定查询 Restrictions.asc() 根据传入的字段进行升序排序 Restrictions.desc() 根据传入的字段进行降序排序 运算类型 HQL运算符 QBC运算方法 type = Restrictions.eq() Restrictions.not(Restrictions.eq()) >= Restrictions.ge()","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(一)","date":"2020-05-28T06:17:43.000Z","path":"archives/ef455019.html","text":"1. Hibernate和ORM的概念1.1 Hibrenate概述它是一个轻量级，企业级，开源的ORM持久层框架。是可以操作数据库的框架。 框架：它就是一个架构。 通常情况下，软件工程的持久层解决方案，一个为主一个为辅。两者并存（写SQL语句的和不写SQL语句的 轻量级：指的是使用时依赖的资源很少。（目前我们使用的阶段，只依赖log4j，c3p0连接池） 企业级：指的是在企业级应用中使用的比较多 开源的：开放源代码。 ORM的操作方式：建立对象关系映射，实现操作实体类就相当于操作数据库表。 Hibernate框架是当今主流的Java持久层框架之一，由于它具有简单易学、灵活性强、扩展性强等特点，能够大大地简化程序的代码量，提高工作效率，因此受到广大开发人员的喜爱。 Hibernate是一个开放源代码的ORM框架，它对JDBC进行了轻量级的对象封装，使得Java开发人员可以使用面向对象的编程思想来操作数据库。 1.2 ORMObject Relational Mapping 对象关系映射 就是建立实体类和数据库表的对应关系。 实现操作实体类对象就相当于操作数据库表 Object Relation Mapping 对象关系映射。 对象-关系映射（OBJECT/RELATIONALMAPPING，简称ORM），是随着面向对象的软件开发方法发展而产生的。用来把对象模型表示的对象映射到基于S Q L 的关系模型数据库结构中去。这样，我们在具体的操作实体对象的时候，就不需要再去和复杂的 SQ L 语句打交道，只需简单的操作实体对象的属性和方法[2] 。O R M 技术是在对象和关系之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化[1] 。 简单的说就是把我们程序中的实体类和数据库表建立起来对应关系。 1.3 为什么要学习Hibernate与其它操作数据库的技术相比，Hibernate具有以下几点优势： Hibernate对JDBC访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了DAO（Data Access Object，数据访问对象）层编码工作。 Hibernate的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。 可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。 明确： ​ 操作实体类就相当于操作数据库表 使用传统的JDBC开发应用系统时，如果是小型应用系统，并不觉得有什么麻烦，但是对于大型应用系统的开发，使用JDBC就会显得力不从心。例如对几十、几百张包含几十个字段的表进行插入操作时，编写的SQL语句不但很长，而且繁琐，容易出错；在读取数据时，需要写多条getXxx语句从结果集中取出各个字段的信息，不但枯燥重复，并且工作量非常大。为了提高数据访问层的编程效率，Gavin King开发出了一个当今最流行的的ORM框架，它就是Hibernate框架。 所谓的ORM就是利用描述对象和数据库表之间映射的元数据，自动把Java应用程序中的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库表的操作。可以把ORM理解为关系型数据和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。ORM原理如图所示。 2. CRMCRM：客户关系管理系统 CRM（Customer Relationship Management）客户关系管理，是利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，向客户提供创新式的个性化的客户交互和服务的过程。 其最终目标是将面向客户的各项信息和活动集成起来，组建一个以客户为中心的企业，实现对面向客户的活动的全面管理。 3. Hibernate快速入门3.1 需求介绍保存一个客户到数据库的客户表中。 3.2 搭建Hibernate开发环境3.2.1 第一步：拷贝必备的jar包到开发目录数据库驱动包，如下图： Hibernate/lib/required/*.jar，如下图： 日志记录的包，如下图: 3.2.2 第二步：创建数据库和实体类持久化类是应用程序中的业务实体类，这里的持久化是指类的对象能够被持久化保存到数据库中。Hibernate使用普通Java对象（Plain Old Java Object），即POJO的编程模式来进行持久化。POJO类中包含的是与数据库表相对应的各个属性，这些属性通过getter和setter方法来访问，对外部隐藏了内部的实现细节。下面就来编写Customer持久化类。 在项目src目录下，创建cn.wgy.domain包，并在包中创建实体类Customer（对应数据库表cst_customer），Customer类包含与cst_customer数据表字段对应的属性，以及相应的getXxx ()和setXxx ()方法。 1234567891011&#x2F;*创建客户表*&#x2F;CREATE TABLE &#96;cst_customer&#96; ( &#96;cust_id&#96; bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#39;客户编号(主键)&#39;, &#96;cust_name&#96; varchar(32) NOT NULL COMMENT &#39;客户名称(公司名称)&#39;, &#96;cust_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户信息来源&#39;, &#96;cust_industry&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户所属行业&#39;, &#96;cust_level&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户级别&#39;, &#96;cust_address&#96; varchar(128) DEFAULT NULL COMMENT &#39;客户联系地址&#39;, &#96;cust_phone&#96; varchar(64) DEFAULT NULL COMMENT &#39;客户联系电话&#39;, PRIMARY KEY (&#96;cust_id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;94 DEFAULT CHARSET&#x3D;utf8; 123456789101112131415/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; ...&#125; 3.2.3 第三步：编写映射配置文件（xml）实体类Customer目前还不具备持久化操作的能力，而Hibernate需要知道实体类Customer映射到数据库Hibernate中的哪个表，以及类中的哪个属性对应数据库表中的哪个字段，这些都需要在映射文件中配置。 在实体类Customer所在的包中，创建一个名称为Customer.hbm.xml的映射文件，在该文件中定义了实体类Customer的属性是如何映射到cst_customer表的列上的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml --&gt;&lt;!-- 导入约束:dtd约束 位置：在Hibernate的核心jar包中名称为hibernate-mapping-3.0.dtd 明确该文件中的内容： 实体类和表的对应关系 实体类中属性和表的字段的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;!-- package属性用于设定包的名称，接下来该配置文件中凡是用到此包中的对象时都可以省略包名 --&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;!-- class标签 作用：建立实体类和表的对应关系 属性： name：指定实体类的名称 table：指定数据库表的名称 --&gt; &lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot;&gt; &lt;!-- id标签 作用：用于映射主键 属性： name：指定的是属性名称。也就是get&#x2F;set方法后面的部分，并且首字母要转小写。 column:指定的是数据库表的字段名称 --&gt; &lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt; &lt;!-- generator标签： 作用：配置主键的生成策略。 属性： class:指定生成方式的取值。 取值之一：native。使用本地数据库的自动增长能力。 mysql数据库的自动增长能力是让某一列自动+1。但是不是所有数据库都支持这种方式。 --&gt; &lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;!-- property标签： 作用：映射其他字段 属性： name：指定属性的名称。和id标签的name属性含义一致 column：指定数据库表的字段名称 --&gt; &lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 3.2.4 第四步：编写主配置文件（hibernate.cfg.xml）Hibernate的映射文件反映了持久化类和数据库表的映射信息，而Hibernate的配置文件则主要用来配置数据库连接以及Hibernate运行时所需要的各个属性的值。在项目的src下创建一个名称为hibernate.cfg.xml的文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 在类的根路径下创建名称为hibernate.cfg.xml的配置文件 --&gt;&lt;!-- 导入dtd约束： 位置：在核心jar包中的名称为hibernate-configuration-3.0.dtd中--&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory SessionFactory的作用就是用于创建Session对象的。 Session对象就是hibernate中操作数据库的核心对象。 此处的配置不要求背，但是要求记住创建SessionFactory必须的三部分信息 第一部分： 连接数据库的信息 第二部分： hibernate的可选配置 第三部分： 映射文件的位置 --&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;property&gt; &lt;!-- 是否让hibernate根据表结构的变化来生成DDL语句 DDL:数据定义语言 hibernate可以根据映射文件来为我们生成数据库的表结构。但是他不能生成数据库。 hbm2ddl.auto的取值 * none:不用Hibernate自动生成表. * create:每次都会创建一个新的表.(测试) * create-drop:每次都会创建一个新的表，执行程序结束后删除这个表.(测试) * update:如果数据库中有表，使用原来的表，如果没有表，创建一个新表.可以更新表结构。 * validate:只会使用原有的表.对映射关系进行校验. --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping resource&#x3D;&quot;com&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 3.4 实现保存操作在项目中新建一个名称为cn.wgy.test的包，然后在包中建立一个名为HibernateDemo1Test.java的文件，该文件是用来测试的类文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * hibernate的入门案例 * 需求： * 实现保存一个客户到数据库 * * @author wgy */public class HibernateDemo1Test &#123; /** * 步骤分析 * 1、解析主配置文件 * 2、根据配置文件创建SessionFactory * 3、根据SessionFactory创建Session * 4、开启事务 * 5、执行操作（保存） * 6、提交事务 * 7、释放资源 */ @Test public void test1() &#123; Customer customer = new Customer(); customer.setCustName(\"测试1\"); // 1、解析主配置文件 Configuration configuration = new Configuration(); configuration.configure(); // 2、根据配置文件创建SessionFactory SessionFactory sessionFactory = configuration.buildSessionFactory(); // 3、根据SessionFactory创建Session Session session = sessionFactory.openSession(); // 4、开启事务 Transaction transaction = session.beginTransaction(); // 5、执行操作（保存） session.save(customer); // 6、提交事务 transaction.commit(); // 7、释放资源 session.close(); sessionFactory.close(); &#125;&#125; 3.5 入门案例的执行过程首先创建Configuration类的实例，并通过它来读取并解析配置文件hibernate.cfg.xml。然后创建SessionFactory读取解析映射文件信息，并将Configuration对象中的所有配置信息拷贝到SessionFactory内存中。接下来，打开Session，让SessionFactory提供连接，并开启一个事务，之后创建对象，向对象中添加数据，通过session.save()方法完成向数据库中保存数据的操作。最后提交事务，并关闭资源。 4. Hibernate中API介绍4.1 Configuration对象4.1.1 作用在使用Hibernate时，首先要创建Configuration实例，Configuration实例主要用于启动、加载、管理hibernate的配置文件信息。在启动Hibernate的过程中，Configuration实例首先确定Hibernate配置文件的位置，然后读取相关配置，最后创建一个唯一的SessionFactory实例。Configuration对象只存在于系统的初始化阶段，它将SessionFactory创建完成后，就完成了自己的使命。 Hibernate通常使用Configuration config = new Configuration().configure();的方式创建实例，此种方式默认会去src下读取 hibernate.cfg.xml配置文件。如果不想使用默认的hibernate.cfg.xml配置文件，而是使用指定目录下（或自定义）的配置文件，则需要向configure()方法中传递一个文件路径的参数，其代码写法如下： 1Configuration config &#x3D; new Configuration().configure(&quot;xml文件位置&quot;); 此种写法hibernate会去指定位置查找配置文件，例如，想要使用src下config包中的 hibernate.cfg.xml文件，只需将文件位置加入configure()中即可，其代码如下所示： 1Configuration config = new Configuration().configure(\"/config/hibernate.cfg.xml\"); 【加载映射文件】 Hibernate除了可以使用Configuration对象加载核心配置文件以外，还可以利用该对象加载映射文件。因为如何使用properties文件作为Hibernate的核心配置文件，其他的属性可以使用key=value的格式来设置，但是映射没有办法加载。这时这个对象就有了用武之地。可以在手动编写代码的时候去加载映射文件。 123Configuration configuration &#x3D; new Configuration().configure(&quot;xml文件位置&quot;);configuration.addResource(&quot;cn&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;); 4.1.2 常用方法1234567891011121314默认构造函数： 它只能加载类的根路径下，名称为hibernate.properties的配置文件。不能加载xmlconfigure()： 它用于加载类的根路径下，名称为hibernate.cfg.xml的配置文件。 configuration.configure();buildSessionFactory()： 根据配置文件，构建SessionFactory SessionFactory sessionFactory &#x3D; configuration.buildSessionFactory();addResource(String url); 指定映射文件的位置 configuration.addResource(&quot;com&#x2F;itheima&#x2F;domain&#x2F;Customer.hbm.xml&quot;);addClass(Class clazz); 指定实体类的字节码 configuration.addClass(Customer.class); 4.2 SessionFactory4.2.1 作用SessionFactory接口负责Hibernate的初始化和建立Session对象。它在Hibernate中起到一个缓冲区作用，Hibernate可以将自动生成的SQL语句、映射数据以及某些可重复利用的的数据放在这个缓冲区中。同时它还保存了对数据库配置的所有映射关系，维护了当前的二级缓存。 SessionFactory 实例是通过Configuration对象获取的，其获取方法如下所示。 1SessionFactory sessionFactory = config.buildSessionFactory(); 4.2.2 常用方法1openSession()：每次都是生成一个新的Session 4.2.3 细节该对象维护了很多信息： 连接数据库的信息 hibernate的基本配置 映射文件的位置，以及映射文件中的配置 一些预定义的SQL语句（这些语句都是通用的） 比如：全字段保存，根据id的全字段更新，根据id的全字段查询，根据id的删除等等。 hibernate的二级缓存（了解） 同时，它是一个线程安全的对象，所有由该工厂生产的Session都共享工厂中维护的数据。 4.2.4 使用原则由于SessionFactory维护了很多信息同时又是线程安全的，一般情况下，一个项目中只需要一个SessionFactory，只有当应用中存在多个数据源时，才为每个数据源建立一个SessionFactory实例。因此，不应该反复的创建和销毁。 原则：一个应用应该只有一个SessionFactory。在应用加载时创建，应用卸载时销毁。 4.2.5 在hibernate中使用数据源(连接池)SessionFactory内部还维护了一个连接池，如果我们需要使用第三方的连接池如C3P0，那么需要我们自己手动进行配置 配置C3P0步骤如下： 导入连接池的jar包 在hibernate主配置文件中配置 1234&lt;!-- 配置数据源的提供商 --&gt;&lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt; org.hibernate.connection.C3P0ConnectionProvider&lt;&#x2F;property&gt; 4.3 Session4.3.1 作用Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。 创建SessionFactory实例后，就可以通过它获取Session实例。获取Session实例有两种方式，一种是通过openSession()方法，另一种是通过getCurrentSession()方法。两种方法获取session的代码如下所示： 12345//采用openSession方法创建sessionSession session = sessionFactory.openSession();//采用getCurrentSession()方法创建sessionSession session = sessionFactory.getCurrentSession(); 以上两种获取session实例方式的主要区别是，采用openSession方法获取Session实例时，SessionFactory直接创建一个新的Session实例，并且在使用完成后需要调用close方法进行手动关闭。而getCurrentSession方法创建的Session实例会被绑定到当前线程中，它在提交或回滚操作时会自动关闭。 4.3.2 常用方法123456789save(Object entity); ：保存一个实体到数据库update(Object entity);：更新一个实体delete(Object entity);：删除一个实体get(Class clazz,Serializable id);：根据id查询一个实体。参数的含义：Class表示要查询的实体类字节码。Serializable就是查询的条件。beginTransaction();：开启事务，并返回事务对象 4.3.3 细节由于SessionFactory已经维护了很多数据，所以Session就维护较少的内容。 它是一个轻量级对象。并且：它不是线程安全的！！！！！！！ 它维护了hibernate的一级缓存。 它的反复创建销毁不会消耗太多资源。 4.3.4 使用原则每个线程都只有一个Session对象。 4.4 Transaction4.4.1 作用Transaction接口主要用于管理事务，它是Hibernate的数据库事务接口，且对底层的事务接口进行了封装。Transaction接口的事务对象是通过Session对象开启的，其开启方式如下所示。 1Transaction transaction &#x3D; session.beginTransaction(); 4.4.2 常用方法123commit()：提交事务rollback()：回滚事务 Session执行完数据库操作后，要使用Transaction接口的commit()方法进行事务提交，才能真正的将数据操作同步到数据库中。发生异常时，需要使用rollback()方法进行事务回滚，以避免数据发生错误。因此，在持久化操作后，必须调用Transaction接口的commit()方法和rollback()方法。如果没有开启事务，那么每个Session的操作，都相当于一个独立的操作。 123456789101112131415161718@Testpublic void testSave1() &#123; Customer c = new Customer(); c.setCustName(\"测试保存功能\"); Transaction tx = null; Session s = null; try &#123; s = HibernateUtil.openSession(); tx = s.beginTransaction(); //保存客户 s.save(c); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); &#125; finally &#123; s.close(); &#125;&#125; 5. 抽取HibernateUtil工具类1234567891011121314151617181920212223242526272829/** * hibernate的工具类 * 用于生产一个Session对象 * * @author wgy */public class HibernateUtil &#123; private static SessionFactory factory; static&#123; try &#123; Configuration cfg = new Configuration(); cfg.configure(); factory = cfg.buildSessionFactory(); &#125; catch (Exception e) &#123; //e.printStackTrace(); throw new ExceptionInInitializerError(\"初始化SessionFactory失败\"); &#125; &#125; /** * 获取一个新的Session对象 * @return */ public static Session openSession()&#123; return factory.openSession(); &#125;&#125; 6. 案例：使用Hibernate实现CRUD6.1 保存操作12345678910111213141516@Testpublic void testAdd()&#123; Customer c = new Customer(); c.setCustName(\"测试保存功能\"); //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 //Transaction tx = session.beginTransaction(); //3.保存客户 session.save(c); //4.提交事务 //tx.commit(); //5.释放资源 session.close();&#125; 6.2 查询一个实体1234567891011121314@Testpublic void testFindOne()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为2的客户 Customer c = session.get(Customer.class, 2L); System.out.println(c); //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.3 修改操作1234567891011121314151617@Testpublic void testUpdate()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为2的客户 Customer c = session.get(Customer.class, 2L); //修改客户的地址为：湖北省 c.setCustAddress(\"湖北省\"); //执行更新 session.update(c); //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.4 删除操作123456789101112131415@Testpublic void testDelete()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为1的客户 Customer c = session.get(Customer.class, 1L); //删除实体 session.delete(c);//delete from cst_customer where cust_id = ? //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.5 实体查询get和load方法6.5.1 实体查询的概念所谓实体查询即OID查询，就是使用主键作为条件来查询一个实体。其中涉及的方法是Session对象get方法和load方法。 6.5.2 方法的说明get方法： 12345678910111213141516/** * 根据id查询一个实体 * @param entityType 指的是要查询的实体类字节码对象 * @param id 查询的条件，即主键的值。 * @return 返回的是实体类对象 */&lt;T&gt; T get(Class&lt;T&gt; entityType, Serializable id);@Testpublic void testGet()&#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 2L); System.out.println(\"get : \"+c.toString()); tx.commit();&#125; load方法： 12345678910111213141516/** * 根据id查询一个实体 * @param theClass 指的是要查询的实体类字节码 * @param id查询的条件，即主键的值。 * @return 返回的是实体类对象或者是实体类对象的代理对象 */&lt;T&gt; T load(Class&lt;T&gt; theClass, Serializable id);@Testpublic void testLoad()&#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); Customer c = s.load(Customer.class, 2L); System.out.println(\"load : \"+c.toString()); tx.commit();&#125; 6.5.3 get和load的区别 查询的时机不一样。 get的查询时机：每次调用get方法时，马上发起查询。 立即加载 load的查询时机：每次真正使用的时候，发起查询。 延迟加载 懒加载 惰性加载 返回的结果不一样。 get方法返回的对象是实体类类型 load方法返回的对象是实体类类型的代理对象 load方法默认情况下是延迟，可以通过配置的方式改为立即加载。 12&lt;!-- 由于load方法是hibernate的方法所以只有XML的方式：--&gt;&lt;class name=\"Customer\" table=\"cst_customer\" lazy=\"false\"&gt;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"使用hexo+github搭建免费个人博客","date":"2020-05-15T11:40:37.000Z","path":"archives/52429b60.html","text":"前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi wgy1993! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置： 12$ git config --global user.name &quot;yourname&quot;&#x2F;&#x2F; 你的github用户名，非昵称$ git config --global user.email &quot;xxx@163.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱 具体这个配置是干嘛的我没仔细深究。 使用hexo写博客hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装1$ npm install -g hexo 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\\MyGitWorkSpace\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /e/MyGitWorkSpace/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了 浏览目录 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： 12$ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里： 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法： 1234deploy: type: git repository: git@github.com:wgy1993&#x2F;wgy1993.github.io.git branch: master 错误写法： 1234deploy: type: github repository: https:&#x2F;&#x2F;github.com&#x2F;wgy1993&#x2F;wgy1993.github.io.git branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件： 1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 保留README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 常用hexo命令常见命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写： 1234hexo n &#x3D;&#x3D; hexo newhexo g &#x3D;&#x3D; hexo generatehexo s &#x3D;&#x3D; hexo serverhexo d &#x3D;&#x3D; hexo deploy 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 写博客定位到我们的hexo根目录，执行命令： 1hexo new &#39;my-first-blog&#39; hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 那么hexo new page &#39;postName&#39;命令和hexo new &#39;postName&#39;有什么区别呢？ 1hexo new page &quot;my-second-blog&quot; 生成如下： 最终部署时生成：hexo\\public\\my-second-blog\\index.html，但是它不会作为文章出现在博文目录。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上``即可，例如： 12345678910111213# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； 最终效果：","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wgy1993.gitee.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://wgy1993.gitee.io/tags/GitHub/"}]}]