[{"title":"MyBatis(四)","date":"2020-06-23T14:38:54.000Z","path":"archives/bf2fe2d.html","text":"1. Mybatis 延迟加载策略1.1 何为延迟加载就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。 好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 坏处 ：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 1.2 实现需求查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加载。 1.3 使用 assocation 实现延迟加载1.3.1 在 Account 实体类中加入 user 属性123456789101112131415/** * 账户实体类 * * @author wgy */public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //从表实体应该包含一个主表实体的对象引用 private User user; ...&#125; 1.3.2 账户的持久层 DAO 接口1234567891011121314/** * 账户持久层接口 * * @author wgy */public interface IAccountDao &#123; /** * 查询所有账户，同时还要获取到当前账户的所属用户信息 * * @return */ List&lt;Account&gt; findAll();&#125; 1.3.3 账户的持久层映射文件123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IAccountDao\"&gt; &lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"uid\" column=\"uid\"/&gt; &lt;result property=\"money\" column=\"money\"/&gt; &lt;!-- 一对一的关系映射：配置封装user的内容 select属性指定的内容：查询用户的唯一标识： column属性指定的内容：用户根据id查询时，所需要的参数的值 --&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\" select=\"com.wgy.dao.IUserDao.findById\"/&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultMap=\"accountUserMap\"&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; 1.3.4 用户的持久层接口和映射文件123456789101112131415/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 根据id查询用户信息 * * @param userId * @return */ User findById(Integer userId);&#125; 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 1.3.5 开启 Mybatis 的延迟加载策略进入 Mybaits 的官方文档，找到 settings 的说明信息： 我们需要在 Mybatis 的配置文件 SqlMapConfig.xml 文件中添加延迟加载的配置。 123456&lt;!--配置参数--&gt;&lt;settings&gt; &lt;!--开启Mybatis支持延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"&gt;&lt;/setting&gt;&lt;/settings&gt; 1.3.6 编写测试只查账户信息不查用户信息12345678/** * 测试查询所有 */@Testpublic void testFindAll() &#123; //5.执行操作 List&lt;Account&gt; accounts = accountDao.findAll();&#125; 测试结果如下： 我们发现，因为本次只是将Account对象查询出来放入List集合中，并没有涉及到User对象，所以就没有发出 SQL 语句查询账户所关联的 User 对象的查询。 1.4 使用 Collection 实现延迟加载1.4.1 在 User 实体类中加入List&lt;Account&gt;属性12345678910111213141516/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //一对多关系映射：主表实体应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; ...&#125; 1.4.2 用户的持久层 DAO 接口123456/** * 查询所有用户，同时获取到用户下所有账户的信息 * * @return */List&lt;User&gt; findAll(); 1.4.3 用户的持久层映射文件12345678910111213141516&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=\"userAccountMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"account\" select=\"com.wgy.dao.IAccountDao.findAccountByUid\" column=\"id\"/&gt;&lt;/resultMap&gt;&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; select * from user&lt;/select&gt; 1.4.4 账户的持久层接口和映射文件1234567/** * 根据用户id查询账户信息 * * @param uid * @return */List&lt;Account&gt; findAccountByUid(Integer uid); 123456&lt;!-- 根据用户id查询账户列表 --&gt;&lt;select id=\"findAccountByUid\" resultType=\"account\" parameterType=\"int\"&gt; select * from account where uid = #&#123;id&#125;&lt;/select&gt; 1.4.5 编写测试只查用户信息不查账户信息12345678/** * 测试查询所有 */@Testpublic void testFindAll() &#123; //5.执行操作 List&lt;User&gt; users = userDao.findAll();&#125; 测试结果如下： 我们发现并没有加载 Account 账户信息。 2. Mybatis 缓存像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。 Mybatis 中缓存分为一级缓存，二级缓存。 2.1 Mybatis 一级缓存2.1.1 证明一级缓存的存在一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close或clearCache，它就存在。 2.1.1.1 编写用户持久层 Dao 接口123456789101112131415/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 根据id查询用户信息 * * @param userId * @return */ User findById(Integer userId);&#125; 2.1.1.2 编写用户持久层映射文件12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 2.1.1.3 编写测试方法123456789101112/** * 测试一级缓存 */@Testpublic void testFirstLevelCache() &#123; //5.执行操作 User user1 = userDao.findById(41); System.out.println(user1); User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125; 测试结果如下： 我们可以发现，虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis 提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询 id为41的记录时，并没有发出sql语句从数据库中查询数据，而是从一级缓存中查询。 2.1.2 一级缓存的分析一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。 得到用户信息，将用户信息存储到一级缓存中。 如果 sqlSession 去执行 commit 操作（执行插入、更新、删除），清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。 2.1.3 测试一级缓存的清空12345678910111213141516/** * 测试一级缓存 */@Testpublic void testFirstLevelCache() &#123; User user1 = userDao.findById(41); System.out.println(user1);// sqlSession.close(); //再次获取SqlSession对象// sqlSession = factory.openSession(); sqlSession.clearCache();//此方法也可以清空缓存 userDao = sqlSession.getMapper(IUserDao.class); User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125; 1234567891011121314151617181920/** * 测试缓存的同步 */@Testpublic void testClearlCache() &#123; //1.根据id查询用户 User user1 = userDao.findById(41); System.out.println(user1); //2.更新用户信息 user1.setUsername(\"update user clear cache\"); user1.setAddress(\"北京市海淀区\"); userDao.updateUser(user1); //3.再次查询id为41的用户 User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125; 当执行sqlSession.close()后，再次获取sqlSession并查询id=41的User对象时，又重新执行了sql语句，从数据库进行了查询操作。 2.2 Mybatis 二级缓存二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 2.2.1 二级缓存结构图 首先开启 mybatis 的二级缓存。 sqlSession1 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。 如果 SqlSession3 去执行相同 mapper 映射下 sql，执行 commit 提交，将会清空该 mapper 映射下的二级缓存区域的数据。 sqlSession2 去查询与 sqlSession1 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。 2.2.2 二级缓存的开启与关闭2.2.2.1 在 SqlMapConfig.xml 文件开启二级缓存123456&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt;因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。 2.2.2.2 配置相关的 Mapper 映射文件1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!--开启user支持二级缓存--&gt; &lt;cache/&gt;&lt;/mapper&gt;&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。 2.2.2.3 配置 statement 上面的 useCache12345678&lt;!-- 根据id查询用户 --&gt;&lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\" useCache=\"true\"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt;&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。 2.2.3 二级缓存测试12345678910111213141516171819/** * 测试二级缓存 */@Testpublic void testFirstLevelCache() &#123; SqlSession sqlSession1 = factory.openSession(); IUserDao dao1 = sqlSession1.getMapper(IUserDao.class); User user1 = dao1.findById(41); System.out.println(user1); sqlSession1.close();//一级缓存消失 SqlSession sqlSession2 = factory.openSession(); IUserDao dao2 = sqlSession2.getMapper(IUserDao.class); User user2 = dao2.findById(41); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2);&#125; 经过上面的测试，我们发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二次查询时，我们发现并没有对数据库发出 sql 语句，所以此时的数据就只能是来自于我们所说的二级缓存。 2.2.4 二级缓存注意事项当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。 3. Mybatis 注解开发3.1 mybatis 的常用注解说明1234567891011@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace:实现注解二级缓存的使用 3.2 使用 Mybatis 注解实现基本 CRUD3.2.1 编写实体类1234567891011121314/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; ...&#125; 3.2.2 使用注解方式开发持久层接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 在mybatis中针对CRUD一共有四个注解 * * @author wgy * @Select @Insert @Update @Delete */public interface IUserDao &#123; /** * 查询所有用户 * * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll(); /** * 保存用户 * * @param user */ @Insert(\"insert into user(username,address,sex,birthday)values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)\") void saveUser(User user); /** * 更新用户 * * @param user */ @Update(\"update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;\") void updateUser(User user); /** * 删除用户 * * @param userId */ @Delete(\"delete from user where id=#&#123;id&#125; \") void deleteUser(Integer userId); /** * 根据id查询用户 * * @param userId * @return */ @Select(\"select * from user where id=#&#123;id&#125; \") User findById(Integer userId); /** * 根据用户名称模糊查询 * * @param username * @return */ @Select(\"select * from user where username like #&#123;username&#125; \")// @Select(\"select * from user where username like '%$&#123;value&#125;%' \") List&lt;User&gt; findUserByName(String username); /** * 查询总用户数量 * * @return */ @Select(\"select count(*) from user \") int findTotalUser();&#125; 3.2.3 编写 SqlMapConfig 配置文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置properties--&gt; &lt;properties resource=\"jdbcConfig.properties\"/&gt; &lt;!--使用typeAliases配置别名，它只能配置domain中类的别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.wgy.domain\"/&gt; &lt;/typeAliases&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置映射文件的位置 --&gt; &lt;mappers&gt; &lt;!-- 配置 dao 接口的位置，它有两种方式 第一种：使用 mapper 标签配置 class 属性 第二种：使用 package 标签，直接指定 dao 接口所在的包 --&gt; &lt;package name=\"com.wgy.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.2.4 编写测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @author wgy */public class AnnotationCRUDTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before public void init() throws Exception &#123; in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); factory = new SqlSessionFactoryBuilder().build(in); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; session.commit(); session.close(); in.close(); &#125; @Test public void testSave() &#123; User user = new User(); user.setUsername(\"mybatis annotation\"); user.setAddress(\"北京市昌平区\"); userDao.saveUser(user); &#125; @Test public void testUpdate() &#123; User user = new User(); user.setId(57); user.setUsername(\"mybatis annotation update\"); user.setAddress(\"北京市海淀区\"); user.setSex(\"男\"); user.setBirthday(new Date()); userDao.updateUser(user); &#125; @Test public void testDelete() &#123; userDao.deleteUser(51); &#125; @Test public void testFindOne() &#123; User user = userDao.findById(57); System.out.println(user); &#125; @Test public void testFindByName() &#123; List&lt;User&gt; users = userDao.findUserByName(\"%mybatis%\");// List&lt;User&gt; users = userDao.findUserByName(\"mybatis\"); for (User user : users) &#123; System.out.println(user); &#125; &#125; @Test public void testFindTotal() &#123; int total = userDao.findTotalUser(); System.out.println(total); &#125;&#125; 3.3 使用注解实现复杂关系映射开发实现复杂关系映射之前我们可以在映射文件中通过配置&lt;resultMap&gt;来实现，在使用注解开发时我们需要借助@Results 注解，@Result 注解，@One 注解，@Many 注解。 3.3.1 复杂关系映射的注解说明123456789101112131415161718192021222324252627@Results 注解代替的是标签&lt;resultMap&gt;该注解中可以使用单个@Result 注解，也可以使用@Result 集合@Results（&#123;@Result（），@Result（）&#125;）或@Results（@Result（））@Resutl 注解代替了 &lt;id&gt; 标签和&lt;result&gt; 标签@Result 中 属性介绍： id 是否是主键字段 column 数据库的列名 property 需要装配的属性名 one 需要使用的@One 注解（@Result（one&#x3D;@One）（））） many 需要使用的@Many 注解（@Result（many&#x3D;@many）（）））@One 注解（一对一） 代替了&lt;assocation&gt; 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。@One 注解属性介绍： select 指定用的 来多表查询的 sqlmapper fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。 使用格式： @Result(column&#x3D;&quot; &quot;,property&#x3D;&quot;&quot;,one&#x3D;@One(select&#x3D;&quot;&quot;))@Many 注解（多对一） 代替了&lt;Collection&gt; 标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType（一般为 ArrayList）但是注解中可以不定义； 使用格式： @Result(property&#x3D;&quot;&quot;,column&#x3D;&quot;&quot;,many&#x3D;@Many(select&#x3D;&quot;&quot;)) 3.3.2 使用注解实现一对一 复杂关系映射及延迟加载加载账户信息时并且加载该账户的用户信息，根据情况可实现延迟加载。（注解方式实现） 3.3.2.1 添加 User 实体类及 Account 实体类1234567891011121314/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer userId; private String userName; private String userAddress; private String userSex; private Date userBirthday; ...&#125; 1234567891011121314/** * 账户实体类 * * @author wgy */public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //多对一（mybatis中称之为一对一）的映射：一个账户只能属于一个用户 private User user; ...&#125; 3.3.2.2 添加账户的持久层接口并使用注解配置123456789101112131415161718192021/** * 账户持久层接口 * * @author wgy */public interface IAccountDao &#123; /** * 查询所有账户，并且获取每个账户所属的用户信息 * * @return */ @Select(\"select * from account\") @Results(id = \"accountMap\", value = &#123; @Result(id = true, column = \"id\", property = \"id\"), @Result(column = \"uid\", property = \"uid\"), @Result(column = \"money\", property = \"money\"), @Result(property = \"user\", column = \"uid\", one = @One(select = \"com.wgy.dao.IUserDao.findById\", fetchType = FetchType.EAGER)) &#125;) List&lt;Account&gt; findAll();&#125; 3.3.2.3 添加用户的持久层接口并使用注解配置123456789101112131415161718192021222324252627282930313233/** * 在mybatis中针对CRUD一共有四个注解 * * @author wgy * @Select @Insert @Update @Delete */public interface IUserDao &#123; /** * 查询所有用户 * * @return */ @Select(\"select * from user\") @Results(id = \"userMap\", value = &#123; @Result(id = true, column = \"id\", property = \"userId\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"address\", property = \"userAddress\"), @Result(column = \"sex\", property = \"userSex\"), @Result(column = \"birthday\", property = \"userBirthday\") &#125;) List&lt;User&gt; findAll(); /** * 根据id查询用户 * * @param userId * @return */ @Select(\"select * from user where id=#&#123;id&#125; \") @ResultMap(\"userMap\") User findById(Integer userId);&#125; 3.3.2.4 测试一对一关联及延迟加载1234@Testpublic void testFindAll() &#123; List&lt;Account&gt; accounts = accountDao.findAll();&#125; 3.3.3 使用注解实现一对多复杂关系映射查询用户信息时，也要查询他的账户列表。使用注解方式实现。 3.3.3.1 User 实体类加入List&lt;Account&gt;12345678910111213141516/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer userId; private String userName; private String userAddress; private String userSex; private Date userBirthday; //一对多关系映射：一个用户对应多个账户 private List&lt;Account&gt; accounts; ...&#125; 3.3.3.2 编写用户的持久层接口并使用注解配置123456789101112131415/** * 查询所有用户 * * @return */@Select(\"select * from user\")@Results(id = \"userMap\", value = &#123; @Result(id = true, column = \"id\", property = \"userId\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"address\", property = \"userAddress\"), @Result(column = \"sex\", property = \"userSex\"), @Result(column = \"birthday\", property = \"userBirthday\"), @Result(property = \"accounts\", column = \"id\", many = @Many(select = \"com.wgy.dao.IAccountDao.findAccountByUid\", fetchType = FetchType.LAZY))&#125;)List&lt;User&gt; findAll(); 3.3.3.3 编写账户的持久层接口并使用注解配置12345678/** * 根据用户id查询账户信息 * * @param userId * @return */@Select(\"select * from account where uid = #&#123;userId&#125;\")List&lt;Account&gt; findAccountByUid(Integer userId); 3.3.3.4 测试一对多关联及延迟加载1234@Testpublic void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll();&#125; 3.4 mybatis 基于注解的二级缓存3.4.1 在 SqlMapConfig 中开启二级缓存支持12345&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 3.4.2 在持久层接口中使用注解配置二级缓存1234567/** * * @author wgy */@CacheNamespace(blocking = true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125;","tags":[{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://wgy1993.gitee.io/tags/MyBatis/"}]},{"title":"MyBatis(三)","date":"2020-06-22T04:21:01.000Z","path":"archives/f1b11122.html","text":"1. Mybatis 连接池与事务深入1.1 Mybatis 的连接池技术在 Mybatis 的 SqlMapConfig.xml 配置文件中，通过&lt;dataSource type=&quot;pooled&quot;&gt;来实现 Mybatis 中连接池的配置。 1.1.1 Mybatis 连接池的分类在 Mybatis 中我们将它的数据源 dataSource 分为以下几类： UNPOOLED：不使用连接池的数据源 POOLED：使用连接池的数据源 JNDI：使用 JNDI 实现的数据源 在这三种数据源中，我们一般采用的是 POOLED 数据源（很多时候我们所说的数据源就是为了更好的管理数据库连接，也就是我们所说的连接池技术）。 1.1.2 Mybatis 中数据源的配置1234567&lt;!-- 配置数据源（连接池）信息 --&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; MyBatis 在初始化时，根据&lt;dataSource&gt;的 type 属性来创建相应类型的的数据源 DataSource。 1.1.3 Mybatis 中 DataSource 的存取MyBatis 是通过工厂模式来创建数据源 DataSource 对象的， MyBatis 定义了抽象的工厂接口:org.apache.ibatis.datasource.DataSourceFactory,通过其 getDataSource()方法返回数据源DataSource。 MyBatis 创建了 DataSource 实例后，会将其放到 Configuration 对象内的 Environment 对象中， 供以后使用。 1.1.4 Mybatis 中连接的获取过程分析当我们需要创建 SqlSession 对象并需要执行 SQL 语句时，这时候 MyBatis 才会去调用 dataSource 对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。当我们用完了就再立即将数据库连接归还到连接池中。 1.2 Mybatis 的事务控制1.2.1 JDBC 中事务的回顾在 JDBC 中我们可以将事务的提交改为自动方式，通过 setAutoCommit()方法就可以调整。 1.2.2 Mybatis 中事务提交方式Mybatis 中事务的提交方式，本质上就是调用 JDBC 的 setAutoCommit()来实现事务控制。 123456789101112131415161718192021222324252627282930@Testpublic void testSaveUser() throws Exception &#123; User user = new User(); user.setUsername(\"mybatis user09\"); //6.执行操作 int res = userDao.saveUser(user); System.out.println(res); System.out.println(user.getId());&#125;@Before//在测试方法执行之前执行public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class);&#125;@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; //7.提交事务 session.commit(); //8.释放资源 session.close(); in.close();&#125; 控制台输出的结果： Connection 的整个变化过程，通过分析我们能够发现之前的 CUD 操作过程中，我们都要手动进行事务的提交，原因是 setAutoCommit()方法，在执行时它的值被设置为 false 了，所以我们在 CUD 操作中，必须通过sqlSession.commit()方法来执行提交操作。 1.2.3 Mybatis 自动提交事务的设置12//4.创建 SqlSession 对象session = factory.openSession(true); 所对应的 DefaultSqlSessionFactory 类的源代码： 2. Mybatis 的动态 SQL 语句2.1 &lt;if&gt;标签123456789101112&lt;!-- 根据条件查询 --&gt;&lt;select id=\"findByUser\" resultType=\"user\" parameterType=\"user\"&gt; select * from user where 1=1 &lt;if test=\"username!=null and username != '' \"&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"address != null\"&gt; and address like #&#123;address&#125; &lt;/if&gt;&lt;/select&gt; 2.2 &lt;where&gt;标签为了简化上面 where 1=1 的条件拼装，我们可以采用&lt;where&gt;标签来简化开发。 123456789101112&lt;select id=\"findUserByCondition\" resultMap=\"userMap\" parameterType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"userName != null\"&gt; and username = #&#123;userName&#125; &lt;/if&gt; &lt;if test=\"userSex != null\"&gt; and sex = #&#123;userSex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 2.3 &lt;foreach&gt; 标签2.3.1 需求传入多个 id 查询用户信息，用下边两个 sql 实现： 12SELECT * FROM USERS WHERE username LIKE '%张%' AND (id =10 OR id =89 OR id=16)SELECT * FROM USERS WHERE username LIKE '%张%' AND id IN (10,89,16) 这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。 2.3.2 在 QueryVo 中加入一个 List 集合用于封装参数123456789/** * @author wgy */public class QueryVo &#123; private User user; private List&lt;Integer&gt; ids; ...&#125; 2.3.3 映射配置12345678910111213141516171819202122&lt;!-- 根据queryvo中的Id集合实现查询用户列表 --&gt;&lt;select id=\"findUserInIds\" resultMap=\"userMap\" parameterType=\"queryvo\"&gt; select * from user &lt;where&gt; &lt;if test=\"ids != null and ids.size()&gt;0\"&gt; &lt;foreach collection=\"ids\" open=\"and id in (\" close=\")\" separator=\",\" item=\"uid\"&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;SQL 语句：select 字段 from user where id in (?)&lt;foreach&gt;标签用于遍历集合，它的属性： collection:代表要遍历的集合元素，注意编写时不要写#&#123;&#125; open:代表语句的开始部分 close:代表结束部分 item:代表遍历集合的每个元素，生成的变量名 sperator:代表分隔符 2.4 简化编写的 SQL 片段Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。 2.4.1 定义代码片段12345&lt;!-- 了解的内容：抽取重复的sql语句--&gt;&lt;sql id=\"defaultUser\"&gt; select * from user&lt;/sql&gt; 2.4.2 引用代码片段1234&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userMap\"&gt; &lt;include refid=\"defaultUser\"&gt;&lt;/include&gt;&lt;/select&gt; 3. Mybatis 多表查询之一对多用户为User 表，账户为Account表。一个用户（User）可以有多个账户（Account）。 3.1 一对一查询( 多对一)查询所有账户信息，关联查询下单用户信息。 3.1.1 方式一3.1.1.1 定义账户信息的实体类1234567public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; ...&#125; 3.1.1.2 编写 Sql 语句1234select a.*, u.username, u.addressfrom account a, user uwhere u.id &#x3D; a.uid; 3.1.1.3 定义 AccountUser 类为了能够封装上面 SQL 语句的查询结果，定义 AccountUser 类中要包含账户信息同时还要包含用户信息，所以我们要在定义 AccountUser 类时可以继承 User 类。 123456789/** * @author wgy */public class AccountUser extends Account &#123; private String username; private String address; ...&#125; 3.1.1.4 映射配置1234567&lt;!--查询所有账户同时包含用户名和地址信息--&gt;&lt;select id=\"findAllAccount\" resultType=\"accountuser\"&gt; select a.*, u.username, u.address from account a, user u where u.id = a.uid;&lt;/select&gt; 定义专门的 po 类作为输出类型，其中定义了 sql 查询结果集所有的字段。此方法较为简单，企业中使用普遍。 3.1.2 方式二使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。 通过面向对象的(has a)关系可以得知，我们可以在 Account 类中加入一个 User 类的对象来代表这个账户是哪个用户的。 3.1.2.1 修改 Account 类在 Account 类中加入 User 类的对象作为 Account 类的一个属性。 123456789101112131415/** * 账户实体类 * * @author wgy */public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //从表实体应该包含一个主表实体的对象引用 private User user; ...&#125; 3.1.2.2 映射配置12345678910111213141516171819202122&lt;!-- 定义封装account和user的resultMap --&gt;&lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"aid\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射：配置封装user的内容--&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- 查询所有 --&gt;&lt;select id=\"findAll\" resultMap=\"accountUserMap\"&gt; select u.*, a.id as aid, a.uid, a.money from account a, user u where u.id = a.uid;&lt;/select&gt; 3.2 一对多查询查询所有用户信息及用户关联的账户信息。 3.2.1 编写 SQL 语句123456SELECT u.*, acc.id id, acc.uid, acc.moneyFROM user u LEFT JOIN account acc ON u.id &#x3D; acc.uid 3.2.2 User类加入 List&lt;Account&gt;12345678910111213141516/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //一对多关系映射：主表实体应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; ...&#125; 3.2.3 映射配置12345678910111213141516171819202122232425262728&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=\"userAccountMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"account\"&gt; &lt;id column=\"aid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; select * from user u left outer join account a on u.id = a.uid&lt;/select&gt;collection 部分定义了用户关联的账户信息。表示关联查询结果集property=\"accounts\" ： 关联查询的结果集存储在 User 对象的上哪个属性。ofType=\"account\" ： 指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。 4. Mybatis 多表查询之多对多多对多关系其实是双向的一对多关系。一个用户可以有多个角色，一个角色可以赋予多个用户。 4.1 实现 Role 到 User 多对多实现查询所有角色并且加载它所分配的用户信息。 4.1.1 编写 SQL 语句1234select u.*, r.id as rid, r.role_name, r.role_descfrom role r left outer join user_role ur on r.id &#x3D; ur.rid left outer join user u on u.id &#x3D; ur.uid 4.1.2 编写角色实体类1234567891011121314/** * 角色实体类 * * @author wgy */public class Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; //多对多的关系映射：一个角色可以赋予多个用户 private List&lt;User&gt; users; ...&#125; 4.1.3 映射配置123456789101112131415161718192021&lt;!--定义role表的ResultMap--&gt;&lt;resultMap id=\"roleMap\" type=\"role\"&gt; &lt;id property=\"roleId\" column=\"rid\"&gt;&lt;/id&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;result property=\"roleDesc\" column=\"role_desc\"&gt;&lt;/result&gt; &lt;collection property=\"users\" ofType=\"user\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"roleMap\"&gt; select u.*, r.id as rid, r.role_name, r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid&lt;/select&gt; 4.2 实现 User 到 Role 的多对多4.2.1 编写 SQL 语句1234select u.*, r.id as rid, r.role_name, r.role_descfrom user u left outer join user_role ur on u.id &#x3D; ur.uid left outer join role r on r.id &#x3D; ur.rid 4.2.2 编写用户实体类12345678910111213141516/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //多对多的关系映射：一个用户可以具备多个角色 private List&lt;Role&gt; roles; ...&#125; 4.2.3 映射配置12345678910111213141516171819202122&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=\"userMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!-- 配置角色集合的映射 --&gt; &lt;collection property=\"roles\" ofType=\"role\"&gt; &lt;id property=\"roleId\" column=\"rid\"&gt;&lt;/id&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;result property=\"roleDesc\" column=\"role_desc\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select u.*, r.id as rid, r.role_name, r.role_desc from user u left outer join user_role ur on u.id = ur.uid left outer join role r on r.id = ur.rid&lt;/select&gt; 5. JNDI数据源JNDI：Java Naming and Directory Interface。是SUN公司推出的一套规范，属于JavaEE技术之一。目的是模仿windows系统中的注册表。在服务器中注册数据源 5.1 创建Maven的war工程并导入坐标123456789101112131415161718192021222324252627282930313233343536373839&lt;groupId&gt;com.wgy&lt;/groupId&gt;&lt;artifactId&gt;MyBatis10_JNDI&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 5.2 在webapp文件下创建META-INF目录 5.3 在META-INF目录中建立一个名为context.xml的配置文件1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Context&gt; &lt;!-- &lt;Resource name=\"jdbc/mybatis\" 数据源的名称 type=\"javax.sql.DataSource\" 数据源类型 auth=\"Container\" 数据源提供者 maxActive=\"20\" 最大活动数 maxWait=\"10000\" 最大等待时间 maxIdle=\"5\" 最大空闲数 username=\"root\" 用户名 password=\"root\" 密码 driverClassName=\"com.mysql.jdbc.Driver\" 驱动类 url=\"jdbc:mysql://localhost:3306/mybatis\" 连接url字符串 /&gt; --&gt; &lt;Resource name=\"jdbc/mybatis\" type=\"javax.sql.DataSource\" auth=\"Container\" maxActive=\"20\" maxWait=\"10000\" maxIdle=\"5\" username=\"root\" password=\"root\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/mybatis\" /&gt;&lt;/Context&gt; 5.4 修改SqlMapConfig.xml中的配置1234567891011121314&lt;!--配置环境--&gt;&lt;environments default=\"dev\"&gt; &lt;!-- 配置dev的环境--&gt; &lt;environment id=\"dev\"&gt; &lt;!-- 配置事务控制的方式 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 配置连接数据库的必备信息 type属性表示是否使用数据源（连接池）--&gt; &lt;dataSource type=\"JNDI\"&gt; &lt;property name=\"data_source\" value=\"java:comp/env/jdbc/mybatis\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;java:comp/env/为固定写法，后面为context.xml中设置的数据源的名称jdbc/mybatis","tags":[{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://wgy1993.gitee.io/tags/MyBatis/"}]},{"title":"MyBatis(二)","date":"2020-06-21T14:11:23.000Z","path":"archives/8f423109.html","text":"1. 基于代理 Dao 实现 CRUD 操作使用要求： 持久层接口和持久层接口的映射配置必须在相同的包下 持久层映射配置中 mapper 标签的 namespace 属性取值必须是持久层接口的全限定类名 SQL 语句的配置标签&lt;select&gt;,&lt;insert&gt;,&lt;delete&gt;,&lt;update&gt;的 id 属性必须和持久层接口的方法名相同。 1.1 根据 ID 查询1.1.1 在持久层接口中添加查询方法1234567/** * 根据id查询用户信息 * * @param userId * @return */User findById(Integer userId); 1.1.2 在用户的映射配置文件中配置123456&lt;!-- 根据id查询用户 --&gt;&lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.wgy.domain.User\"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt; 细节： resultType 属性： 用于指定结果集的类型。 parameterType 属性： 用于指定传入参数的类型。 sql 语句中使用#{} 字符 ： 它代表占位符，相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。 具体的数据是由#{}里面的内容决定的。 #{} 中内容的写法： 由于数据类型是基本类型，所以此处可以随意写。 1.1.3 在测试类添加测试12345678910111213141516171819202122232425262728293031323334353637383940/** * 测试mybatis的crud操作 * * @author wgy */public class MyBatisTest &#123; private InputStream in; private SqlSession sqlSession; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(); //4.获取dao的代理对象 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy() throws Exception &#123; //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询一个操作 */ @Test public void testFindOne() &#123; //5.执行查询一个方法 User user = userDao.findById(49); System.out.println(user); &#125;&#125; 1.2 保存操作1.2.1 在持久层接口中添加新增方法123456/** * 保存用户 * * @param user */void saveUser(User user); 1.2.2 在用户的映射配置文件中配置12345&lt;!-- 保存用户 --&gt;&lt;insert id=\"saveUser\" parameterType=\"com.wgy.domain.User\"&gt; insert into user(username, address, sex, birthday) values (#&#123;userName&#125;, #&#123;userAddress&#125;, #&#123;userSex&#125;, #&#123;userBirthday&#125;);&lt;/insert&gt; 细节： parameterType 属性： 代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。 sql 语句中使用#{}字符： 它代表占位符，相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。 具体的数据是由#{}里面的内容决定的。 #{}中内容的写法： 由于我们保存方法的参数是 一个 User 对象，此处要写 User 对象中的属性名称。 它用的是 ognl 表达式。 ognl 表达式： 它是 apache 提供的一种表达式语言，全称是：Object Graphic Navigation Language 对象图导航语言 它是按照一定的语法格式来获取数据的。 语法格式就是使用 #{对象.对象}的方式 #{user.username}它会先去找 user 对象，然后在 user 对象中找到 username 属性，并调用getUsername()方法把值取出来。但是我们在 parameterType 属性上指定了实体类名称，所以可以省略 user.而直接写 username。 1.2.3 在测试类添加测试12345678910111213141516/** * 测试保存操作 */@Testpublic void testSave() &#123; User user = new User(); user.setUserName(\"insert User property\"); user.setUserAddress(\"北京市顺义区\"); user.setUserSex(\"男\"); user.setUserBirthday(new Date()); System.out.println(\"保存操作之前：\" + user); //5.执行保存方法 userDao.saveUser(user); System.out.println(\"保存操作之后：\" + user);&#125; 打开 Mysql 数据库发现并没有添加任何记录，原因是什么？ 这一点和 jdbc 是一样的，我们在实现增删改时一定要去控制事务的提交，那么在 mybatis 中如何控制事务提交呢？ 可以使用:session.commit();来实现事务提交。加入事务提交后的代码如下： 12345678@After//用于在测试方法执行之后执行public void destroy() throws Exception &#123; //提交事务 sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close();&#125; 1.2.4 问题扩展：新增用户 id 的返回值新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。 123456789&lt;!-- 保存用户 --&gt;&lt;insert id=\"saveUser\" parameterType=\"com.wgy.domain.User\"&gt; &lt;!-- 配置插入操作后，获取插入数据的id --&gt; &lt;selectKey keyProperty=\"userId\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username, address, sex, birthday) values (#&#123;userName&#125;, #&#123;userAddress&#125;, #&#123;userSex&#125;, #&#123;userBirthday&#125;);&lt;/insert&gt; 1.3 用户更新1.3.1 在持久层接口中添加更新方法123456/** * 更新用户 * * @param user */void updateUser(User user); 1.3.2 在用户的映射配置文件中配置123456789&lt;!-- 更新用户 --&gt;&lt;update id=\"updateUser\" parameterType=\"com.wgy.domain.User\"&gt; update user set username=#&#123;userName&#125;, address=#&#123;userAddress&#125;, sex=#&#123;userSex&#125;, birthday=#&#123;userBirthday&#125; where id = #&#123;userId&#125;&lt;/update&gt; 1.3.3 在测试类添加测试123456789101112131415/** * 测试更新操作 */@Testpublic void testUpdate() &#123; User user = new User(); user.setUserId(49); user.setUserName(\"mybastis update user\"); user.setUserAddress(\"北京市顺义区\"); user.setUserSex(\"女\"); user.setUserBirthday(new Date()); //5.执行保存方法 userDao.updateUser(user);&#125; 1.4 用户删除1.4.1 在持久层接口中添加删除方法123456/** * 根据Id删除用户 * * @param userId */void deleteUser(Integer userId); 1.4.2 在用户的映射配置文件中配置123456&lt;!-- 删除用户--&gt;&lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id = #&#123;uid&#125;&lt;/delete&gt; 1.4.3 在测试类添加测试12345678/** * 测试删除操作 */@Testpublic void testDelete() &#123; //5.执行删除方法 userDao.deleteUser(48);&#125; 1.5 用户模糊查询1.5.1 在持久层接口中添加模糊查询方法1234567/** * 根据名称模糊查询用户信息 * * @param username * @return */List&lt;User&gt; findByName(String username); 1.5.2 在用户的映射配置文件中配置123456&lt;!-- 根据名称模糊查询 --&gt;&lt;select id=\"findByName\" parameterType=\"string\" resultType=\"com.wgy.domain.User\"&gt; select * from user where username like #&#123;name&#125;&lt;/select&gt; 1.5.3 在测试类添加测试1234567891011/** * 测试模糊查询操作 */@Testpublic void testFindByName() &#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName(\"%王%\"); for (User user : users) &#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 我们在配置文件中没有加入%来作为模糊查询的条件，所以在传入字符串实参时，就需要给定模糊查询的标识%。配置文件中的#{username}也只是一个占位符，所以 SQL 语句显示为“？”。 1.5.4 模糊查询的另一种配置方式第一步：修改 SQL 语句的配置，配置如下： 123456&lt;!-- 根据名称模糊查询 --&gt;&lt;select id=\"findByName\" parameterType=\"string\" resultType=\"com.wgy.domain.User\"&gt; select * from user where username like '%$&#123;value&#125;%'&lt;/select&gt; 我们在上面将原来的#{}占位符，改成了${value}。注意如果用模糊查询的这种写法，那么${value}的写法就是固定的，不能写成其它名字。 第二步：测试，如下： 1234567891011/** * 测试模糊查询操作 */@Testpublic void testFindByName() &#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName(\"王\"); for (User user : users) &#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 可以发现，我们在程序代码中就不需要加入模糊查询的匹配符%了，这两种方式的实现效果是一样的，但执行的语句是不一样的。 1.5.5 #{} 与${} 的区别 #{} 表示一个占位符号 通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。 ${} 表示拼接 sql 串 通过${}可以将 parameterType 传入的内容拼接在 sql中且不进行 jdbc 类型转换， ${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。 1.5.6 模糊查询的${value} 源码分析 这就说明了源码中指定了读取的 key 的名字就是”value”，所以我们在绑定参数时就只能叫 value 的名字了。 1.6 查询使用聚合函数1.6.1 在持久层接口中添加聚合函数查询方法123456/** * 查询总用户数 * * @return */int findTotal(); 1.6.2 在用户的映射配置文件中配置12345&lt;!-- 获取用户的总记录条数 --&gt;&lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(id) from user;&lt;/select&gt; 1.6.3 在测试类添加测试123456789/** * 测试查询总记录条数 */@Testpublic void testFindTotal() &#123; //5.执行查询一个方法 int count = userDao.findTotal(); System.out.println(count);&#125; 2. Mybatis 的参数深入2.1 parameterType 配置参数2.1.1 使用说明 SQL 语句传参，使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类 2.1.2 注意事项基本类 型和 String 我们可以直接写类型名称 ，也可以使用包名 . 类名的方式 ，例如 ：java.lang.String。实体类类型，目前我们只能使用全限定类名。 2.2 传递 pojo 包装对象开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。Pojo 类中包含 pojo。 需求：根据用户名查询用户信息，查询条件放到 QueryVo 的 user 属性中。 2.2.1 编写 QueryVo123456789101112131415/** * @author wgy */public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 2.2.2 在持久层接口中添加查询方法123456/** * 根据queryVo中的条件查询用户 * @param vo * @return */List&lt;User&gt; findUserByVo(QueryVo vo); 2.2.3 在用户的映射配置文件中配置123456&lt;!-- 根据queryVo的条件查询用户 --&gt;&lt;select id=\"findUserByVo\" parameterType=\"com.wgy.domain.QueryVo\" resultType=\"com.wgy.domain.User\"&gt; select * from user where username like #&#123;user.userName&#125;&lt;/select&gt; 2.2.4 在测试类添加测试123456789101112131415/** * 测试使用QueryVo作为查询条件 */@Testpublic void testFindByVo() &#123; QueryVo vo = new QueryVo(); User user = new User(); user.setUserName(\"%王%\"); vo.setUser(user); //5.执行查询一个方法 List&lt;User&gt; users = userDao.findUserByVo(vo); for (User u : users) &#123; System.out.println(u); &#125;&#125; 3. Mybatis 的输出结果封装3.1 resultType 配置结果类型resultType 属性可以指定结果集的类型，它支持基本类型和实体类类型。 它和 parameterType 一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。 3.1.1 基本类型示例案例1.6 3.1.2 实体类类型示例案例1.1 3.1.3 特殊情况示例3.1.3.1 修改实体类实体类属性和数据库表的列名已经不一致 3.1.3.2 修改映射配置使用别名查询 12345&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultType=\"com.wgy.domain.User\"&gt; select id as userId, username as userName, address as userAddress, sex as userSex, birthday as userBirthday from user;&lt;/select&gt; 3.2 resultMap 结果类型resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 3.2.1 定义 resultMap12345678910111213141516&lt;!-- 建立 User 实体和数据库表的对应关系 type 属性：指定实体类的全限定类名 id 属性：给定一个唯一标识，是给查询 select 标签引用用的。--&gt;&lt;resultMap type&#x3D;&quot;com.wgy.domain.User&quot; id&#x3D;&quot;userMap&quot;&gt; &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;userId&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;username&quot; property&#x3D;&quot;userName&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;sex&quot; property&#x3D;&quot;userSex&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;address&quot; property&#x3D;&quot;userAddress&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;birthday&quot; property&#x3D;&quot;userBirthday&quot;&#x2F;&gt;&lt;&#x2F;resultMap&gt;id 标签：用于指定主键字段result 标签：用于指定非主键字段column 属性：用于指定数据库列名property 属性：用于指定实体类属性名称 3.2.2 映射配置12345&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select * from user&lt;/select&gt; 4. Mybatis 传统 DAO 层开发使用 Mybatis 开发 Dao，通常有两个方法，即原始 Dao开发方式和 Mapper 接口代理开发方式。而现在主流的开发方式是接口代理开发方式，这种方式总体上更加简便。 4.1 Mybatis 实现 DAO 的传统开发方式4.1.1 持久层 Dao 接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ List&lt;User&gt; findAll(); /** * 保存用户 * * @param user */ void saveUser(User user); /** * 更新用户 * * @param user */ void updateUser(User user); /** * 根据Id删除用户 * * @param userId */ void deleteUser(Integer userId); /** * 根据id查询用户信息 * * @param userId * @return */ User findById(Integer userId); /** * 根据名称模糊查询用户信息 * * @param username * @return */ List&lt;User&gt; findByName(String username); /** * 查询总用户数 * * @return */ int findTotal();&#125; 4.1.2 持久层 Dao 实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 持久层实现类 * * @author wgy */public class UserDaoImpl implements IUserDao &#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; public List&lt;User&gt; findAll() &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用SqlSession中的方法，实现查询列表 //参数就是能获取配置信息的key List&lt;User&gt; users = session.selectList(\"com.wgy.dao.IUserDao.findAll\"); //3.释放资源 session.close(); return users; &#125; public void saveUser(User user) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用方法实现保存 session.insert(\"com.wgy.dao.IUserDao.saveUser\", user); //3.提交事务 session.commit(); //4.释放资源 session.close(); &#125; public void updateUser(User user) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用方法实现更新 session.update(\"com.wgy.dao.IUserDao.updateUser\", user); //3.提交事务 session.commit(); //4.释放资源 session.close(); &#125; public void deleteUser(Integer userId) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用方法实现更新 session.update(\"com.wgy.dao.IUserDao.deleteUser\", userId); //3.提交事务 session.commit(); //4.释放资源 session.close(); &#125; public User findById(Integer userId) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用SqlSession中的方法，实现查询一个 User user = session.selectOne(\"com.wgy.dao.IUserDao.findById\", userId); //3.释放资源 session.close(); return user; &#125; public List&lt;User&gt; findByName(String username) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用SqlSession中的方法，实现查询列表 List&lt;User&gt; users = session.selectList(\"com.wgy.dao.IUserDao.findByName\", username); //3.释放资源 session.close(); return users; &#125; public int findTotal() &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用SqlSession中的方法，实现查询一个 Integer count = session.selectOne(\"com.wgy.dao.IUserDao.findTotal\"); //3.释放资源 session.close(); return count; &#125;&#125; 4.1.3 持久层映射配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultType=\"com.wgy.domain.User\"&gt; select * from user &lt;/select&gt; &lt;!-- 保存用户 --&gt; &lt;insert id=\"saveUser\" parameterType=\"com.wgy.domain.User\"&gt; &lt;!-- 配置插入操作后，获取插入数据的id --&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username, address, sex, birthday) values (#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;); &lt;/insert&gt; &lt;!-- 更新用户 --&gt; &lt;update id=\"updateUser\" parameterType=\"com.wgy.domain.User\"&gt; update user set username=#&#123;username&#125;, address=#&#123;address&#125;, sex=#&#123;sex&#125;, birthday=#&#123;birthday&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除用户--&gt; &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id = #&#123;uid&#125; &lt;/delete&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.wgy.domain.User\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt; &lt;!-- 根据名称模糊查询 --&gt; &lt;select id=\"findByName\" parameterType=\"string\" resultType=\"com.wgy.domain.User\"&gt; select * from user where username like #&#123;name&#125; &lt;/select&gt; &lt;!-- 获取用户的总记录条数 --&gt; &lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(id) from user; &lt;/select&gt;&lt;/mapper&gt; 4.1.4 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 测试mybatis的crud操作 * * @author wgy */public class MyBatisTest &#123; private InputStream in; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.使用工厂对象，创建dao对象 userDao = new UserDaoImpl(factory); &#125; @After//用于在测试方法执行之后执行 public void destroy() throws Exception &#123; //6.释放资源 in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll() &#123; //5.执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试保存操作 */ @Test public void testSave() &#123; User user = new User(); user.setUsername(\"dao impl user\"); user.setAddress(\"北京市顺义区\"); user.setSex(\"男\"); user.setBirthday(new Date()); System.out.println(\"保存操作之前：\" + user); //5.执行保存方法 userDao.saveUser(user); System.out.println(\"保存操作之后：\" + user); &#125; /** * 测试更新操作 */ @Test public void testUpdate() &#123; User user = new User(); user.setId(50); user.setUsername(\"userdaoimpl update user\"); user.setAddress(\"北京市顺义区\"); user.setSex(\"女\"); user.setBirthday(new Date()); //5.执行保存方法 userDao.updateUser(user); &#125; /** * 测试删除操作 */ @Test public void testDelete() &#123; //5.执行删除方法 userDao.deleteUser(54); &#125; /** * 测试删除操作 */ @Test public void testFindOne() &#123; //5.执行查询一个方法 User user = userDao.findById(50); System.out.println(user); &#125; /** * 测试模糊查询操作 */ @Test public void testFindByName() &#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName(\"%王%\"); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试查询总记录条数 */ @Test public void testFindTotal() &#123; //5.执行查询一个方法 int count = userDao.findTotal(); System.out.println(count); &#125;&#125; 5. SqlMapConfig.xml 配置文件5.1 配置内容5.1.1 SqlMapConfig.xml 中配置的内容和顺序1234567891011121314151617-properties （属性） --property-settings（全局配置参数） --setting-typeAliases （类型别名） --typeAliase --package-typeHandlers（类型处理器）-objectFactory（对象工厂）-plugins（插件）-environments（环境集合属性对象） --environment（环境子属性对象） ---transactionManager（事务管理） ---dataSource（数据源）-mappers （映射器） --mapper --package 5.2 properties（属性）在使用 properties 标签配置时，我们可以采用两种方式指定属性配置。 5.2.1 第一种123456&lt;properties&gt; &lt;property name=\"jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbc.url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"jdbc.username\" value=\"root\"/&gt; &lt;property name=\"jdbc.password\" value=\"root\"/&gt;&lt;/properties&gt; 5.2.2 第二种5.2.2.1 在 classpath 下定义 db.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root 5.2.2.2 properties 标签配置12345678910111213141516&lt;!-- 配置properties 可以在标签内部配置连接数据库的信息。也可以通过属性引用外部配置文件信息 resource属性： 常用的 用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于类路径下。 resource=\"db.properties\" url属性： 是要求按照Url的写法来写地址 URL：Uniform Resource Locator 统一资源定位符。它是可以唯一标识一个资源的位置。 它的写法： http://localhost:8080/mybatisserver/demo1Servlet 协议 主机 端口 URI URI:Uniform Resource Identifier 统一资源标识符。它是在应用中可以唯一定位一个资源的。--&gt;&lt;properties url=\"file:///E:\\MyIDEAWorkSpace\\MyBatis\\MyBatis05_CRUD\\src\\main\\resources\\db.properties\"&gt;&lt;/properties&gt; 5.2.3 dataSource 标签引用配置1234567&lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt;&lt;/dataSource&gt; 5.3 typeAliases（类型别名）除了前面 Mybatis 支持的默认别名，也可以采用自定义别名方式来开发。 5.3.1 自定义别名在 SqlMapConfig.xml 中配置： 123456&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=\"user\" type=\"com.wgy.domain.User\"/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &lt;package name=\"com.wgy.domain\"/&gt;&lt;/typeAliases&gt; 5.4 mappers（映射器）5.4.1 &lt;mapper resource=&quot; &quot; /&gt;12使用相对于类路径的资源如：&lt;mapper resource=\"com/wgy/dao/IUserDao.xml\" /&gt; 5.4.2 &lt;mapper class=&quot; &quot; /&gt;123使用 mapper 接口类路径如：&lt;mapper class=\"com.wgy.dao.UserDao\"/&gt;注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 5.4.3 &lt;package name=&quot;&quot;/&gt;123注册指定包下的所有 mapper 接口如：&lt;package name=\"com.wgy.dao\"/&gt;注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。","tags":[{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://wgy1993.gitee.io/tags/MyBatis/"}]},{"title":"MyBatis(一)","date":"2020-06-20T07:25:51.000Z","path":"archives/2073aa6b.html","text":"1. 单独使用jdbc编程问题总结1.1 jdbc编程步骤 加载数据库驱动 创建并获取数据库链接 创建jdbc statement对象 设置sql语句 设置sql语句中的参数(使用preparedStatement) 通过statement执行sql并获取结果 对sql执行结果进行解析处理 释放资源(resultSet、preparedstatement、connection) 1.2 jdbc程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; //加载数据库驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //通过驱动管理类获取数据库链接 connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\", \"root\", \"root\"); //定义sql语句 ?表示占位符 String sql = \"select * from user where username = ?\"; //获取预处理statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, \"王五\"); //向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next())&#123; System.out.println(resultSet.getString(\"id\")+\" \"+resultSet.getString(\"username\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //释放资源 if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(preparedStatement!=null)&#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上边使用jdbc的原始方法（未经封装）实现了查询数据库表记录的操作。 1.3 jdbc问题总结如下1、数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。 设想：使用数据库连接池管理数据库连接。 2、将sql语句硬编码到java代码中，如果sql 语句修改，需要重新编译java代码，不利于系统维护。 设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。 3、向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。 设想：将sql语句及占位符号和参数全部配置在xml中。 4、从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，，不利于系统维护。 设想：将查询的结果集，自动映射成java对象。 2. MyBatis框架2.1 MyBatis是什么？mybatis是一个持久层的框架，它对jdbc的操作数据库的过程进行封装，不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。是apache下的顶级项目。 mybatis托管到goolecode下，再后来托管到github下(https://github.com/mybatis/mybatis-3/releases)。 mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。 mybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射） 2.2 MyBatis框架 2.3 与hibernate不同Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 2.4 Mybatis与iBatis的主要差异对比他们都是优秀的持久层框架，MyBatis是现在最常用的持久层框架，可以动态地拼接sql语句，非常人性化，更适合编辑复杂的sql；iBatis就是MyBatis前身，他们有很多相似的地方 1、传入参数 iBatis是parameterClass，而MyBatis是可以不写的，也可以用parameterType,parameterClass iBatis的传出参数关键字是resultClass，而MyBatis是resultMap 2、判断语句 对于MyBatis的很简单，只要在where或者if标签里面添加test=“”就可以了，里面写判断条件。 但是iBatis的就麻烦了许多了，它将每个方法都进行了封装。例如isNull：判断字段是否为null 3、循环的使用 iBatis是使用Iterate，而MyBatis使用的是ForEach方法 4、MyBatis实现了DAO接口与xml映射文件的绑定，使用更加方便 3. MyBatis 框架快速入门3.1 Mybatis 框架开发的准备3.1.1 官网下载 Mybatis 框架从百度中“mybatis download”可以下载最新的 Mybatis 开发包。https://mybatis.org/mybatis-3/ 进入选择语言的界面，进入中文版本的开发文档。 下载相关的 jar 包或 maven 开发的坐标。 3.2 搭建 Mybatis 开发环境3.2.1 创建 maven 工程创建 MyBatis01 的工程，工程信息如下： 1234&lt;groupId&gt;com.wgy&lt;/groupId&gt;&lt;artifactId&gt;MyBatis01&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 3.2.2 添加 Mybatis3.4.5 的坐标在 pom.xml 文件中添加 Mybatis3.4.5 的坐标，如下： 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2.3 log4j.properties123456789log4j.rootLogger=DEBUG,consolelog4j.additivity.org.apache=true# 控制台(console)log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.ImmediateFlush=truelog4j.appender.console.Target=System.outlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n 3.2.4 编写 User 实体类1234567891011121314/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; ...&#125; 3.2.5 编写持久层口接口 IUserDao1234567891011121314/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ List&lt;User&gt; findAll();&#125; 3.2.6 编写持久层接口的件映射文件 IUserDao.xml创建位置：必须和持久层接口在相同的包中。名称：必须以持久层接口名称命名文件名，扩展名是.xml 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.wgy.dao.IUserDao&quot;&gt; &lt;!--配置查询所有--&gt; &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;com.wgy.domain.User&quot;&gt; select * from user &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; 3.2.7 编写 SqlMapConfig.xml12345678910111213141516171819202122232425262728&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default&#x3D;&quot;dev&quot;&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id&#x3D;&quot;dev&quot;&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;com&#x2F;wgy&#x2F;dao&#x2F;IUserDao.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; 3.2.8 编写测试类1234567891011121314151617181920212223242526272829303132/** * mybatis的入门案例 * * @author wgy */public class MyBatisTest &#123; /** * 入门案例 * * @param args */ public static void main(String[] args) throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 3.3 基于注解的 mybatis 使用3.3.1 在持久层接口中添加注解123456789101112131415/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 3.3.2 修改 SqlMapConfig.xml123456&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名--&gt;&lt;mappers&gt; &lt;mapper class&#x3D;&quot;com.wgy.dao.IUserDao&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt; 注意事项：在使用基于注解的 Mybatis 配置时，请移除 xml 的映射配置（IUserDao.xml） 。 4. 自定义 Mybatis 框架4.1 自定义 Mybatis 框架的分析4.1.1 涉及知识点介绍构建一个属于自己的持久层框架，将会涉及到的一些知识点：工厂模式（Factory 工厂模式） 、构造者模式（Builder 模式）、代理模式，反射，自定义注解，注解的反射，xml 解析，数据库元数据，元数据的反射等。 4.1.2 分析流程 4.2 前期准备4.2.1 创建 Maven 工程创建 MyBatis04_Design 的工程，工程信息如下： 1234&lt;groupId&gt;com.wgy&lt;/groupId&gt;&lt;artifactId&gt;MyBatis04_Design&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 4.2.2 引入相关坐标12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- mysql 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 解析 xml 的 dom4j --&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dom4j 的依赖包 jaxen --&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.2.3 引入 工具类到项目中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/** * 用于解析配置文件 * * @author wgy */public class XMLConfigBuilder &#123; /** * 解析主配置文件，把里面的内容填充到DefaultSqlSession所需要的地方 * 使用的技术： * dom4j+xpath */ public static Configuration loadConfiguration(InputStream config) &#123; try &#123; //定义封装连接信息的配置对象（mybatis的配置对象） Configuration cfg = new Configuration(); //1.获取SAXReader对象 SAXReader reader = new SAXReader(); //2.根据字节输入流获取Document对象 Document document = reader.read(config); //3.获取根节点 Element root = document.getRootElement(); //4.使用xpath中选择指定节点的方式，获取所有property节点 List&lt;Element&gt; propertyElements = root.selectNodes(\"//property\"); //5.遍历节点 for (Element propertyElement : propertyElements) &#123; //判断节点是连接数据库的哪部分信息 //取出name属性的值 String name = propertyElement.attributeValue(\"name\"); if (\"driver\".equals(name)) &#123; //表示驱动 //获取property标签value属性的值 String driver = propertyElement.attributeValue(\"value\"); cfg.setDriver(driver); &#125; if (\"url\".equals(name)) &#123; //表示连接字符串 //获取property标签value属性的值 String url = propertyElement.attributeValue(\"value\"); cfg.setUrl(url); &#125; if (\"username\".equals(name)) &#123; //表示用户名 //获取property标签value属性的值 String username = propertyElement.attributeValue(\"value\"); cfg.setUsername(username); &#125; if (\"password\".equals(name)) &#123; //表示密码 //获取property标签value属性的值 String password = propertyElement.attributeValue(\"value\"); cfg.setPassword(password); &#125; &#125; //取出mappers中的所有mapper标签，判断他们使用了resource还是class属性 List&lt;Element&gt; mapperElements = root.selectNodes(\"//mappers/mapper\"); //遍历集合 for (Element mapperElement : mapperElements) &#123; //判断mapperElement使用的是哪个属性 Attribute attribute = mapperElement.attribute(\"resource\"); if (attribute != null) &#123; System.out.println(\"使用的是XML\"); //表示有resource属性，用的是XML //取出属性的值 //获取属性的值\"com/wgy/dao/IUserDao.xml\" String mapperPath = attribute.getValue(); //把映射配置文件的内容获取出来，封装成一个map Map&lt;String, Mapper&gt; mappers = loadMapperConfiguration(mapperPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125; else &#123; System.out.println(\"使用的是注解\"); //表示没有resource属性，用的是注解 //获取class属性的值 String daoClassPath = mapperElement.attributeValue(\"class\"); //根据daoClassPath获取封装的必要信息 Map&lt;String, Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125; &#125; //返回Configuration return cfg; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; config.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据传入的参数，解析XML，并且封装到Map中 * * @param mapperPath 映射配置文件的位置 * @return map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成） * 以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名） */ private static Map&lt;String, Mapper&gt; loadMapperConfiguration(String mapperPath) throws IOException &#123; InputStream in = null; try &#123; //定义返回值对象 Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); //2.根据字节输入流获取Document对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); //3.获取根节点 Element root = document.getRootElement(); //4.获取根节点的namespace属性取值 //是组成map中key的部分 String namespace = root.attributeValue(\"namespace\"); //5.获取所有的select节点 List&lt;Element&gt; selectElements = root.selectNodes(\"//select\"); //6.遍历select节点集合 for (Element selectElement : selectElements) &#123; //取出id属性的值 组成map中key的部分 String id = selectElement.attributeValue(\"id\"); //取出resultType属性的值 组成map中value的部分 String resultType = selectElement.attributeValue(\"resultType\"); //取出文本内容 组成map中value的部分 String queryString = selectElement.getText(); //创建Key String key = namespace + \".\" + id; //创建Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); //把key和value存入mappers中 mappers.put(key, mapper); &#125; return mappers; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; in.close(); &#125; &#125; /** * 根据传入的参数，得到dao中所有被select注解标注的方法。 * 根据方法名称和类名，以及方法上注解value属性的值，组成Mapper的必要信息 * * @param daoClassPath * @return */ private static Map&lt;String, Mapper&gt; loadMapperAnnotation(String daoClassPath) throws Exception &#123; //定义返回值对象 Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到dao接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到dao接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历Method数组 for (Method method : methods) &#123; //取出每一个方法，判断是否有select注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if (isAnnotated) &#123; //创建Mapper对象 Mapper mapper = new Mapper(); //取出注解的value属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 //List&lt;User&gt; Type type = method.getGenericReturnType(); //判断type是不是参数化的类型 if (type instanceof ParameterizedType) &#123; //强转 ParameterizedType ptype = (ParameterizedType) type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class) types[0]; //获取domainClass的类名 String resultType = domainClass.getName(); //给Mapper赋值 mapper.setResultType(resultType); &#125; //组装key的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className + \".\" + methodName; //给map赋值 mappers.put(key, mapper); &#125; &#125; return mappers; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 责执行SQL语句，并且封装结果集 * * @author wgy */public class Executor &#123; public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) &#123; PreparedStatement pstm = null; ResultSet rs = null; try &#123; //1.取出mapper中的数据 //select * from user String queryString = mapper.getQueryString(); //com.wgy.domain.User String resultType = mapper.getResultType(); Class domainClass = Class.forName(resultType); //2.获取PreparedStatement对象 pstm = conn.prepareStatement(queryString); //3.执行SQL语句，获取结果集 rs = pstm.executeQuery(); //4.封装结果集 //定义返回值 List&lt;E&gt; list = new ArrayList&lt;E&gt;(); while (rs.next()) &#123; //实例化要封装的实体类对象 E obj = (E) domainClass.newInstance(); //取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); //取出总列数 int columnCount = rsmd.getColumnCount(); //遍历总列数 for (int i = 1; i &lt;= columnCount; i++) &#123; //获取每列的名称，列名的序号是从1开始的 String columnName = rsmd.getColumnName(i); //根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); //给obj赋值：使用Java内省机制（借助PropertyDescriptor实现属性的封装） //要求：实体类的属性和数据库表的列名保持一种 PropertyDescriptor pd = new PropertyDescriptor(columnName, domainClass); //获取它的写入方法 Method writeMethod = pd.getWriteMethod(); //把获取的列的值，给对象赋值 writeMethod.invoke(obj, columnValue); &#125; //把赋好值的对象加入到集合中 list.add(obj); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; release(pstm, rs); &#125; &#125; private void release(PreparedStatement pstm, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (pstm != null) &#123; try &#123; pstm.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122/** * 用于创建数据源的工具类 * * @author wgy */public class DataSourceUtil &#123; /** * 用于获取一个连接 * * @param cfg * @return */ public static Connection getConnection(Configuration cfg) &#123; try &#123; Class.forName(cfg.getDriver()); return DriverManager.getConnection(cfg.getUrl(), cfg.getUsername(), cfg.getPassword()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 4.2.4 编写 SqlMapConfig.xml12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/wgy/dao/IUserDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意：此处我们直接使用的是 mybatis 的配置文件，但是由于我们没有使用 mybatis 的 jar 包，所以要把配置文件的约束删掉否则会报错（如果电脑能接入互联网，不删也行） 4.2.5 编写读取配置文件类1234567891011121314151617/** * 使用类加载器读取配置文件的类 * * @author wgy */public class Resources &#123; /** * 根据传入的参数，获取一个字节输入流 * * @param filePath * @return */ public static InputStream getResourceAsStream(String filePath) &#123; return Resources.class.getClassLoader().getResourceAsStream(filePath); &#125;&#125; 4.2.6 编写 Mapper 类12345678910111213141516171819202122232425262728/** * 用于封装执行的SQL语句和结果类型的全限定类名 * * @author wgy */public class Mapper &#123; //SQL private String queryString; //实体类的全限定类名 private String resultType; public String getQueryString() &#123; return queryString; &#125; public void setQueryString(String queryString) &#123; this.queryString = queryString; &#125; public String getResultType() &#123; return resultType; &#125; public void setResultType(String resultType) &#123; this.resultType = resultType; &#125;&#125; 4.2.7 编写 Configuration 配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 自定义mybatis的配置类 * * @author wgy */public class Configuration &#123; private String driver; private String url; private String username; private String password; private Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); public String getDriver() &#123; return driver; &#125; public void setDriver(String driver) &#123; this.driver = driver; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Map&lt;String, Mapper&gt; getMappers() &#123; return mappers; &#125; public void setMappers(Map&lt;String, Mapper&gt; mappers) &#123; //此处需要使用追加的方式 this.mappers.putAll(mappers); &#125;&#125; 4.2.8 编写 User 实体类1234567891011121314/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; ...&#125; 4.3 基于 XML 的自定义 mybatis 框架4.3.1 编写持久层接口和 IUserDao.xml1234567891011121314/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ List&lt;User&gt; findAll();&#125; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultType=\"com.wgy.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 注意：此处我们使用的也是 mybatis 的配置文件，所以也要把约束删除了 4.3.2 编写构建者类123456789101112131415161718/** * 用于创建一个SqlSessionFactory对象 * * @author wgy */public class SqlSessionFactoryBuilder &#123; /** * 根据参数的字节输入流来构建一个SqlSessionFactory工厂 * * @param config * @return */ public SqlSessionFactory build(InputStream config) &#123; Configuration cfg = XMLConfigBuilder.loadConfiguration(config); return new DefaultSqlSessionFactory(cfg); &#125;&#125; 4.3.3 编写 SqlSessionFactory 接口和实现类123456789101112/** * @author wgy */public interface SqlSessionFactory &#123; /** * 用于打开一个新的SqlSession对象 * * @return */ SqlSession openSession();&#125; 12345678910111213141516171819202122/** * SqlSessionFactory接口的实现类 * * @author wgy */public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; private Configuration cfg; public DefaultSqlSessionFactory(Configuration cfg) &#123; this.cfg = cfg; &#125; /** * 用于创建一个新的操作数据库对象 * * @return */ public SqlSession openSession() &#123; return new DefaultSqlSession(cfg); &#125;&#125; 4.3.4 编写 SqlSession 接口和实现类12345678910111213141516171819202122/** * 自定义Mybatis中和数据库交互的核心类 * 它里面可以创建dao接口的代理对象 * * @author wgy */public interface SqlSession &#123; /** * 根据参数创建一个代理对象 * * @param daoInterfaceClass dao的接口字节码 * @param &lt;T&gt; * @return */ &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterfaceClass); /** * 释放资源 */ void close();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * SqlSession接口的实现类 * * @author wgy */public class DefaultSqlSession implements SqlSession &#123; private Configuration cfg; private Connection connection; public DefaultSqlSession(Configuration cfg) &#123; this.cfg = cfg; connection = DataSourceUtil.getConnection(cfg); &#125; /** * 用于创建代理对象 * * @param daoInterfaceClass dao的接口字节码 * @param &lt;T&gt; * @return */ public &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterfaceClass) &#123; return (T) Proxy.newProxyInstance(daoInterfaceClass.getClassLoader(), new Class[]&#123;daoInterfaceClass&#125;, new MapperProxy(cfg.getMappers(), connection)); &#125; /** * 用于释放资源 */ public void close() &#123; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4.3.5 编写用于创建 Dao 接口代理对象的类123456789101112131415161718192021222324252627282930313233343536373839404142/** * 代理实现类 * * @author wgy */public class MapperProxy implements InvocationHandler &#123; //map的key是全限定类名+方法名 private Map&lt;String, Mapper&gt; mappers; private Connection conn; public MapperProxy(Map&lt;String, Mapper&gt; mappers, Connection conn) &#123; this.mappers = mappers; this.conn = conn; &#125; /** * 用于对方法进行增强的，我们的增强其实就是调用selectList方法 * * @param proxy * @param method * @param args * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //1.获取方法名 String methodName = method.getName(); //2.获取方法所在类的名称 String className = method.getDeclaringClass().getName(); //3.组合key String key = className + \".\" + methodName; //4.获取mappers中的Mapper对象 Mapper mapper = mappers.get(key); //5.判断是否有mapper if (mapper == null) &#123; throw new IllegalArgumentException(\"传入的参数有误\"); &#125; //6.调用工具类执行查询所有 return new Executor().selectList(mapper, conn); &#125;&#125; 4.3.6 运行测试类1234567891011121314151617181920212223242526272829303132/** * mybatis的入门案例 * * @author wgy */public class MyBatisTest &#123; /** * 入门案例 * * @param args */ public static void main(String[] args) throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 4.4 基于注解方式定义 Mybatis 框架4.4.1 自定义@Select 注解12345678910111213141516/** * 查询的注解 * * @author wgy */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Select &#123; /** * 配置SQL语句的 * * @return */ String value();&#125; 4.4.2 修改持久层接口123456789101112131415/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 4.4.3 修改 SqlMapConfig.xml1234&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;&lt;mappers&gt; &lt;mapper class=\"com.wgy.dao.IUserDao\"/&gt;&lt;/mappers&gt;","tags":[{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://wgy1993.gitee.io/tags/MyBatis/"}]},{"title":"Maven(三)","date":"2020-06-18T16:03:44.000Z","path":"archives/898b4292.html","text":"1. maven 私服1.1 需求正式开发，不同的项目组开发不同的工程。 ssm_dao 工程开发完毕，发布到私服。 ssm_service 从私服下载 dao 1.2 分析公司在自己的局域网内搭建自己的远程仓库服务器，称为私服，私服服务器即是公司内部的 maven 远程仓库，每个员工的电脑上安装 maven 软件并且连接私服服务器，员工将自己开发的项目打成 jar 并发布到私服服务器，其它项目组从私服服务器下载所依赖的构件（jar）。 私服还充当一个代理服务器，当私服上没有 jar 包会从互联网中央仓库自动下载，如下图： 1.3 搭建私服环境1.3.1 下载 nexusNexus 是 Maven 仓库管理器，通过 nexus 可以搭建 maven 仓库，同时 nexus 还提供强 大的仓库管理功能，构件搜索功能等。 下载 Nexus， 下载地址：https://www.sonatype.com/download-oss-sonatype 1.3.2 安装 nexus解压 nexus-2.12.0-01-bundle.zip，本教程将它解压在 F 盘，进入 bin 目录： cmd进入 bin目录，执行 nexus.bat install 安装成功在服务中查看有 nexus 服务： 1.3.3 卸载 nexuscmd 进入 nexus 的 bin 目录，执行：nexus.bat uninstall 查看 window 服务列表 nexus 已被删除。 1.3.4 启动 nexus方法 1：cmd 进入 bin 目录，执行 nexus.bat start 方法 2：直接启动 nexus 服务 1.3.4.1 查看 nexus 的配置文件conf/nexus.properties 12345678# Jetty sectionapplication-port=8081 # nexus 的访问端口配置 application-host=0.0.0.0 # nexus 主机监听配置(不用修改) nexus-webapp=$&#123;bundleBasedir&#125;/nexus # nexus 工程目录 nexus-webapp-context-path=/nexus # nexus 的 web 访问路径# Nexus sectionnexus-work=$&#123;bundleBasedir&#125;/../sonatype-work/nexus # nexus 仓库目录runtime=$&#123;bundleBasedir&#125;/nexus/WEB-INF # nexus 运行程序目录 1.3.4.2 访问http://localhost:8081/nexus/ 1.3.4.3 使用 Nexus 内置账户登陆点击右上角的 Log in，输入账号和密码登陆 admin/admin123 登陆成功： 1.3.5 仓库类型1.3.5.1 查看 nexus 的仓库 1.3.5.2 nexus 的仓库有 4 种类型 1、hosted，宿主仓库，部署自己的 jar 到这个类型的仓库，包括 releases 和 snapshot 两部 分，Releases 公司内部发布版本仓库、 Snapshots 公司内部测试版本仓库 2、proxy，代理仓库，用于代理远程的公共仓库，如 maven 中央仓库，用户连接私服，私服自动去中央仓库下载 jar 包或者插件。 3、group，仓库组，用来合并多个 hosted/proxy 仓库，通常我们配置自己的 maven 连接仓库组。 4、virtual(虚拟)：兼容 Maven1 版本的 jar 或者插件 1.3.5.3 nexus 仓库目录默认在 sonatype-work 目录中： central：代理仓库，代理中央仓库 apache-snapshots：代理仓库，存储 snapshots 构件，代理地址 https://repository.apache.org/snapshots/ central-m1：virtual 类型仓库，兼容 Maven1 版本的 jar 或者插件 releases：本地仓库，存储 releases 构件。 snapshots：本地仓库，存储snapshots 构件。 thirdparty：第三方仓库 public：仓库组 1.4 将项目发布到私服1.4.1 需求企业中多个团队协作开发通常会将一些公用的组件、开发模块等发布到私服供其它团队 或模块开发人员使用。 本例子假设多团队分别开发 ssm_dao、ssm_service、ssm_web，某个团队开发完在 ssm_dao 会将 ssm_dao 发布到私服供 ssm_service 团队使用，本例子会将 ssm_dao 工程打成 jar 包发布到私服。 1.4.2 配置1.4.2.1 修改 settings.xml文件需要在客户端即部署 ssm_dao 工程的电脑上配置 maven 环境，并修改 settings.xml文件，配置连接私服的用户和密码 。 此用户名和密码用于私服校验，因为私服需要知道上传的账号和密码是否和私服中的账号和 密码一致。 12345678910111213141516&lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;!-- releases 连接发布版本项目仓库 snapshots 连接测试版本项目仓库--&gt; 1.4.2.2 配置项目 pom.xml配置私服仓库的地址，本公司的自己的 jar 包会上传到私服的宿主仓库，根据工程的版本号决定上传到哪个宿主仓库，如果版本为 release 则上传到私服的 release 仓库，如果版本为 snapshot 则上传到私服的 snapshot 仓库 12345678910&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 注意：pom.xml 这里&lt;id&gt; 和 settings.xml 配置 &lt;id&gt; 对应！ 1.4.3 测试将项目 dao 工程打成 jar 包发布到私服： 1、首先启动 nexus 2、对 ssm_dao 工程执行 deploy 命令 根据本项目pom.xml中version定义决定发布到哪个仓库，如果 version定义为 snapshot， 执行 deploy 后查看 nexus 的 snapshot 仓库，如果 version 定义为 release 则项目将发布到 nexus 的 release 仓库。 1.5 从私服下载 jar 包1.5.1 需求没有配置 nexus 之前，如果本地仓库没有，去中央仓库下载，通常在企业中会在局域网 内部署一台私服服务器，有了私服本地项目首先去本地仓库找 jar，如果没有找到则连接私 服从私服下载 jar 包，如果私服没有 jar 包私服同时作为代理服务器从中央仓库下载 jar 包， 这样做的好处是一方面由私服对公司项目的依赖 jar 包统一管理，一方面提高下载速度，项 目连接私服下载 jar 包的速度要比项目连接中央仓库的速度快的多。 本例子测试从私服下载 ssm_dao 工程 jar 包。 1.5.2 管理仓库组nexus中包括很多仓库，hosted 中存放的是企业自己发布的jar包及第三方公司的 jar包， proxy 中存放的是中央仓库的 jar，为了方便从私服下载 jar 包可以将多个仓库组成一个仓库 组，每个工程需要连接私服的仓库组下载 jar 包。 打开 nexus 配置仓库组，如下图： 上图中仓库组包括了本地仓库、代理仓库等。 1.5.3 在 settings.xml 中配置仓库在客户端的 settings.xml 中配置私服的仓库，由于 settings.xml 中没有 repositories 的配置标签需要使用 profile 定义仓库。 1234567891011121314151617181920212223242526272829&lt;profile&gt; &lt;!--profile 的 id--&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库 id，repositories 可以配置多个仓库，保证 id 不重复--&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址，即 nexus 仓库组的地址--&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;!--是否下载 releases 构件--&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!--是否下载 snapshots 构件--&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven 的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;!-- 插件仓库的 id 不允许重复，如果重复后边配置会覆盖前边 --&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/profile&gt; 使用 profile 定义仓库需要激活才可生效。 123&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 2. 把第三方 jar 包放入本地仓库或私服2.1 导入本地库随便找一个 jar 包测试，可以先 CMD 进入到 jar 包所在位置，运行 1mvn install:install-file -DgroupId&#x3D;com.alibaba -DartifactId&#x3D;fastjson -Dversion&#x3D;1.1.37 -Dfile&#x3D;fastjson-1.1.37.jar -Dpackaging&#x3D;jar 2.2 导入私服需要在 maven 软件的核心配置文件 settings.xml 中配置第三方仓库的 server 信息 12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; CMD执行命令 1mvn deploy:deploy-file -DgroupId&#x3D;com.alibaba -DartifactId&#x3D;fastjson -Dversion&#x3D;1.1.37 -Dpackaging&#x3D;jar -Dfile&#x3D;fastjson-1.1.37.jar -Durl&#x3D;http:&#x2F;&#x2F;localhost:8081&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;thirdparty&#x2F; -DrepositoryId&#x3D;thirdparty 2.3 参数说明 DgroupId 和 DartifactId 构成了该 jar 包在 pom.xml 的坐标，项目就是依靠这两个属性定位。 自己起名字也行。 Dfile 表示需要上传的 jar 包的绝对路径。 Durl 私服上仓库的位置，打开 nexus——&gt;repositories 菜单，可以看到该路径。 DrepositoryId 服务器的表示 id，在 nexus 的 configuration 可以看到。 Dversion 表示版本信息。 关于 jar 包准确的版本： 包的名字上一般会带版本号，如果没有那可以解压该包，会发现一个叫 MANIFEST.MF 的文件，这个文件就有描述该包的版本信息。","tags":[{"name":"Maven","slug":"Maven","permalink":"https://wgy1993.gitee.io/tags/Maven/"},{"name":"项目管理","slug":"项目管理","permalink":"https://wgy1993.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"Maven(二)","date":"2020-06-18T14:07:00.000Z","path":"archives/f77862b9.html","text":"1. maven 构建 SSM 工程1.1 需求实现 SSM 工程构建，规范依赖管理。场景：根据 id 展示商品信息 1.2 准备数据库1234567891011121314151617181920212223SET FOREIGN_KEY_CHECKS&#x3D;0;-- ------------------------------ Table structure for &#96;items&#96;-- ----------------------------DROP TABLE IF EXISTS &#96;items&#96;;CREATE TABLE &#96;items&#96; ( &#96;id&#96; int(10) NOT NULL auto_increment, &#96;name&#96; varchar(20) default NULL, &#96;price&#96; float(10,0) default NULL, &#96;pic&#96; varchar(40) default NULL, &#96;createtime&#96; datetime default NULL, &#96;detail&#96; varchar(200) default NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;9 DEFAULT CHARSET&#x3D;utf8;-- ------------------------------ Records of items-- ----------------------------INSERT INTO &#96;items&#96; VALUES (&#39;1&#39;, &#39;插入测试1&#39;, &#39;1000&#39;, null, &#39;2018-03-13 09:29:30&#39;, &#39;插入测试&#39;);INSERT INTO &#96;items&#96; VALUES (&#39;2&#39;, &#39;插入测试2&#39;, null, null, &#39;2018-03-28 10:05:52&#39;, &#39;插入测试&#39;);INSERT INTO &#96;items&#96; VALUES (&#39;3&#39;, &#39;插入测试3&#39;, &#39;199&#39;, null, &#39;2018-03-07 10:08:04&#39;, &#39;插入测试&#39;);INSERT INTO &#96;items&#96; VALUES (&#39;4&#39;, &#39;插入测试4&#39;, null, null, null, null);INSERT INTO &#96;items&#96; VALUES (&#39;5&#39;, &#39;插入测试5&#39;, null, null, null, null); 1.3 创建一个 maven 工程1.3.1 新建 ssm_maven 项目,使用下图选中的骨架 1.3.2 填写坐标 1.3.3 查看是否使用的自己的私服 1.3.4 在 main 目录下新建 java 和 resources 文件夹把 java 和 resources 文件夹转成 Sources Root和Resources Root 1.3.5 修改编译版本，在 pom.xml 文件中添加123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;!-- 设置编译版本为1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1.4 知识点准备1.4.1 什么是依赖传递先添加 springmvc 的核心依赖的坐标 12345678&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 会发现出现除了 spring-webmvc 以外的其他 jar。因为我们的项目依赖 spring-webmv.jar，而 spring-webmv.jar 会依赖 spring-beans.jar 等等，所以 spring-beans.jar 这些 jar 包也出现在了我 们的 maven 工程中，这种现象我们称为依赖传递。从下图中可看到他们的关系：（请注意 spring-beans 的版本） 1.4.2 依赖冲突的解决接着添加一个依赖 1234567891011121314&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 我们会发现这两个 jar 包同时都依赖了 spring-beans spring-webmvc 依赖 spirng-beans-4.2.4，spring-context 依赖 spring-beans-5.0.2，但是发现 spirng-beans-4.2.4 加入到工程中。而我们希望 spring-beans-5.0.2 加入工程。这就造成了依赖冲突。 1.4.2.1 依赖调解原则maven 自动按照下边的原则调解： 第一声明者优先原则： 在 pom 文件定义依赖，先声明的依赖为准。 测试： 如果将上边 spring-webmvc 和 spring-context 顺序颠倒，系统将导入 spring-beans-5.0.2。 分析：由于 spring-webmvc 在前边以 spring-webmvc 依赖的 spring-beans-5.0.2 为准，所以最终spring-beans-5.0.2 添加到了工程中。 路径近者优先原则： 例如：还是上述情况，spring-contex 和 spring-webmvc 都会传递过来 spirng-beans，那 如果直接把 spring-beans 的依赖直接写到 pom 文件中，那么项目就不会再使用其他依赖传 递来的 spring-beans，因为自己直接在 pom 中定义 spring-beans 要比其他依赖传递过来的路径要近。在本工程中的 pom 中加入 spirng-beans-5.0.2 的依赖，根据路径近者优先原则，系统将导入spirng-beans-5.0.2： 12345678910111213141516171819&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1.4.2.2 排除依赖上边的问题也可以通过排除依赖方法辅助依赖调解，如下： 比如在依赖 spring-webmvc 的设置中添加排除依赖，排除 spring-beans， 下边的配置表示：依赖 spring-webmvc，但排除 spring-webmvc 所依赖的 spring-beans。 1234567891011121314151617181920&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1.4.2.3 锁定版本面对众多的依赖，有一种方法不用考虑依赖路径、声明优化等因素可以采用直接锁定版 本的方法确定依赖构件的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本的为准添加到工程中，此方法在企业开发中常用。 如下的配置是锁定了 spring-beans 和 spring-context 的版本： 123456789101112131415&lt;!-- 锁定jar包版本 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 还可以把版本号提取出来，使用&lt;properties&gt;标签设置成变量。 1234567891011121314151617181920&lt;!-- 统一管理jar包版本 --&gt;&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;!-- 锁定jar包版本 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 注意：在工程中锁定依赖的版本并不代表在工程中添加了依赖，如果工程需要添加锁定版本的依赖则需要单独添加&lt;dependencies&gt;&lt;/dependencies&gt;标签，如下： 123456789101112&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 上边添加的依赖并没有指定版本，原因是已在&lt;dependencyManagement&gt;中锁定了版本， 所以在&lt;dependency&gt;下不需要再指定版本。 1.5 定义 pom.xmlmaven 工程首先要识别依赖，web 工程实现 SSM 整合，需要依赖 spring-webmvc5.0.2、 spring5.0.2、mybatis3.4.5 等，在 pom.xml 添加工程如下依赖： （在实际企业开发中会有架构师专门来编写 pom.xml） 分两步： 锁定依赖版本 添加依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222&lt;!-- 统一管理jar包版本 --&gt;&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;!-- 锁定jar包版本 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;!-- 添加tomcat7插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 设置编译版本为1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1.6 Dao 层在 src/main/java 中定义 dao 接口，实现根据 id 查询商品信息： 1.6.1 pojo 模型类在 src/main/java 创建模型类 123456789101112131415/** * 实体类 * * @author wgy */public class Items implements Serializable &#123; private Integer id; private String name; private Double price; private String pic; private Date createtime; private String detail; ...&#125; 1.6.2 dao 层代码123456789101112131415/** * 持久接口 * * @author wgy */public interface ItemsDao &#123; /** * 根据id查询 * * @param id * @return */ public Items findById(Integer id);&#125; 1.6.3 配置文件1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.ItemsDao\"&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"items\"&gt; select * from items where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 注意配置文件位置（resources下创建目录/com/wgy/dao）： 在 src/main/resources 配置 log4j.properties 12345678### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5 p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change 'info' to 'debug' ####在开发阶段日志级别使用 debuglog4j.rootLogger=debug, stdout 在 src/main/resources 创建 applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--dao层配置文件开始--&gt; &lt;!--配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///maven\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--配置生产SqlSession对象的工厂--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--扫描pojo包，给包下所有pojo对象起别名--&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.wgy.domain\"/&gt; &lt;/bean&gt; &lt;!--扫描接口包路径，生成包下所有接口的代理对象，并且放入spring容器中--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.wgy.dao\"/&gt; &lt;/bean&gt; &lt;!--dao层配置文件结束--&gt;&lt;/beans&gt; 1.6.4 单元测试在 src/test/java 创建单元测试类 12345678910111213141516171819/** * 测试 * * @author wgy */public class ItemsTest &#123; @Test public void findById() &#123; //获取spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //dao测试 //从容器中拿到所需的dao的代理对象 ItemsDao itemsDao = ac.getBean(ItemsDao.class); //调用方法 Items items = itemsDao.findById(1); System.out.println(items.getName()); &#125;&#125; 1.7 Service 层1.7.1 代码123456789101112131415/** * 业务层接口 * * @author wgy */public interface ItemsService &#123; /** * 根据id查询 * * @param id * @return */ public Items findById(Integer id);&#125; 123456789101112131415/** * 持久层实现类 * * @author wgy */@Servicepublic class ItemsServiceImpl implements ItemsService &#123; @Autowired private ItemsDao itemsDao; public Items findById(Integer id) &#123; return itemsDao.findById(id); &#125;&#125; 1.7.2 配置文件在 applicationContext.xml 中配置 service 123456789101112131415161718192021222324252627&lt;!--service层配置文件开始--&gt;&lt;!--组件扫描配置--&gt;&lt;context:component-scan base-package=\"com.wgy.service\"/&gt;&lt;!--aop面向切面编程，切面就是切入点和通知的组合--&gt;&lt;!--配置事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--配置事务的通知--&gt;&lt;tx:advice id=\"advice\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt; &lt;tx:method name=\"*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置切面--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"advice\" pointcut-ref=\"pointcut\"/&gt;&lt;/aop:config&gt;&lt;!--service层配置文件结束--&gt; 1.7.3 单元测试123456789101112131415161718/** * 测试 * * @author wgy */public class ItemsTest &#123; @Test public void findById() &#123; //获取spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //service测试 ItemsService itemsService = ac.getBean(ItemsService.class); //调用方法 Items items = itemsService.findById(1); System.out.println(items.getName()); &#125;&#125; 1.8 Web 层1.8.1 代码12345678910111213141516171819/** * 控制器 * * @author wgy */@Controller@RequestMapping(\"/items\")public class ItemsController &#123; @Autowired private ItemsService itemsService; @RequestMapping(\"/findDetail\") public String findDetail(Model model) &#123; Items items = itemsService.findById(1); model.addAttribute(\"item\", items); return \"itemDetail\"; &#125;&#125; 1.8.2 配置文件在 src/main/resources 创建 springmvc.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=\"com.wgy.controller\"/&gt; &lt;!--处理器映射器，处理器适配器--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--释放静态资源--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; 配置web.xml，加载 spring 容器，配置 springmvc 前端控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;!--编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置spring核心监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--重新指定spring配置文件的路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--springmvc的核心servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 1.9 Jsp/WEB-INF/pages/itemDetail.jsp 12345678910111213141516171819202122232425262728293031323334&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;table width=\"100%\" border=1&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt; $&#123;item.name &#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt; $&#123;item.price &#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;生成日期&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=\"$&#123;item.createtime&#125;\" pattern=\"yyyy-MM-dd HH:mm:ss\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品简介&lt;/td&gt; &lt;td&gt;$&#123;item.detail&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1.10 运行与调试添加 tomcat7 插件，双击右侧 tomcat7 运行 运行结果如下： 2. 分模块构建工程基于上边的三个工程分析 继承：创建一个 parent 工程将所需的依赖都配置在 pom 中 聚合：聚合多个模块运行。 2.1 需求2.1.1 需求描述将 SSM 工程拆分为多个模块开发： ssm_dao、ssm_service、ssm_web 2.1.2 理解继承和聚合通常继承和聚合同时使用 何为继承？ 继承是为了消除重复，如果将 dao、service、web 分开创建独立的工程则每个工程的 pom.xml 文件中的内容存在重复，比如：设置编译版本、锁定 spring 的版本的等，可以将这些重复的配置提取出来在父工程的 pom.xml 中定义。 何为聚合？ 项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在 一起运行，比如：dao、service、web 三个工程最终会打一个独立的 war 运行。 2.2 案例实现2.2.1 maven-parent 父模块2.2.1.1 创建父工程工程只有pom.xml文件 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;artifactId&gt;maven05_parent&lt;/artifactId&gt; &lt;!-- 设置项目的打包方式 --&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 2.2.1.2 定义 pom.xml在父工程的 pom.xml 中抽取一些重复的配置的， 比如： 锁定 jar 包的版本、 设置编译版本等。 具体配置同上1.5 2.2.2 ssm_dao 子模块2.2.2.1 创建 dao 子模块在父工程上右击创建 maven 模块 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;maven05_parent&lt;/artifactId&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven05_dao&lt;/artifactId&gt;&lt;/project&gt; 2.2.2.2 dao 代码将 ssm_maven 工程中的 dao接口、映射文件及 pojo 类拷贝到 src/main/java 中： 2.2.2.3 配置文件将 applicationContext.xml拆分出一个applicationContext-dao.xml，此文件中只配置 dao 相关内容 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--dao层配置文件开始--&gt; &lt;!--配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///maven\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--配置生产SqlSession对象的工厂--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--扫描pojo包，给包下所有pojo对象起别名--&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.wgy.domain\"/&gt; &lt;/bean&gt; &lt;!--扫描接口包路径，生成包下所有接口的代理对象，并且放入spring容器中--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.wgy.dao\"/&gt; &lt;/bean&gt; &lt;!--dao层配置文件结束--&gt;&lt;/beans&gt; 2.2.3 ssm_service 子模块2.2.3.1 创建 service 子模块方法同 ssm_dao 模块创建方法。ssm_service 依赖 ssm_dao 模块 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;maven05_parent&lt;/artifactId&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven05_service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;artifactId&gt;maven05_dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.2.3.2 service 代码将 ssm_maven 工程中的service接口、实现类拷贝到 src/main/java中： 2.2.3.3 配置文件将 applicationContext.xml拆分出一个applicationContext-service.xml，此文件中只配置 service相关内容 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--service层配置文件开始--&gt; &lt;!--组件扫描配置--&gt; &lt;context:component-scan base-package=\"com.wgy.service\"/&gt; &lt;!--aop面向切面编程，切面就是切入点和通知的组合--&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!--配置事务的通知--&gt; &lt;tx:advice id=\"advice\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt; &lt;tx:method name=\"*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"advice\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; &lt;!--service层配置文件结束--&gt;&lt;/beans&gt; 2.2.4 ssm_web 子模块2.2.4.1 创建 web 子模块 ssm_web 依赖 ssm_service 模块 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;maven05_parent&lt;/artifactId&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven05_web&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;artifactId&gt;maven05_service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.2.4.2 controller 代码将 ssm_web 工程中的controller 代码拷贝到src/main/java 中： 2.2.4.3 配置文件拷贝 ssm_web 工程中配置文件 将 applicationContext.xml引入server、dao配置： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"classpath:spring/applicationContext-dao.xml\"/&gt; &lt;import resource=\"classpath:spring/applicationContext-service.xml\"/&gt;&lt;/beans&gt; 2.2.5 运行调试 方法 1：在 ssm_web 工程的 pom.xml 中配置 tomcat 插件运行 运行 ssm_web 工程它会从本地仓库下载依赖的 jar 包，所以当 ssm_web 依赖的 jar 包内容修改了必须及时发布到本地仓库，比如：ssm_web 依赖的 ssm_service 修改了，需要及时将ssm_service 发布到本地仓库。 方法 2：在父工程的 pom.xml 中配置 tomcat 插件运行，自动聚合并执行 推荐方法 2，如果子工程都在本地，采用方法 2 则不需要子工程修改就立即发布到本地仓库， 父工程会自动聚合并使用最新代码执行。 注意：如果子工程和父工程中都配置了 tomcat 插件，运行的端口和路径以子工程为准。","tags":[{"name":"Maven","slug":"Maven","permalink":"https://wgy1993.gitee.io/tags/Maven/"},{"name":"项目管理","slug":"项目管理","permalink":"https://wgy1993.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"Maven(一)","date":"2020-06-17T08:21:58.000Z","path":"archives/5849f9db.html","text":"1. Maven 介绍1.1 什么是 Maven1.1.1 什么是 MavenMaven 是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)， 和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 1.1.2 Maven能解决什么问题用更通俗的方式来说明，项目开发不仅仅是写写代码而已，期间会伴随着各种必不可少的事情要做，下面列举几个感受一下： 我们需要引用各种 jar包，尤其是比较大的工程，引用的 jar 包往往有几十个乃至上百个， 每用到一种 jar包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的jar 包冲突，版本冲突。 我们辛辛苦苦写好了 Java文件，可是只懂 0 和 1 的白痴电脑却完全读不懂，需要将它编译成二进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA 等都可以将代码即时编译。当然，如果你嫌生命漫长，何不铺张，也可以用记事本来敲代码，然后用 javac 命令一个个地去编译，逗电脑玩。 世界上没有不存在 bug的代码，为了减少 bug，因此写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。 再优雅的代码也是要出来卖的。我们后面还需要把代码与各种配置文件、资源整合到一起，定型打包，如果是 web项目，还需要将之发布到服务器，供人蹂躏。 试想，如果现在有一种工具，可以把你从上面的繁琐工作中解放出来，能帮你构建工程，管理 jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站点，你会心动吗？Maven 就可以解决上面所提到的这些问题。 1.1.3 Maven 的优势举例我们通过 Web 阶段项目，要能够将项目运行起来，就必须将该项目所依赖的一些 jar 包添加到工程中，否则项目就不能运行。试想如果具有相同架构的项目有十个，那么我们就需要将这一份 jar包复制到十个不同的工程中。我们一起来看一个CRM项目的工程大小。 使用传统 Web 项目构建的 CRM 项目如下： 原因主要是因为上面的 WEB 程序要运行，我们必须将项目运行所需的 Jar 包复制到工程目录中，从而导致了工程很大。 同样的项目，如果我们使用Maven 工程来构建，会发现总体上工程的大小会少很多。如下图: 小结：可以初步推断它里面一定没有 jar 包，继续思考，没有 jar 包的项目怎么可能运行呢？ 1.2 Maven的两个精典作用1.2.1 Maven的依赖管理Maven的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成一项困难的任务。Maven展示出了它对处理这种情形的高度控制。 传统的WEB项目中，我们必须将工程所依赖的jar包复制到工程中，导致了工程的变得很大。那么maven工程是如何使得工程变得很少呢？ 分析如下： 通过分析发现：maven工程中不直接将jar包导入到工程中，而是通过在pom.xml文件中添加所需jar包的坐标，这样就很好的避免了jar直接引入进来，在需要用到jar包的时候，只要查找pom.xml文件，再通过pom.xml文件中的坐标，到一个专门用于”存放jar包的仓库”(maven仓库)中根据坐标从而找到这些jar包，再把这些jar包拿去运行。 那么问题来了第一：”存放jar包的仓库”长什么样？第二：通过读取pom.xml 文件中的坐标，再到仓库中找到jar包，会不会很慢？从而导致这种方式不可行！ 第一个问题：存放jar包的仓库长什么样，这一点我们后期会分析仓库的分类，也会带大家去看我们的本地的仓库长什么样。第二个问题：通过pom.xml文件配置要引入的jar包的坐标，再读取坐标并到仓库中加载jar包，这样我们就可以直接使用jar包了，为了解决这个过程中速度慢的问题，maven中也有索引的概念，通过建立索引，可以大大提高加载jar包的速度，使得我们认为jar包基本跟放在本地的工程文件中再读取出来的速度是一样的。这个过程就好比我们查阅字典时，为了能够加快查找到内容，书前面的目录就好比是索引，有了这个目录我们就可以方便找到内容了，一样的在maven仓库中有了索引我们就可以认为可以快速找到jar包。 1.2.2 项目的一键构建我们的项目，往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。 什么是构建：指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给maven进行管理，这个过程称为构建。 一键构建：指的是整个构建过程，使用maven一个命令可以轻松完成整个工作。 Maven规范化构建流程如下： 2. Maven 的使用2.1 Maven的安装2.1.1 Maven软件的下载为了使用Maven管理工具，我们首先要到官网去下载它的安装软件。通过百度搜索“Maven“如下： 点击 Download 链接，就可以直接进入到 Maven 软件的下载页面： 2.1.2 Maven软件的安装Maven下载后，将Maven解压到一个没有中文没有空格的路径下，比如D:\\software\\maven下面。解压后目录结构如下： bin:存放了maven的命令，比如我们前面用到的mvn tomcat:runboot:存放了一些maven本身的引导程序，如类加载器等conf:存放了maven的一些配置文件，如setting.xml文件lib:存放了maven本身运行所需的一些jar包 至此我们的maven软件就可以使用了，前提是你的电脑上之前已经安装并配置好了JDK。 2.1.3 JDK的准备JDK 使用 JDK8版本 2.1.4 Maven及JDK配置配置 MAVEN_HOME （bin目录之前一级目录）： 配置JAVA_HOME： 添加%MAVEN_HOME%/bin;%JAVA_HOME%/bin;到patch中。 2.1.5 Maven软件版本测试通过 mvn -v命令检查 maven是否安装成功，看到maven的版本为3.5.2及java版本为1. 8 即为安装成功。 找开cmd命令，输入mvn –v命令，如下图： 2.2 Maven仓库2.2.1 Maven仓库的分类maven的工作需要从仓库下载一些jar包，如下图所示，本地的项目A、项目B等都会通过maven软件从远程仓库（可以理解为互联网上的仓库）下载jar包并存在本地仓库，本地仓库就是本地文件夹，当第二次需要此jar包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。 下图描述了maven中仓库的类型： 本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找。默认本地仓库位置在 ${user.dir}/.m2/repository，${user.dir}表示windows 用户目录 远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。 中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件。 2.2.2 Maven本地仓库的配置在MAVE_HOME/conf/settings.xml文件中配置本地仓库位置（maven的安装目录下）： 打开settings.xml文件，配置如下： 2.2.3 全局setting与用户settingmaven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。 在maven安装目录下的有 conf/setting.xml文件，此setting.xml文件用于maven的所有project项目，它作为maven的全局配置。 如需要个性配置则需要在用户配置中设置，用户配置的setting.xml文件默认的位置在：${user.dir}/.m2/settings.xml目录中,${user.dir} 指windows 中的用户目录。 maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。 2.3 Maven工程的认识2.3.1 Maven工程的目录结构 作为一个maven工程，它的src目录和pom.xml是必备的。 进入src目录后，我们发现它里面的目录结构如下： src/main/java —— 存放项目的.java文件src/main/resources —— 存放项目资源文件，如spring, hibernate配置文件src/test/java —— 存放所有单元测试.java文件，如JUnit测试类src/test/resources —— 测试资源文件target —— 项目输出位置，编译后的class文件会输出到此目录pom.xml——maven项目核心配置文件 注意：如果是普通的java项目，那么就没有webapp目录。 2.3.2 Maven工程的运行进入maven工程目录（当前目录有pom.xml文件），运行tomcat:run命令。 根据上边的提示信息，通过浏览器访问：http://localhost:8080/maven-helloworld/ 3. Maven常用命令我们可以在cmd中通过一系列的maven命令来对我们的maven-helloworld工程进行编译、测试、运行、打包、安装、部署。 3.1 compilecompile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。 cmd进入命令状态，执行mvn compile，如下图提示成功： 查看 target目录，class文件已生成，编译完成。 3.2 testtest是maven工程的测试命令 mvn test，会执行src/test/java下的单元测试类。 cmd执行mvn test执行src/test/java下单元测试类，下图为测试结果，运行 1 个测试用例，全部成功。 3.3 cleanclean是maven工程的清理命令，执行 clean会删除target目录及内容。 3.4 packagepackage是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。 3.5 installinstall是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。 3.6 Maven指令的生命周期maven对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是： Clean Lifecycle ：在进行真正的构建之前进行一些清理工作。Default Lifecycle ：构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle ：生成项目报告，站点，发布站点。 3.7 maven的概念模型Maven包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 项目对象模型 (Project Object Model) 一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。 12345678910&lt;project&gt; ：文件的根节点 .&lt;modelversion&gt; ： pom.xml 使用的对象模型版本&lt;groupId&gt; ：项目名称，一般写项目的域名&lt;artifactId&gt; ：模块名称，子项目名或模块名称&lt;version&gt; ：产品的版本号 .&lt;packaging&gt; ：打包类型，一般有 jar、war、pom 等&lt;name&gt; ：项目的显示名，常用于 Maven 生成的文档。&lt;description&gt; ：项目描述，常用于 Maven 生成的文档&lt;dependencies&gt; ：项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt; ：项目构建配置，配置编译、运行插件等。 依赖管理系统(Dependency Management System) 通过maven的依赖管理对项目所依赖的jar 包进行统一管理。 比如：项目依赖junit4.9，通过在pom.xml中定义junit4.9的依赖即使用junit4.9，如下所示是junit4.9的依赖定义： 1234567891011121314&lt;!-- 依赖关系 --&gt;&lt;dependencies&gt; &lt;!-- 此项目运行使用 junit，所以此项目依赖 junit --&gt; &lt;dependency&gt; &lt;!-- junit 的项目名称 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!-- junit 的模块名称 --&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!-- junit 版本 --&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;!-- 依赖范围：单元测试时使用 junit --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 一个项目生命周期(Project Lifecycle) 使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven将这些过程规范为一个生命周期，如下所示是生命周期的各各阶段： maven通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行mvn compile执行编译、执行mvn clean执行清理。 一组标准集合 maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。 插件(plugin)目标(goal) maven 管理项目生命周期过程都是基于插件完成的。 4. idea开发maven项目在实战的环境中，我们都会使用流行的工具来开发项目。 4.1 idea的maven配置依据图片指示，选择本地maven安装目录，指定maven安装目录下conf文件夹中settings配置文件。 4.2 idea中创建maven的web工程打开idea，选择创建一个新工程 选择idea提供好的maven的web工程模板 点击Next填写项目信息 点击Next，此处不做改动。 点击Next选择项目所在目录 点击Finish后开始创建工程，耐心等待，直到出现如下界面。 手动添加src/main/java目录，如下图右键main文件夹&gt;New&gt;Directory 创建一个新的文件夹命名为java 点击OK后，在新的文件夹java上右键&gt;Make Directory as&gt;Sources Root 4.2.1 创建一个Servletsrc/java/main创建了一个Servlet，但报错 要解决问题，就是要将servlet-api-xxx.jar包放进来，作为maven工程应当添加servlet的坐标，从而导入它的jar 4.2.2 在pom.xml文件添加坐标直接打开hello_maven工程的pom.xml文件，再添加坐标 添加jar包的坐标时，还可以指定这个jar包将来的作用范围。 每个maven工程都需要定义本工程的坐标，坐标是maven对jar包的身份定义，比如：入门程序的坐标定义如下： 12345678910&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&lt;groupId&gt;com.wgy&lt;&#x2F;groupId&gt;&lt;!-- 模块名称 --&gt;&lt;artifactId&gt;hello_maven&lt;&#x2F;artifactId&gt;&lt;!-- 当前项目版本号，snapshot 为快照版本即非正式版本，release为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;&lt;packaging&gt; ：打包类型 jar：执行 package 会打成 jar 包 war：执行 package 会打成 war 包 pom ：用于 maven 工程的继承，通常父工程设置为 pom 4.2.3 坐标的来源方式添加依赖需要指定依赖jar包的坐标，但是很多情况我们是不知道jar包的的坐标，可以通过如下方式查询： http://search.maven.org/http://mvnrepository.com/ 4.3 依赖范围A依赖B，需要在A的pom.xml文件中添加B的坐标，添加坐标时需要指定依赖范围，依赖范围包括： compile：编译范围，指A在编译时依赖B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。 provided：provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用， provided依赖在编译和测试时需要，在运行时不需要，比如：servlet api被tomcat容器提供。 runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以runtime范围的依赖会被打包。 test：test范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以test范围依赖不会被打包。 system：system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径，需要指定systemPath磁盘路径，system依赖不推荐使用。 在maven-web工程中测试各各scop。 测试总结： 默认引入 的jar包 ——- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ） servlet-api 、jsp-api ——- provided （编译、测试 有效， 运行时无效，防止和tomcat下jar冲突） jdbc驱动jar包 —- runtime （测试、运行 有效 ） junit —– test （测试有效） 依赖范围由强到弱的顺序是：compile&gt;provided&gt;runtime&gt;test 4.4 项目中添加的坐标1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.5 设置jdk编译版本本教程使用jdk1. 8 ，需要设置编译版本为1. 8 ，这里需要使用maven的插件来设置，在pom.xml中加入： 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 4.6 编写servlet在src/main/java中创建ServletTest 123456789101112public class MyServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher(\"/hello.jsp\").forward(request, response); &#125;&#125; 4.7 编写jsp123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; hello maven&lt;/body&gt;&lt;/html&gt; 4.8 在web.xml中配置servlet访问路径12345678&lt;servlet&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wgy.servlet.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4.9 添加tomcat7插件在pom文件中添加如下内容 12345678&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;/configuration&gt;&lt;/plugin&gt; 此时点击idea最右侧Maven Projects，就可以看到我们新添加的tomcat7插件双击tomcat7插件下tomcat7:run命令直接运行项目 也可以直接点击如图按钮，手动输入tomc7:run命令运行项目 5. maven工程运行调试5.1 端口占用处理重新执行tomcat:run命令重启工程，重启之前需手动停止 tomcat，否则报下边的错误： 5.2 断点调试点击如图所示选项 在弹出框中点击如图加号按钮找到maven选项 在弹出窗口中填写如下信息 完成后先Apply再OK结束配置后，可以在主界面找到我们刚才配置的操作名称。 如上图红框选中的两个按钮，左侧是正常启动，右侧是debug启动。","tags":[{"name":"Maven","slug":"Maven","permalink":"https://wgy1993.gitee.io/tags/Maven/"},{"name":"项目管理","slug":"项目管理","permalink":"https://wgy1993.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"SSH","date":"2020-06-16T05:58:26.000Z","path":"archives/782a8ece.html","text":"1. SSH三大框架整合1.1 整合说明 独立式整合指的是三个框架都使用自己的配置文件。 引入式整合指的是hibernate主配置文件中的内容都配置到spring配置文件中 在整合过程中，确保每步都运行成功，然后在继续往下做。 整合中使用的案例是客户的保存和列表查询操作。 后面的三种整合方式都基于1.2中的环境准备。 1.2 环境准备1.2.1 创建java web工程1.2.2 创建数据库和表结构1234567891011121314create database ssh;use ssh;&#x2F;*创建客户表*&#x2F;CREATE TABLE &#96;cst_customer&#96; ( &#96;cust_id&#96; bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#39;客户编号(主键)&#39;, &#96;cust_name&#96; varchar(32) NOT NULL COMMENT &#39;客户名称(公司名称)&#39;, &#96;cust_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户信息来源&#39;, &#96;cust_industry&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户所属行业&#39;, &#96;cust_level&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户级别&#39;, &#96;cust_address&#96; varchar(128) DEFAULT NULL COMMENT &#39;客户联系地址&#39;, &#96;cust_phone&#96; varchar(64) DEFAULT NULL COMMENT &#39;客户联系电话&#39;, PRIMARY KEY (&#96;cust_id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8; 1.2.3 编写实体类1234567891011121314/** * 客户的实体类（数据模型） */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; ...&#125; 1.2.4 编写业务层接口和实现类12345678910111213141516/** * 客户的业务层接口 */public interface ICustomerService &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer(); /** * @param customer */ void saveCustomer(Customer customer);&#125; 123456789101112131415161718192021/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao; public void setCustomerDao(ICustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125; @Override public void saveCustomer(Customer customer) &#123; customerDao.saveCustomer(customer); &#125;&#125; 1.2.5 编写持久层接口和实现类1234567891011121314151617/** * 客户的持久层接口 */public interface ICustomerDao &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer(); /** * 保存客户 * @param customer */ void saveCustomer(Customer customer);&#125; 12345678910111213141516/** * 客户的持久层实现类 */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; System.out.println(\"查询了所有用户\"); return null; &#125; @Override public void saveCustomer(Customer customer) &#123; System.out.println(\"保存了用户\"); &#125;&#125; 2. 基于XML的独立式整合2.1 保证spring框架在web工程中独立运行2.1.1 拷贝spring的ioc,aop和事务控制三组jar包ioc: aop: 事务控制: 2.1.2 编写spring配置文件并导入约束123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 2.1.3 把业务层和持久层配置到文件中123456789&lt;!-- 把资源交给spring来管理 --&gt;&lt;!-- 配置dao --&gt;&lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt;&lt;/bean&gt; &lt;!-- 配置service --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;!-- 注入dao --&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.1.4 测试spring能否独立运行12345678910111213/** * 测试类，测试spring框架可以独立运行 */public class SpringTest &#123; public static void main(String[] args) &#123; //1.获取spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.跟Id获取bean对象 ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); cs.findAllCustomer(); &#125;&#125; 2.2 保证hibernate框架能够在web工程中独立运行2.2.1 拷贝hibernate必备jar包hibernate基本jar包: c3p0: 2.2.2 编写实体类的映射文件1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping package=\"com.wgy.domain\"&gt; &lt;class name=\"Customer\" table=\"cst_customer\"&gt; &lt;id name=\"custId\" column=\"cust_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"custName\" column=\"cust_name\"/&gt; &lt;property name=\"custSource\" column=\"cust_source\"/&gt; &lt;property name=\"custIndustry\" column=\"cust_industry\"/&gt; &lt;property name=\"custLevel\" column=\"cust_level\"/&gt; &lt;property name=\"custAddress\" column=\"cust_address\"/&gt; &lt;property name=\"custPhone\" column=\"cust_phone\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 2.2.3 编写hibernate主配置文件12345678910111213141516171819202122232425262728293031&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory--&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/ssh&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name=\"hibernate.format_sql\"&gt;false&lt;/property&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name=\"hibernate.connection.provider_class\"&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;/property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping resource=\"com/wgy/domain/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 2.2.4 编写测试类-测试保存客户123456789101112131415161718192021222324252627/** * 保证hibernate框架能够独立在web工程中运行 * * @author wgy */public class HibernateTest &#123; public static void main(String[] args) &#123; Customer c = new Customer(); c.setCustName(\"ssh整合Customer\"); //1.加载配置文件 Configuration cfg = new Configuration(); cfg.configure(); //2.根据配置文件创建SessionFactory SessionFactory factory = cfg.buildSessionFactory(); //3.获取session Session session = factory.getCurrentSession(); //4.开启事务 Transaction tx = session.beginTransaction(); //5.执行操作 session.save(c); //6.提交/回滚事务 tx.commit(); //7.释放资源 factory.close(); &#125;&#125; 2.3 整合spring和hibernate框架2.3.1 明确 Spring和Hibernate的整合就是spring接管SessionFactory的创建 Spring针对Hiberante的操作有一个封装的对象HibernateTemplate 和JdbcTemplate一样，HibernateTemplate也有一个HibernateDaoSupport HibernateTemplate和HibernateDaoSupport都在spring-orm-4.2.4.RELEASE.jar中 我们Dao采用继承HiberanteDaoSupport的方式编写，它一样不能用于注解配置。 2.3.2 整合步骤2.3.2.1 在spring配置文件中配置SessionFactory12345678&lt;!-- 配置sessionFactory：让spring接管sessionFactory的创建 用spring提供的一个SessionFactory：LocalSessionFactoryBean 创建SessionFactory有三部分必不可少的信息。三部分信息在hibernate主配置文件中都有 把hibernate主配置文件的位置注入进来--&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\"/&gt;&lt;/bean&gt; 2.3.2.2 改造Dao继承HibernateDaoSupport123456789101112131415/** * 客户的持久层实现类 */public class CustomerDaoImpl extends HibernateDaoSupport implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return (List&lt;Customer&gt;) getHibernateTemplate().find(\"from Customer\"); &#125; @Override public void saveCustomer(Customer customer) &#123; getHibernateTemplate().save(customer); &#125;&#125; 2.3.2.3 在spring配置文件中给Dao注入SessionFactory1234&lt;!-- 配置dao --&gt;&lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.3.2.4 测试12345678910111213141516171819202122232425262728293031/** * 整合spring和hibernate的测试类 * spring整合Junit * 第一步：拷贝jar包 * spring-junit-4.2.4.jar * 第二步：使用注解替换运行器（原来junit的main方法） * @RunWith(支持spring的main方法) * @ContextConfiguration(指定spring的配置文件位置) */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:bean.xml\"&#125;)public class SpringHibernateTest &#123; @Autowired private ICustomerService cs; @Test public void testSave() &#123; Customer c = new Customer(); c.setCustName(\"spring hibernate customer123\"); cs.saveCustomer(c); &#125; @Test public void testFindAll() &#123; List list = cs.findAllCustomer(); for (Object o : list) &#123; System.out.println(o); &#125; &#125;&#125; 12345测试结果： 无论保存还是查询都运行失败！ 按常理来说，我们没有配置事务，保存失败是可以理解的。为什么查询也会失败呢？分析原因： 是由于spring的HibernateTemplate对象在使用Session时，spring创建了Session的代理对象，在这个过程中，spring对hibernate绑定Session到当前线程的配置不认识了，所以运行失败。 2.3.2.5 修改把Session绑定到当前线程上123456789&lt;!-- 是hibernate把session绑定到当前线程上的配置 &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt;--&gt;&lt;!-- 是spring把sesion绑定到当前线程上的配置 --&gt;&lt;property name=\"hibernate.current_session_context_class\"&gt; org.springframework.orm.hibernate5.SpringSessionContext&lt;/property&gt;此时再运行刚才的测试： 查询可以使用了。保存不能使用，原因是没有事务。 2.3.3 配置Spring的事务2.3.3.1 配置事务管理器并注入SessionFactory1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 2.3.3.2 配置事务的通知及通知的属性1234567&lt;!-- 配置事务的通知 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 2.3.3.3 配置AOP建立切入点表达式和事务通知的关系12345678910&lt;!-- 配置aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;!-- 建立切入点表达式和事务通知的关联 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt;&lt;/aop:config&gt;再次测试： 此时保存和查询都可以正常使用了。 2.4 保证struts2框架能够在web工程中独立运行2.4.1 拷贝struts2的必备jar包 2.4.2 编写struts.xml文件并导入约束123456789&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;struts&gt; 2.4.3 在web.xml中配置struts2的核心过滤器123456789&lt;!-- 配置struts2和核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.4.4 导入jsp页面 2.4.5 修改menu.jsp123&lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/addUICustomer.action\" target=main&gt;－ 新增客户&lt;/A&gt;&lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/findAllCustomer.action\" target=main&gt;－ 客户列表&lt;/A&gt; 2.4.6 在struts.xml中配置action12345678910&lt;!-- 配置动作 --&gt;&lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;action name&#x3D;&quot;addUICustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;addUICustomer&quot;&gt; &lt;result name&#x3D;&quot;addUICustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 2.4.7 编写动作类和方法12345678910111213141516171819202122232425262728/** * 客户的动作类*/public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); @Override public Customer getModel() &#123; return customer; &#125; /** * 获取添加客户页面 * @return */ public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 查询所有客户 * @return */ public String findAllCustomer() &#123; //调用业务层查询客户列表 &#125;&#125; 2.4.8 测试1运行结果：通过点击【新增客户】可以跳转到客户添加页面 2.5 整合spring和struts22.5.1 明确 spring整合struts2就是让spring接管action的创建 action是多例的，配置到spring中需要设置scope属性为多例 2.5.2 整合步骤2.5.2.1 拷贝spring整合struts的jar包 2.5.2.2 在action中使用构造函数获取Service对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 客户的动作类 */public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); private List&lt;Customer&gt; customers; private ICustomerService customerService; @Override public Customer getModel() &#123; return customer; &#125; public void setCustomerService(ICustomerService customerService) &#123; this.customerService = customerService; &#125;//此种方式根本不能用，因为由于动作类是多例的，每次都会创建新的容器，导致容器中的bean也会创建新的。// public CustomerAction()&#123;// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// System.out.println(ac);// ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\");// this.setCustomerService(cs);// &#125;//此种方式解决了容器多例的问题，保证了容器一个应用只有一个，但是我们的代码边臃肿了，每个action都需要这么写一下。 public CustomerAction()&#123; ServletContext application = ServletActionContext.getServletContext(); ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(application); System.out.println(ac); ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); this.setCustomerService(cs); &#125; /** * 获取添加客户页面 * * @return */ public String addUICustomer() &#123; return \"addUICustomer\"; &#125; /** * 查询所有客户 * @return */ public String findAllCustomer() &#123; //调用业务层查询客户列表 customers = customerService.findAllCustomer(); return \"findAllCustomer\"; &#125; public List&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers; &#125;&#125; 2.5.2.3 测试1运行结果：查询客户列表测试通过。 2.6 优化配置2.6.1 配置spring的监听器12345678910111213141516171819在上面2.5.2.2小节中有这么一句： 由于动作类是多例的，每次都会创建容器，导致资源的浪费。一个应用应该只有一个容器问题： 如何解决呢？答案： 只要让容器在应用加载时创建，应用卸载时销毁就可以。问题： 我们怎么知道应用何时加载了呢？答案： ServletContext对象创建了，就表示当前应用已经被服务器加载了。问题： 我们怎么知道ServletContext对象创建了呢？答案： ServletContextListener监听器可以监听到ServletContext对象的创建和销毁。Spring框架为我们提供了一个监听器：ContextLoaderListener。它是ServletContextListener接口的实现类，负责监听ServletContext对象的创建，为我们创建容器，监听ServletContext对象的销毁，销毁容器。我们只需要配置上即可。ContextLoaderListener在spring-web-4.2.4.RELEASE.jar中 在web.xml中配置监听器： 123456789&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;当配置了此监听器后，就不需要使用Action的构造函数了，可以把构造函数那段删除了。此监听器只能读取WEB-INF目录中的名称为applicationContext.xml的配置文件。这显然限制了我们的配置。我们可以通过配置全局初始化参数的方式，指定spring配置文件的位置. 2.6.2 配置指定spring配置文件的位置12345&lt;!-- 手动指定spring的配置文件位置，需要使用ServletContext的初始化参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 2.6.3 分文件编写spring配置我们写到这里，其实搭建环境已经基本结束了，但是发现spring的配置文件杂乱无章，使我们在找配置的时候，很难一下找到。所以我们采用分配置文件编写的方式。 2.6.3.1 编写主配置文件引入其他配置文件1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 引入其他spring配置文件 --&gt; &lt;import resource=\"applicationContext-customer.xml\"/&gt; &lt;import resource=\"applicationContext-jdbc.xml\"/&gt; &lt;import resource=\"applicationContext-tx.xml\"/&gt;&lt;/beans&gt; 2.6.3.2 编写针对需求的配置文件applicationContext-customer.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"/&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.6.3.3 编写数据库连接的配置文件applicationContext-jdbc.xml123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置SessionFactory --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 使用的是hibernate主配置文件中的内容，我们只需要指定hibernate配置文件的位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:config/hibernate/hibernate.cfg.xml\"&gt;/&gt; &lt;/bean&gt;&lt;/beans&gt; 2.6.3.4 编写事务控制的配置文件applicationContext-tx.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 和事务相关的配置 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务的通知 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 配置事务的属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置aop --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;!-- 建立切入点表达式和事务通知的关联 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.6.4 配置指定struts2配置文件位置我们的spring和hibernate配置文件都存到了src/config/的对应包中了，只有struts2配置文件还在类的根路径下，它也可以通过配置的方式指定struts.xml的位置。配置的是过滤器的初始化参数。初始化参数的name和value都是固定写法。 1234567891011121314&lt;!-- 配置struts2和核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;!-- 手动指定struts2配置文件的位置：此处的配置绝大多数都是固定的--&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;struts-default.xml,struts-plugin.xml,config/struts/struts.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.6.5 分文件编写struts2配置文件当我们后面做的模块越来越多，struts2一个配置文件写起来也会杂乱无章，所以我们也可以把struts2的配置文件分开编写。 2.6.5.1 编写struts2的主配置文件struts.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name=\"struts.devMode\" value=\"true\"/&gt; &lt;!-- 配置公共包，有公共的配置就写在此处--&gt; &lt;package name=\"myDefault\" extends=\"struts-default\" abstract=\"true\"&gt; &lt;/package&gt; &lt;!-- 引入其他struts2配置文件 --&gt; &lt;include file=\"config/struts/struts-customer.xml\"&gt;&lt;/include&gt;&lt;/struts&gt; 2.6.5.2 针对不同模块编写不同的配置文件struts-customer.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 配置和客户管理相关的动作 --&gt; &lt;package name=\"customer\" extends=\"myDefault\" namespace=\"/customer\"&gt; &lt;action name=\"addUICustomer\" class=\"com.wgy.web.action.CustomerAction\" method=\"addUICustomer\"&gt; &lt;result name=\"addUICustomer\"&gt;/jsp/customer/add.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"findAllCustomer\" class=\"com.wgy.web.action.CustomerAction\" method=\"findAllCustomer\"&gt; &lt;result name=\"findAllCustomer\"&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 2.6.6 管理Action的两种方式2.6.6.1 让struts2自己来管理此种方式就是在action标签的class属性中提供动作类的全限定类名。 123&lt;action name=\"addUICustomer\" class=\"com.wgy.web.action.CustomerAction\" method=\"addUICustomer\"&gt; &lt;result name=\"addUICustomer\"&gt;/jsp/customer/add.jsp&lt;/result&gt;&lt;/action&gt; 2.6.6.2 让spring来管理（实际开发中采用的方式）此种方式就是在spring配置文件中配置Action，在struts2配置文件action标签的class属性里写bean的id。 spring配置文件： 1234&lt;!-- 配置action --&gt;&lt;bean id=\"customerAction\" class=\"com.wgy.web.action.CustomerAction\" scope=\"prototype\"&gt; &lt;property name=\"customerService\" ref=\"customerService\"&gt;&lt;/property&gt;&lt;/bean&gt; struts2配置文件： 123&lt;action name&#x3D;&quot;addUICustomer&quot; class&#x3D;&quot;customerAction&quot; method&#x3D;&quot;addUICustomer&quot;&gt; &lt;result name&#x3D;&quot;addUICustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3. 基于XML的引入式整合3.1 明确引入式整合就是把hibernate.cfg.xml中的配置都挪到spring的配置文件中 3.2 配置方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 和jdbc配置相关的 --&gt;&lt;!-- 配置sessionFactory --&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 第一部分：连接数据库的 用连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;!-- 数据库的方言 --&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;prop key=\"hibernate.format_sql\"&gt;false&lt;/prop&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;prop key=\"hibernate.current_session_context_class\"&gt; org.springframework.orm.hibernate5.SpringSessionContext &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 第三部分：映射文件的位置 mappingResources：它是一个注入string数组类型的数据。提供的是映射文件的位置。有几个映射文件，就需要写几个。 mappingDirectoryLocations：它是注入一个Resource类型的数组。提供的是映射文件所在的目录。此属性一般多用于一个项目有多个地方存放映射配置。 //服务端 server_domain //移动端 mobile_domain mappingLocations：它是注入一个Resource类型的数组。提供的映射文件的位置。它可以使用通配符。 --&gt; &lt;property name=\"mappingLocations\"&gt; &lt;array&gt; &lt;value&gt;classpath:com/wgy/domain/*.hbm.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/ssh\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt;&lt;/bean&gt; 4. 基于注解的整合4.1 明确 注解整合仍然使用上面的环境，就是把xml的配置全部换成注解 spring的注解整合有两种方式，一种是用xml文件，一种是纯注解。 hibernate注解整合是把实体类映射改为JPA注解映射 4.2 整合步骤-spring使用xml文件4.2.1 spring配置使用注解实现4.2.1.1 在spring配置文件中配置要扫描的包12&lt;!-- 配置spring运行要扫描的包 --&gt;&lt;context:component-scan base-package=\"com.wgy\"/&gt; 4.2.1.2 把action,service和dao都用注解配置12345678910/** * 客户的动作类 */@Controller(\"customerAction\")@Scope(\"prototype\")public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; @Autowired private ICustomerService customerService; //action中的方法不变&#125; 123456789/** * 客户的业务层实现类 */@Service(\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Autowired private ICustomerDao customerDao; //service中的方法不变&#125; 12345678910/** * 客户的持久层实现类 */@Repository(\"customerDao\")public class CustomerDaoImpl implements ICustomerDao &#123; //dao中必须自己定义HibernateTemplate，不能继承HibernateDaoSupport了 @Autowired private HibernateTemplate hibernateTemplate; //dao中的方法不变&#125; 4.2.1.3 在spring配置文件中配置HiernateTemplate1234&lt;!-- 配置hibernateTemplate --&gt;&lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate5.HibernateTemplate\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 4.2.1.4 在spring配置文件中配置事务管理器1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 4.2.1.5 在spring配置文件中开启spring对注解事务的支持12&lt;!-- 开启spring对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 4.2.1.6 在客户的业务层实现类上使用@Transactional注解123456789101112131415161718192021222324/** * 客户的业务层实现类 * * @author wgy */@Service(\"customerService\")@Transactional(readOnly = false, propagation = Propagation.REQUIRED)public class CustomerServiceImpl implements ICustomerService &#123; @Resource(name = \"customerDao\") private ICustomerDao customerDao; @Override @Transactional(readOnly = true, propagation = Propagation.SUPPORTS) public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125; @Override public void saveCustomer(Customer customer) &#123; customerDao.saveCustomer(customer); &#125;&#125; 4.2.2 hibernate映射使用注解配置实现4.2.2.1 实体类映射注解配置1234567891011121314151617181920212223242526272829/** * 客户的实体类 * JPA规范：java 持久化规范 * 注解全都是JPA规范的。 * 导包都需要导入javax.persistence包下的 * */@Entity@Table(name=\"cst_customer\")public class Customer implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"cust_id\") private Long custId; @Column(name=\"cust_name\") private String custName; @Column(name=\"cust_source\") private String custSource; @Column(name=\"cust_industry\") private String custIndustry; @Column(name=\"cust_level\") private String custLevel; @Column(name=\"cust_address\") private String custAddress; @Column(name=\"cust_phone\") private String custPhone; ...&#125; 4.2.2.2 spring中SessionFactory配置修改123456789101112131415161718192021222324252627282930&lt;!-- 配置sessionFactory --&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 第一部分：连接数据库的 用连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;!-- 数据库的方言 --&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;prop key=\"hibernate.format_sql\"&gt;false&lt;/prop&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;prop key=\"hibernate.current_session_context_class\"&gt; org.springframework.orm.hibernate5.SpringSessionContext &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 第三部分：指定实体类所在的包，当创建SessionFactory,会去该包中扫描实体类上的注解，从而生成映射配置--&gt; &lt;property name=\"packagesToScan\"&gt; &lt;array&gt; &lt;value&gt;com.wgy.domain&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 4.2.3 struts2配置使用注解实现4.2.3.1 导入struts2注解的jar包 4.2.3.2 使用注解配置Action1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 客户的动作类 */@Controller(\"customerAction\")@Scope(\"prototype\")//-------以下都是struts2的注解-----------@ParentPackage(\"struts-default\")//指定当前包的父包@Namespace(\"/customer\")//指定名称空间，访问当前action的所有方法都需要有名称空间@Results(&#123; @Result(name = \"addUICustomer\", type = \"dispatcher\", location = \"/jsp/customer/add.jsp\"), @Result(name = \"findAllCustomer\", type = \"dispatcher\", location = \"/jsp/customer/list.jsp\"), @Result(name = \"listCustomer\", type = \"redirectAction\", location = \"findAllCustomer\")&#125;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); private List&lt;Customer&gt; customers; @Resource(name = \"customerService\") private ICustomerService customerService; @Override public Customer getModel() &#123; return customer; &#125; /** * 查询所有客户 * @return */ @Action(\"findAllCustomer\") public String findAllCustomer()&#123; //调用业务层查询客户列表 customers = customerService.findAllCustomer(); return \"findAllCustomer\"; &#125; /** * 获取添加客户页面 * @return */ @Action(\"addUICustomer\") public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 添加客户 * @return */ @Action(\"addCustomer\") public String addCustomer()&#123; customerService.saveCustomer(customer); return \"listCustomer\"; &#125; public List&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers; &#125;&#125; 4.2.3.3 指定struts2开发模式12345678910111213&lt;!-- 配置struts2和核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.devMode&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Spring(四)","date":"2020-06-14T09:18:35.000Z","path":"archives/924a9eab.html","text":"1. Spring中的JdbcTemplate1.1 JdbcTemplate概述它是spring框架中提供的一个对象，是对原始Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类，入下图所示： 我们今天的主角在spring-jdbc-4.24.RELEASE.jar中，我们在导包的时候，除了要导入这个jar包外，还需要导入一个spring-tx-4.2.4.RELEASE.jar（它是和事务相关的）。 1.2 JdbcTemplate对象的创建我们可以参考它的源码，来一探究竟： 12345678910111213public JdbcTemplate() &#123;&#125;public JdbcTemplate(DataSource dataSource) &#123; setDataSource(dataSource); afterPropertiesSet();&#125;public JdbcTemplate(DataSource dataSource, boolean lazyInit) &#123; setDataSource(dataSource); setLazyInit(lazyInit); afterPropertiesSet();&#125; 除了默认构造函数之外，都需要提供一个数据源。既然有set方法，依据我们之前学过的依赖注入，我们可不可以在配置文件中配置呢？ 答案是肯定的。 1.3 Spring中配置数据源1.3.1 环境搭建 1.3.2 编写Spring的配置文件1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; 1.3.3 配置数据源我们之前已经接触过了两个数据源，一个是C3P0，一个是DBCP。要想使用这两数据源都需要导入对应的jar包。 1.3.3.1 配置C3P0数据源导包: 在Spring的配置文件中配置： 123456&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.3.3.2 配置DBCP数据源导包: 在Spring的配置文件中配置： 123456&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.3.3.3 配置spring内置数据源spring框架也提供了一个内置数据源，我们也可以使用spring的内置数据源，它就在spring-jdbc-4.2.4.REEASE.jar包中： 123456&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.3.4 将数据库连接的信息配置到属性文件中:定义属性文件 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc.username=rootjdbc.password=root 引入外部的属性文件 12345678一种方式:&lt;!-- 引入外部属性文件： --&gt;&lt;bean class&#x3D;&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name&#x3D;&quot;location&quot; value&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;二种方式:&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt; 1.4 JdbcTemplate的增删改查操作1.4.1 前期准备12345678910创建数据库：create database spring;use spring;创建表：create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci; 1.4.2 在spring配置文件中配置JdbcTemplate12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.4.3 最基本使用1234567891011public class JdbcTemplateDemo2 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 jt.execute(\"insert into account(name,money)values('eee',500)\"); &#125;&#125; 1.4.4 保存操作123456789101112public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //保存 jt.update(\"insert into account(name,money)values(?,?)\",\"fff\",5000); &#125;&#125; 1.4.5 更新操作123456789101112public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //修改 jt.update(\"update account set money = money-? where id = ?\",300,6); &#125;&#125; 1.4.6 删除操作123456789101112public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //删除 jt.update(\"delete from account where id = ?\",6); &#125;&#125; 1.4.7 查询所有操作1234567891011121314151617181920212223242526public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询所有 List&lt;Account&gt; accounts = jt.query(\"select * from account where money &gt; ? \",new AccountRowMapper(), 500); for(Account o : accounts)&#123; System.out.println(o); &#125; &#125;&#125;public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(\"id\")); account.setName(rs.getString(\"name\")); account.setMoney(rs.getFloat(\"money\")); return account; &#125;&#125; 123456789101112131415public class JdbcTemplateDemo3 &#123; public static void main(String[] args)&#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.跟id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询所有 List&lt;Account&gt; accounts = jt.query(\"select * from account where money &gt; ?\",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),1000); for(Account account : accounts)&#123; System.out.println(account); &#125; &#125;&#125; 1.4.8 查询一个操作1234567891011121314151617181920212223242526272829//使用RowMapper的方式：常用的方式public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询一个 List&lt;Account&gt; as = jt.query(\"select * from account where id = ? \", new AccountRowMapper(), 55); System.out.println(as.isEmpty()?\"没有结果\":as.get(0)); &#125;&#125;//使用ResultSetExtractor的方式:不常用的方式public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询一个 Account account = jt.query(\"select * from account where id = ?\",new AccountResultSetExtractor(),3); System.out.println(account); &#125;&#125; 1.4.9 查询返回一行一列操作1234567891011121314public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询返回一行一列：使用聚合函数，在不使用group by字句时，都是返回一行一列。最长用的就是分页中获取总记录条数 //queryForObject是spring 3.x之后的新方法，在spring2.x的时候，它的方法是多个：queryForInt queryForLong queryForShort Integer total = jt.queryForObject(\"select count(*) from account where money &gt; ? \",Integer.class,500); System.out.println(total); &#125;&#125; 1.5 在dao中使用JdbcTemplate1.5.1 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 1.5.2 第一种方式：在dao中定义JdbcTemplate123456789101112131415161718192021222324252627282930313233343536/** * 账户的持久层实现类 * 此版本的dao，需要给dao注入JdbcTemplate */public class AccountDaoImpl implements IAccountDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ? \",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where name = ? \",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一，不是只有一个账户对象\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set money = ? where id = ? \",account.getMoney(),account.getId()); &#125;&#125; 配置文件： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置一个dao --&gt; &lt;bean id=\"accountDao\" class=\"com.wgy.dao.impl.AccountDaoImpl\"&gt; &lt;!-- 注入jdbcTemplate --&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.5.3 第二种方式：让dao继承JdbcDaoSupportJdbcDaoSupport是spring框架为我们提供的一个类，该类中定义了一个JdbcTemplate对象，我们可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源：具体源码如下： 12345678910111213141516171819202122232425public abstract class JdbcDaoSupport extends DaoSupport &#123; //定义对象 private JdbcTemplate jdbcTemplate; //set方法注入数据源，判断是否注入了，注入了就创建JdbcTemplate public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; //如果提供了数据源就创建JdbcTemplate this.jdbcTemplate = createJdbcTemplate(dataSource); initTemplateConfig(); &#125; &#125; //使用数据源创建JdcbTemplate protected JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; //当然，我们也可以通过注入JdbcTemplate对象 public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; initTemplateConfig(); &#125; //使用getJdbcTmeplate方法获取操作模板对象 public final JdbcTemplate getJdbcTemplate() &#123; return this.jdbcTemplate; &#125;&#125; 1234567891011121314151617181920212223242526272829303132/** * 账户的持久层实现类 * 此版本dao，只需要给它的父类注入一个数据源 */public class AccountDaoImpl2 extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where id = ? \",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where name = ? \",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一，不是只有一个账户对象\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 getJdbcTemplate().update(\"update account set money = ? where id = ? \",account.getMoney(),account.getId()); &#125;&#125; 配置文件： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置dao2 --&gt; &lt;bean id=\"accountDao2\" class=\"com.wgy.dao.impl.AccountDaoImpl2\"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.5.4 两种方式有什么区别呢？ 第一种在Dao类中定义JdbcTemplate的方式，适用于所有配置方式（xml和注解都可以）。 第二种让Dao继承JdbcDaoSupport的方式，只能用于基于XML的方式，注解用不了。 2. Spring中的事务控制2.1 Spring中事务控制的API介绍2.1.1 PlatformTransactionManager此接口是spring的事务管理器，它里面提供了我们常用的操作事务的方法，如下图： 我们在开发中都是使用它的实现类，如下图： 123真正管理事务的对象 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用Spring JDBC或iBatis 进行持久化数据时使用 org.springframework.orm.hibernate3.HibernateTransactionManager 使用Hibernate版本进行持久化数据时使用 2.1.2 TransactionDefinition它是事务的定义信息对象，里面有如下方法： 2.1.2.1 事务的隔离级别 2.1.2.2 事务的传播行为1234567REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起NEVER:以非事务方式运行，如果当前存在事务，抛出异常NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类似的操作。 2.1.2.3 超时时间默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 2.1.2.4 是否是只读事务建议查询时设置为只读 2.1.3 TransactionStatus此接口提供的是事务具体的运行状态，方法介绍如下图： 2.2 基于XML的声明式事务控制（配置方式）2.2.1 环境搭建2.2.1.1 拷贝必要的jar 2.2.1.2 创建spring的配置文件并导入约束123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;/beans&gt; 2.2.1.3 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 2.2.1.4 编写业务层接口和实现类1234567891011121314151617181920/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 根据id查询账户信息 * @param id * @return */ Account findAccountById(Integer id);//查 /** * 转账 * @param sourceName 转出账户名称 * @param targeName 转入账户名称 * @param money 转账金额 */ void transfer(String sourceName,String targeName,Float money);//增删改&#125; 123456789101112131415161718192021222324252627282930/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 2.2.1.5 编写Dao接口和实现类123456789101112131415161718192021222324/** * 账户的持久层接口 */public interface IAccountDao &#123; /** * 根据id查询账户信息 * @param id * @return */ Account findAccountById(Integer id); /** * 根据名称查询账户信息 * @return */ Account findAccountByName(String name); /** * 更新账户信息 * @param account */ void updateAccount(Account account);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 账户的持久层实现类 * 此版本dao，只需要给它的父类注入一个数据源 */public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where id = ? \",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where name = ? \",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一，不是只有一个账户对象\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; getJdbcTemplate().update(\"update account set money = ? where id = ? \",account.getMoney(),account.getId()); &#125;&#125;/** * 账户的封装类RowMapper的实现类 */public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(\"id\")); account.setName(rs.getString(\"name\")); account.setMoney(rs.getFloat(\"money\")); return account; &#125;&#125; 2.2.1.6 在配置文件中配置业务层和持久层123456789101112131415161718&lt;!-- 配置service --&gt;&lt;bean id=\"accountService\" class=\"com.wgy.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 配置dao --&gt;&lt;bean id=\"accountDao\" class=\"com.wgy.dao.impl.AccountDaoImpl\"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 配置数据源 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.2 配置步骤2.2.2.1 配置事务管理器12345&lt;!-- 配置一个事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入DataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.2.2 配置事务的通知引用事务管理器123&lt;!-- 事务的配置 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt;&lt;/tx:advice&gt; 2.2.2.3 配置事务的属性12345678910111213&lt;!--在tx:advice标签内部 配置事务的属性 --&gt;&lt;tx:attributes&gt; &lt;!-- 指定方法名称：是业务核心方法 read-only：是否是只读事务。默认false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。 --&gt; &lt;tx:method name=\"*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt;&lt;/tx:attributes&gt; 2.2.2.4 配置AOP-切入点表达式12345&lt;!-- 配置aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt;&lt;/aop:config&gt; 2.2.2.5 配置切入点表达式和事务通知的对应关系12&lt;!-- 在aop:config标签内部：建立事务的通知和切入点表达式的关系 --&gt;&lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; 2.2.2.6 完整配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"accountService\" class=\"com.wgy.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id=\"accountDao\" class=\"com.wgy.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SPRING内置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring基于XML的声明式事务控制 --&gt; &lt;!-- 第一步：配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第二步：配置事务的通知 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 第四步：配置事务的属性 isolation：配置事务的隔离级别。默认值：DEFAULT，使用数据库的默认隔离级别。mysql是REPEATABLE_READ propagation：配置事务的传播行为。默认值是：REQUIRED。 一般的选择。（增删改方法）。当是查询方法时，选择SUPPORTS timeout：指定事务的超时时间。默认值是：-1，永不超时。当指定其他值时，以秒为单位 read-only：配置是否只读事务。默认值是：false，读写型事务。 当指定为true时，表示只读，只能用于查询方法。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常时，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当执行产生该异常时，事务不回滚。产生其他异常时，事务回滚。没有默认值，任何异常都回滚。 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 第三步：配置aop 要配的是：切入点表达式 通知和切入点表达式的关联 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt; &lt;!-- 配置事务通知和切入点表达式的关联 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.3 基于XML和注解组合使用的整合方式2.3.1 环境搭建2.3.1.1 拷贝必备的jar 2.3.1.2 spring的配置文件导入约束并配置扫描的包1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置spring要扫描的包 --&gt; &lt;context:component-scan base-package=\"com.wgy\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 2.3.1.3 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 2.3.1.4 业务层实现类使用注解让spring管理123456789101112131415161718192021222324252627/** * 账户的业务层实现类 */@Service(\"accountService\")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 2.3.1.5 Dao实现类使用注解让spring管理1234567891011121314151617181920212223242526272829303132@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountId); return list.isEmpty() ? null : list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where name = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (list.isEmpty()) &#123; //没有这个名称的账户 return null; &#125; if (list.size() &gt; 1) &#123; //结果集不唯一，不符合我们的约定 throw new RuntimeException(\"结果集不唯一，请检查数据\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set name=?,money=? where id=?\", account.getName(), account.getMoney(), account.getId()); &#125;&#125; 2.3.2 配置步骤2.3.2.1 配置数据源和JdbcTemplate123456789101112&lt;!-- 配置jdbcTemplate --&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置SPRING内置数据源 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.3.2.2 配置事务管理器并注入数据源1234&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.3.2.3 在业务层使用@Transactional注解1234567&lt;!-- 在需要事务的地方使用@Transactional注解 该注解可以写在接口上，类上和方法上。 写在接口上，表示该接口的所有实现类都有事务。 写在类上，表示该类中所有方法都有事务。 写在方法，表示该方法有事务。 优先级：就近原则。方法&gt;类&gt;接口--&gt; 12345678910111213141516171819202122232425262728@Service(\"accountService\")@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)//只读型public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; @Override @Transactional(propagation=Propagation.REQUIRED,readOnly=false)//读写型 public void transfer(String sourceName, String targetName, Float money) &#123; //1.根据名称查询账户信息 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); //2.转出账户减钱，转入账户加钱 source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); //3.更新账户信息 accountDao.updateAccount(source); int i = 1 / 0; accountDao.updateAccount(target); &#125;&#125; 2.3.2.4 在配置文件中开启spring对注解事务的支持12&lt;!-- 开启spring对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 2.4 基于纯注解的声明式事务控制（配置方式）2.4.1 环境搭建2.4.1.1 拷贝必备的jar包 2.4.1.2 创建一个类用于加载spring的配置并指定要扫描的包12345678/** * 用于初始化spring容器的配置类 */@Configuration@ComponentScan(basePackages=\"com.wgy\")public class SpringConfiguration &#123;&#125; 2.4.1.3 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 2.4.1.4 业务层实现类使用注解让spring管理123456789101112131415161718192021222324252627/** * 账户的业务层实现类 */@Service(\"accountService\")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 2.4.1.5 Dao实现类使用注解让spring管理1234567891011121314151617181920212223242526272829303132@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountId); return list.isEmpty() ? null : list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where name = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (list.isEmpty()) &#123; //没有这个名称的账户 return null; &#125; if (list.size() &gt; 1) &#123; //结果集不唯一，不符合我们的约定 throw new RuntimeException(\"结果集不唯一，请检查数据\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set name=?,money=? where id=?\", account.getName(), account.getMoney(), account.getId()); &#125;&#125; 2.4.2 配置步骤2.4.2.1 使用@Bean注解配置数据源和JdbcTemplate12345678910111213141516171819202122/** * 连接数据库的配置类 * * @author wgy */public class JdbcConfig &#123; @Bean(name = \"jdbcTemplate\") public JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = \"dataSource\") public DataSource createDataSource() &#123; DriverManagerDataSource ds = new DriverManagerDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; &#125;&#125; 2.4.2.2 使用@Bean注解配置配置事务管理器123456789101112/** * 事务控制的配置类 * * @author wgy */public class TransactionManager &#123; @Bean(name = \"transactionManager\") public PlatformTransactionManager createTransactionManager(DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 2.4.2.3 在业务层使用@Transactional注解1234567&lt;!-- 在需要事务的地方使用@Transactional注解 该注解可以写在接口上，类上和方法上。 写在接口上，表示该接口的所有实现类都有事务。 写在类上，表示该类中所有方法都有事务。 写在方法，表示该方法有事务。 优先级：就近原则。方法&gt;类&gt;接口--&gt; 12345678910111213141516171819202122232425262728@Service(\"accountService\")@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)//只读型public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; @Override @Transactional(propagation=Propagation.REQUIRED,readOnly=false)//读写型 public void transfer(String sourceName, String targetName, Float money) &#123; //1.根据名称查询账户信息 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); //2.转出账户减钱，转入账户加钱 source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); //3.更新账户信息 accountDao.updateAccount(source); int i = 1 / 0; accountDao.updateAccount(target); &#125;&#125; 2.4.2.4 使用@EnableTransactionManagement开启spring对注解事务的的支持123456789101112/** * spring的配置类，作用就是当bean.xml用 * * @author wgy */@Configuration@ComponentScan(\"com.wgy\")@Import(&#123;JdbcConfig.class, TransactionManager.class&#125;)@EnableTransactionManagementpublic class SpringConfiguration &#123;&#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Spring(三)","date":"2020-06-13T10:27:26.000Z","path":"archives/680971a4.html","text":"1. AOP的相关概念1.1 AOP概述1.1.1 什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.1.2 AOP的作用及优势作用： 在程序运行期间，不修改源码对已有方法进行增强。 优势： 减少重复代码 提高开发效率 维护方便 1.1.3 AOP的实现方式使用动态代理技术 1.2 AOP的具体应用1.2.1 案例中问题这是我们之前在struts2课程中做的一个完整的增删改查例子。下面是客户的业务层接口和实现类。 通过下面的代码，我们能看出什么问题吗? 123456789101112131415161718/** * 客户的业务层接口 */public interface ICustomerService &#123; /** * 保存客户 * @param customer */ void saveCustomer(Customer customer); /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 客户的业务层实现类 * 事务必须在此控制 * 业务层都是调用持久层的方法 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public void saveCustomer(Customer customer) &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); customerDao.saveCustomer(customer); tx.commit(); &#125;catch(Exception e)&#123; tx.rollback(); throw new RuntimeException(e); &#125; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); List&lt;Customer&gt; customers = customerDao.findAllCustomer(); tx.commit(); return customers; &#125;catch(Exception e)&#123; tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 上面代码的问题就是：我们的事务控制是重复性的代码。这还只是一个业务类，如果有多个业务了，每个业务类中都会有这些重复性的代码。 1.2.2 动态代理回顾1.2.2.1 动态代理的特点123字节码随用随创建，随用随加载。它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。装饰者模式就是静态代理的一种体现。 1.2.2.2 动态代理常用的有两种方式123456基于接口的动态代理 提供者：JDK官方的Proxy类。 要求：被代理类最少实现一个接口。基于子类的动态代理 提供者：第三方的CGLib，如果报asmxxxx异常，需要导入asm.jar。 要求：被代理类不能用final修饰的类（最终类）。 1.2.2.3 使用JDK官方的Proxy类创建代理对象 此处我们使用的是一个演员的例子： 在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。 而随着时间的推移，产生了一个新兴职业：经纪人（中间人），这个时候剧组再想找演员就需要通过经纪人来找了。下面我们就用代码演示出来。 1234567891011121314151617/** * 一个经纪公司的要求: * 能做基本的表演和危险的表演 */public interface IActor &#123; /** * 基本演出 * @param money */ public void basicAct(float money); /** * 危险演出 * @param money */ public void dangerAct(float money);&#125; 1234567891011121314/** * 一个演员 * 实现了接口，就表示具有接口中的方法实现。即：符合经纪公司的要求 */public class Actor implements IActor&#123; public void basicAct(float money)&#123; System.out.println(\"拿到钱，开始基本的表演：\"+money); &#125; public void dangerAct(float money)&#123; System.out.println(\"拿到钱，开始危险的表演：\"+money); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 模拟一个剧组 * * @author wgy */public class Client &#123; public static void main(String[] args) &#123; //一个剧组找演员 final Actor actor = new Actor(); /** * 动态代理： * 作用：不改变源码的基础上，对已有方法增强。（它是AOP思想的实现技术） * 分类： * 基于接口的动态代理： * 要求：被代理类最少实现一个接口 * 提供者：JDK官方 * 涉及的类：Proxy * 创建代理对象的方法：newProxyInstance(ClassLoader,Class[],InvocationHandler) * 参数的含义： * ClassLoader：类加载器。和被代理对象使用相同的类加载器。一般都是固定写法。 * Class[]：字节码数组。被代理类实现的接口。（要求代理对象和被代理对象具有相同的行为）。一般都是固定写法。 * InvocationHandler：它是一个接口，就是用于我们提供增强代码的。我们一般都是些一个该接口的实现类。实现类可以是匿名内部类。 * 它的含义就是：如何代理。此处的代码只能是谁用谁提供。 * 策略模式： * 使用要求：数据已经有了 * 目的明确 * 达成目标的过程就是策略。 * 在dbutils中的ResultSetHandler就是策略模式的具体应用。 * * 基于子类的动态代理 * */ IActor proxyActor = (IActor) Proxy.newProxyInstance(actor.getClass().getClassLoader(), actor.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 执行被代理对象的任何方法都会经过该方法，该方法有拦截的功能 * 方法的参数 * Object proxy：代理对象的引用。不一定每次都会有。 * Method method：当前执行的方法 * Object[] args：当前执行方法所需的参数 * 返回值： * 当前执行方法的返回值 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object rtValue = null; //1.取出执行方法中的参数：给的多少钱 Float money = (Float)args[0]; //2.判断当前执行的是什么方法：每个经纪公司对不同演出收费不一样，此处开始判断 if(\"basicAct\".equals(method.getName()))&#123; //基本演出，没有10000不演 if(money &gt; 10000)&#123; //执行方法（开始表演） //看上去剧组是给了20000，实际到演员手里只有10000 //这就是我们没有修改原来basicAct方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; if(\"dangerAct\".equals(method.getName()))&#123; //危险演出，没有50000不演 if(money &gt; 50000)&#123; //执行方法 //看上去剧组是给了60000，实际到演员手里只有30000 //这就是我们没有修改原来dangerAct方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;);// 没有经纪公司的时候，直接找演员。// actor.basicAct(1000f);// actor.dangerAct(5000f);// 剧组无法直接联系演员，而是由经纪公司找的演员 proxyActor.basicAct(20000); proxyActor.dangerAct(60000); &#125;&#125; 1.2.2.4 使用CGLib的Enhancer类创建代理对象还是那个演员的例子，只不过不让他实现接口。 12345678910111213141516171819202122232425/** * 一个演员 * * @author wgy */public class Actor &#123; /** * 基本的演出 * * @param money */ public void basicAct(float money) &#123; System.out.println(\"CGLIB拿到钱，开始基本的表演：\" + money); &#125; /** * 危险的表演 * * @param money */ public void dangerAct(float money) &#123; System.out.println(\"CGLIB拿到钱，开始危险的表演：\" + money); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 模拟一个剧组 * * @author wgy */public class Client &#123; public static void main(String[] args) &#123; final Actor actor = new Actor(); /** * 动态代理： * 作用：不改变源码的基础上，对已有方法增强。（它是AOP思想的实现技术） * 分类： * 基于接口的动态代理： * * 基于子类的动态代理： * 要求：被代理类不能是最终类。不能被final修饰 * 提供者：第三方CGLib * 涉及的类：Enhancer * 创建代理对象的方法：create(Class,Callback); * 参数的含义： * Class：被代理对象的字节码 * Callback：如何代理。它和InvocationHandler的作用是一样的。它也是一个接口，我们一般使用该接口的子接口MethodInterceptor * 在使用时我们也是创建该接口的匿名内部类。 * */ Actor cglibActor = (Actor) Enhancer.create(actor.getClass(), new MethodInterceptor() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。它和基于接口动态代理的invoke方法的作用是一模一样的。 * 方法的参数; * 前面三个和invoke方法的参数含义和作用都一样。 * MethodProxy methodProxy：当前执行方法的代理对象。一般不用 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object rtValue = null; //1.取出执行方法中的参数：给的多少钱 Float money = (Float)args[0]; //2.判断当前执行的是什么方法 if(\"basicAct\".equals(method.getName()))&#123; //基本演出 if(money &gt; 10000)&#123; //执行方法（开始表演） rtValue = method.invoke(actor, money/2); &#125; &#125; if(\"dangerAct\".equals(method.getName()))&#123; //危险演出 if(money &gt; 50000)&#123; //执行方法 rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;); cglibActor.basicAct(50000); cglibActor.dangerAct(100000); &#125;&#125; 1.2.3 解决案例中的问题思路只有一个：使用动态代理技术创建客户业务层的代理对象，在执行CustomerServiceImpl时，对里面的方法进行增强，加入事务的支持。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 用于创建客户业务层对象工厂（当然也可以创建其他业务层对象，只不过我们此处不做那么繁琐）*/public class BeanFactory &#123; /** * 获取客户业务层对象的代理对象 * @return */ public static ICustomerService getCustomerService() &#123; //定义客户业务层对象 final ICustomerService customerService = new CustomerServiceImpl(); //生成它的代理对象 ICustomerService proxyCustomerService = (ICustomerService) Proxy.newProxyInstance(customerService.getClass().getClassLoader() ,customerService.getClass().getInterfaces(), new InvocationHandler() &#123; //执行客户业务层任何方法，都会在此处被拦截，我们对那些方法增强，加入事务。 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String name = method.getName(); Object rtValue = null; try&#123; //开启事务 HibernateUtil.beginTransaction(); //执行操作 rtValue = method.invoke(customerService, args); //提交事务 HibernateUtil.commit(); &#125;catch(Exception e)&#123; //回滚事务 HibernateUtil.rollback(); e.printStackTrace(); &#125;finally&#123; //释放资源.hibernate在我们事务操作（提交/回滚）之后，已经帮我们关了。 //如果他没关，我们在此处关 &#125; return rtValue; &#125; &#125;); return proxyCustomerService; &#125;&#125; 1.3 Spring中的AOP1.3.1 关于代理的选择在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.3.2 AOP相关术语123456789101112131415161718Joinpoint(连接点): 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。Pointcut(切入点): 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。Advice(通知&#x2F;增强): 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。Introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。Target(目标对象): 代理的目标对象。Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。Proxy（代理）: 一个类被AOP织入增强后，就产生一个结果代理类。Aspect(切面): 是切入点和通知（引介）的结合。 1.3.3 学习spring中的AOP要明确的事123456a、开发阶段（我们做的） 编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。 把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP编程人员来做。 在配置文件中，声明切入点与通知间的关系，即切面。：AOP编程人员来做。b、运行阶段（Spring框架完成的） Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 2. 基于XML的AOP配置2.1 环境搭建2.1.1 准备客户的业务层和接口（需要增强的类）12345678910111213141516/** * 客户的业务层接口*/public interface ICustomerService &#123; /** * 保存客户 */ void saveCustomer(); /** * 修改客户 * @param i */ void updateCustomer(int i);&#125; 123456789101112131415/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"调用持久层，执行保存客户\"); &#125; @Override public void updateCustomer(int i) &#123; System.out.println(\"调用持久层，执行修改客户\"); &#125;&#125; 2.1.2 拷贝必备的jar包 2.1.3 创建spring的配置文件并导入约束12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 2.1.4 把客户的业务层配置到spring容器中12&lt;!-- 把资源交给spring来管理 --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"/&gt; 2.1.5 制作通知（增强的类）123456789101112131415/** * 一个用于记录日志的类 * * @author wgy */public class Logger &#123; /** * 记录日志的操作 * 计划让其在业务核心方法（切入点方法）执行之前执行 */ public void beforePrintLog() &#123; System.out.println(\"Logger中的printLog方法开始记录日志了。。。。\"); &#125;&#125; 2.2 配置步骤2.2.1 把通知类用bean标签配置起来12&lt;!-- 把通知类也交给spring来管理 --&gt;&lt;bean id=\"logger\" class=\"com.wgy.util.Logger\"&gt;&lt;/bean&gt; 2.2.2 使用aop:config声明aop配置1234&lt;!-- aop的配置 --&gt;&lt;aop:config&gt; &lt;!-- 配置的代码都写在此处 --&gt; &lt;/aop:config&gt; 2.2.3 使用aop:aspect配置切面1234567&lt;!-- 配置切面 ：此标签要出现在aop:config内部 id：给切面提供一个唯一标识 ref：引用的是通知类的bean的id--&gt;&lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!--配置通知的类型要写在此处--&gt;&lt;/aop:aspect&gt; 2.2.4 使用aop:before配置前置通知12345&lt;!-- 用于配置前置通知：指定增强的方法在切入点方法之前执行 method:用于指定通知类中的增强方法名称 ponitcut-ref：用于指定切入点的表达式的引用 --&gt;&lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"/&gt; 2.2.5 使用aop:pointcut配置切入点表达式1&lt;aop:pointcut expression=\"execution(public void com.wgy.service.impl.CustomerServiceImpl.saveCustomer())\" id=\"pt1\"/&gt; 2.3 切入点表达式说明123456789101112131415161718192021222324252627execution: 匹配方法的执行(常用) execution(表达式)表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))写法说明： 全匹配方式： public void com.wgy.service.impl.CustomerServiceImpl.saveCustomer() 访问修饰符可以省略 void com.wgy.service.impl.CustomerServiceImpl.saveCustomer() 返回值可以使用*号，表示任意返回值 * com.wgy.service.impl.CustomerServiceImpl.saveCustomer() 包名可以使用*号，表示任意包，但是有几级包，需要写几个* * *.*.*.*.CustomerServiceImpl.saveCustomer() 使用..来表示当前包，及其子包 * com..CustomerServiceImpl.saveCustomer() 类名可以使用*号，表示任意类 * com..*.saveCustomer() 方法名可以使用*号，表示任意方法 * com..*.*() 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数 * com..*.*(*) 参数列表可以使用..表示有无参数均可，有参数可以是任意类型 * com..*.*(..) 全通配方式： * *..*.*(..) 实际开发中，我们一般情况下，我们都是对业务层方法进行增强： 所以写法：* com.wgy.service.impl.*.*(..) 2.4 完整配置123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt;&lt;/bean&gt; &lt;!-- 基于xml的aop配置步骤 ：要想使用spring的aop，必须导入aop的jar包--&gt; &lt;!-- 第一步：把通知类交给spring来管理 --&gt; &lt;bean id=\"logger\" class=\"com.wgy.utils.Logger\"&gt;&lt;/bean&gt; &lt;!-- 第二步：导入aop名称空间，并且使用aop:config开始aop的配置 --&gt; &lt;aop:config&gt; &lt;!-- 定义通用的切入点表达式，如果写在aop:aspct标签外部，则表示所有切面可用 --&gt; &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt; &lt;!-- 第三步：使用aop:aspect配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 第四步：配置通知的类型，指定增强的方法何时执行。--&gt; &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:before&gt; &lt;!-- 定义通用的切入点表达式：如果是写在了aop:aspect标签内部，则表示只有当前切面可用 &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt;--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.5 通知的类型2.5.1 类型说明1234567891011121314151617&lt;!-- 配置通知的类型 aop:before： 用于配置前置通知。前置通知的执行时间点：切入点方法执行之前执行 aop:after-returning： 用于配置后置通知。后置通知的执行时间点：切入点方法正常执行之后。它和异常通知只能有一个执行 aop:after-throwing 用于配置异常通知。异常通知的执行时间点：切入点方法执行产生异常后执行。它和后置通知只能执行一个。 aop:after 用于配置最终通知。最终通知的执行时间点：无论切入点方法执行时是否有异常，它都会在其后面执行。 aop:around 用于配置环绕通知。他和前面四个不一样，他不是用于指定通知方法何时执行的。--&gt; &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:around method=\"aroundPringLog\" pointcut-ref=\"pt1\"/&gt; 2.5.2 环绕通知的特殊说明1234567891011121314151617181920212223242526272829/** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而环绕通知里的代码执行了。 * 分析： * 由动态代理可知，环绕通知指的是invoke方法，并且里面有明确的切入点方法调用。而我们现在的环绕通知没有明确切入点方法调用。 * 解决： * spring为我们提供了一个接口：ProceedingJoinPoint。该接口可以作为环绕通知的方法参数来使用。 * 在程序运行时，spring框架会为我们提供该接口的实现类，供我们使用。 * 该接口中有一个方法，proceed()，它的作用就等同于method.invoke方法，就是明确调用业务层核心方法（切入点方法） * * 环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制通知方法什么时候执行的方式。 */public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。前置\"); rtValue = pjp.proceed(); System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。后置\"); &#125; catch (Throwable e) &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。异常\"); e.printStackTrace(); &#125;finally&#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。最终\"); &#125; return rtValue;&#125; 3. 基于注解的AOP配置3.1 环境搭建3.1.1 准备客户的业务层和接口（需要增强的类）12345678910111213141516/** * 客户的业务层接口*/public interface ICustomerService &#123; /** * 保存客户 */ void saveCustomer(); /** * 修改客户 * @param i */ void updateCustomer(int i);&#125; 123456789101112131415/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"调用持久层，执行保存客户\"); &#125; @Override public void updateCustomer(int i) &#123; System.out.println(\"调用持久层，执行修改客户\"); &#125;&#125; 3.1.2 拷贝必备的jar包 3.1.3 创建spring的配置文件并导入约束12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;/beans&gt; 3.1.4 把资源使用注解让spring来管理123456789101112131415/** * 客户的业务层实现类 */@Service(\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"调用持久层，执行保存客户\"); &#125; @Override public void updateCustomer(int i) &#123; System.out.println(\"调用持久层，执行修改客户\"); &#125;&#125; 3.1.5 在配置文件中指定spring要扫描的包12&lt;!-- 告知spring，在创建容器时要扫描的包 --&gt;&lt;context:component-scan base-package=\"com.wgy\"&gt;&lt;/context:component-scan&gt; 3.2 配置步骤3.2.1 把通知类也使用注解配置1234567/** * 一个记录日志的工具类 */@Component(\"logger\")public class Logger &#123;&#125; 3.2.2 在通知类上使用@Aspect注解声明为切面12345678/** * 一个记录日志的工具类 */@Component(\"logger\")@Aspect//表明当前类是一个切面类public class Logger &#123; &#125; 3.2.3 在增强的方法上使用注解配置通知1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 一个用于记录日志的类 * * @author wgy */@Component(\"logger\")@Aspect//配置了切面public class Logger &#123; /** * 指定切入点表达式 */ @Pointcut(\"execution(* com.wgy.service.impl.*.*(..))\") private void pt1()&#123;&#125; /** * 前置通知 */// @Before(\"execution(* com.wgy.service.impl.*.*(..))\") public void beforePrintLog() &#123; System.out.println(\"前置：Logger中的beforePrintLog方法开始记录日志了。。。。\"); &#125; /** * 后置通知 */// @AfterReturning(\"pt1()\") public void afterReturningPrintLog() &#123; System.out.println(\"后置：Logger中的afterReturningPrintLog方法开始记录日志了。。。。\"); &#125; /** * 异常通知 */// @AfterThrowing(\"pt1()\") public void afterThrowingPrintLog() &#123; System.out.println(\"异常：Logger中的afterThrowingPrintLog方法开始记录日志了。。。。\"); &#125; /** * 最终通知 */// @After(\"pt1()\") public void afterPrintLog() &#123; System.out.println(\"最终：Logger中的afterPrintLog方法开始记录日志了。。。。\"); &#125; /** * 环绕通知 */ @Around(\"pt1()\") public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。前置\"); rtValue = pjp.proceed(); System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。后置\"); &#125; catch (Throwable e) &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。异常\"); e.printStackTrace(); &#125;finally&#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。最终\"); &#125; return rtValue; &#125;&#125; 3.2.4 在spring配置文件中开启spring对注解AOP的支持12&lt;!-- 开启spring对注解AOP的支持 --&gt;&lt;aop:aspectj-autoproxy/&gt; 3.3 不使用XML的配置方式123456@Configuration@ComponentScan(basePackages=\"com.wgy\")@EnableAspectJAutoProxypublic class SpringConfiguration &#123; &#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Spring(二)","date":"2020-06-11T06:53:10.000Z","path":"archives/16fa518f.html","text":"1. 基于注解的IOC配置1.1 写在最前学习基于注解的IoC配置，大家脑海里首先得有一个认知，即注解配置和xml配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 关于实际的开发中到底使用xml还是注解，每家公司有着不同的使用习惯。所以这两种配置方式我们都需要掌握。 1.2 环境搭建1.2.1 拷贝必备jar包注意：在基于xml的配置中，多拷贝一个aop的jar包。如下图： 1.2.2 在类的根路径下创建任意名称的xml文件12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 1.2.3 使用@Component注解配置管理的资源12345678910111213/** * 客户的业务层实现类 * * @author wgy */@Component(value=\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"执行了保存客户\"); &#125;&#125; 1.2.4 在Spring的配置文件中开启Spring对注解ioc的支持12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 告知spring在创建容器时要扫描的包。当配置了此标签之后，spring创建容器就会去指定的包及其子包下找对应的注解 标签是在一个context的名称空间里，所以必须先导入context名称空间 --&gt; &lt;context:component-scan base-package=\"com.wgy\"/&gt;&lt;/beans&gt; 1.3 常用注解1.3.1 用于创建bean对象1234567891011121314相当于：&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot;&gt;@Component 作用：就相当于配置了一个bean标签。 它能出现的位置：类上面 属性： value：含义是指定bean的id。当不写时，它有默认值，默认值是：当前类的短名首字母改小写。 由此注解衍生的三个注解： @Controller 一般用于表现的注解 @Service 一般用于业务层 @Repository 一般用于持久层 他们和@Component的作用及属性都是一模一样 细节：如果注解中有且只有一个属性要赋值时，且名称是value，value在赋值是可以不写。 1.3.2 用于注入数据的1234567891011121314151617181920212223242526相当于：&lt;property name&#x3D;&quot;&quot; ref&#x3D;&quot;&quot;&gt; &lt;property name&#x3D;&quot;&quot; value&#x3D;&quot;&quot;&gt;@Autowired 作用：自动按照类型注入。只要有唯一的类型匹配就能注入成功。 如果注入的bean在容器中类型不唯一时，它会把变量名称作为bean的id，在容器中查找，找到后也能注入成功。 如果没有找到一致的bean的id，则报错。 当我们使用注解注入时，set方法就不是必须的了。 @Qualifier 作用：在自动按照类型注入的基础之上，再按照bean的id注入。 它在给类成员注入数据时，不能独立使用。但是再给方法的形参注入数据时，可以独立使用。 属性： value：用于指定bean的id。 @Resource 作用：直接按照bean的id注入。 属性： name：用于指定bean的id。 以上三个注解都是用于注入其他bean类型的。用于注入基本类型和String类型需要使用Value@Value: 作用：用于注入基本类型和String类型数据。它可以借助Spring的el表达式读取properties文件中的配置。 属性： value：用于指定要注入的数据 1.3.3 用于改变作用范围的1234567相当于：&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot; scope&#x3D;&quot;&quot;&gt;@Scope 作用：用于改变bean的作用范围 属性： value：用于指定范围的取值。 取值和xml中scope属性的取值是一样的。singleton prototype request session globalsession 1.3.4 和生命周期相关的123456789相当于：&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot; init-method&#x3D;&quot;&quot; destroy-method&#x3D;&quot;&quot; &#x2F;&gt;@PostConstruct 作用： 用于指定初始化方法。@PreDestroy 作用： 用于指定销毁方法。 1.3.5 代码示例持久层 123456789101112131415161718192021222324/** * 客户的业务层实现类 * * @author wgy */@Service(\"customerService\")@Scope(\"singleton\")public class CustomerServiceImpl implements ICustomerService &#123; @Value(\"泰斯特\") private String name;// @Autowired// @Qualifier(\"customerDao1\") @Resource(name=\"customerDao\") private ICustomerDao customerDao = null; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层......\"+name); customerDao.saveCustomer(); &#125;&#125; 持久层 1234567891011121314/** * 模拟客户的持久层实现类 * * @author wgy */@Repository(\"customerDao\")public class CustomerDaoImpl implements ICustomerDao &#123; @Override public void saveCustomer() &#123; System.out.println(\"持久层保存了客户\"); &#125;&#125; 1.3.6 关于Spring注解和XML的选择问题1234注解的优势： 配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。XML的优势： 修改时，不用改源码。不涉及重新编译和部署。 Spring管理Bean方式的比较： 1.4 Spring的纯注解配置1.4.1 待改造的问题我们发现，之所以我们现在离不开xml配置文件，是因为我们有一句很关键的配置： 1234&lt;!-- 告知spring在创建容器时要扫描的包。当配置了此标签之后，spring创建容器就会去指定的包及其子包下找对应的注解 标签是在一个context的名称空间里，所以必须先导入context名称空间--&gt;&lt;context:component-scan base-package&#x3D;&quot;com.wgy&quot;&#x2F;&gt; 如果他要也能用注解配置，那么我们就可以脱离xml文件了。 1.4.2 使用注解配置要扫描的包创建配置类： 1234567891011/** * 一个spring的配置类 * 它的作用就相当于bean.xml * * @author wgy */@Configuration//它就是把当前类看成是spring的配置类@ComponentScan(&#123;\"com.wgy\"&#125;)//配置要扫描的包public class SpringConfiguration &#123; &#125; 测试类获取容器: 123456789public static void main(String[] args) &#123; //1.获取容器：由于我们已经没有了xml文件，所以再用读取xml方式就不能用了。 //这时需要指定加载哪个类上的注解 ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); //2.根据id获取对象 ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); cs.saveCustomer();&#125; 1.4.3 新注解说明1.4.3.1 @Configuration12345@Configuration 作用： 用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class)。 属性： value:用于指定配置类的字节码 1.4.3.2 @ComponentScan123456@ComponentScan 作用： 用于指定spring在初始化容器时要扫描的包。作用和在spring的xml配置文件中的： &lt;context:component-scan base-package&#x3D;&quot;com.wgy&quot;&#x2F;&gt;是一样的。 属性： basePackages：用于指定要扫描的包。和该注解中的value属性作用一样。 1.4.3.3 @PropertySource12345@PropertySource 作用： 用于加载.properties文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties配置文件中，就可以使用此注解指定properties配置文件的位置。 属性： value[]：用于指定properties文件位置。如果是在类路径下，需要写上classpath: 1.4.3.4 @Import12345@Import 作用： 用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration注解。当然，写上也没问题。 属性： value[]：用于指定其他配置类的字节码。 1.4.3.5 @Bean12345@Bean 作用： 该注解只能写在方法上，表明使用此方法创建一个对象，并且放入spring容器。它就相当于我们之前在xml配置中介绍的factory-bean和factory-method。 属性： name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id）。 1.4.3.6 代码示例jdbcConfig.properties: 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc.username=rootjdbc.password=root Jdbc的配置类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Jdbc的配置类 * * @author wgy */public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean(name = \"runner\")//它是把方法的返回值存入Spring容器中。该注解有一个属性，name：用于指定bean的id。当不指定时它有默认值，默认值是方法的名称。 public QueryRunner createQueryRunner(@Qualifier(\"ds1\") DataSource dataSource) &#123; return new QueryRunner(dataSource); &#125; @Bean(name = \"ds\") public DataSource createDataSource() &#123; try &#123; System.out.println(driver);//com.mysql.jdbc.Driver ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; @Bean(name = \"ds1\") public DataSource createDataSource1() &#123; try &#123; System.out.println(url); ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 配置类: 123456789101112131415161718192021222324252627/** * 一个spring的配置类 * 它的作用就相当于bean.xml * * @author wgy */@Configuration//它就是把当前类看成是spring的配置类@ComponentScan(&#123;\"com.wgy\"&#125;)@Import(&#123;JdbcConfig.class&#125;)//导入其他配置类@PropertySource(&#123;\"classpath:config/jdbcConfig.properties\"&#125;)public class SpringConfiguration &#123; /** * Spring EL表达式失效问题： * 目前使用的版本是4.2.4,在spring4.3以前都需要提供一个占位符配置器： * PropertySourcesPlaceholderConfigurer * 而在spring4.3以后，则不需要提供。 * 提供的方式如下：（在SpringConfiguration或JdbcConfig中配置均可） * * @return */ @Bean public static PropertySourcesPlaceholderConfigurer createPropertySourcesPlaceholderConfigurer()&#123; return new PropertySourcesPlaceholderConfigurer(); &#125;&#125; 2. Spring整合Junit2.1 准备测试环境2.1.1 创建业务层接口实现类123456789101112/** * 客户的业务层接口 */public interface ICustomerService &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao; public void setCustomerDao(ICustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125;&#125; 2.1.2 创建持久层接口实现类123456789101112/** * 客户的持久层接口 */public interface ICustomerDao &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 123456789101112/** * 客户的持久层实现类 */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; System.out.println(\"查询了所有客户\"); return null; &#125;&#125; 2.1.3 导入junit的jar包 2.1.4 编写测试类123456789101112/** * 测试客户的业务层和持久层 */public class CustomerServiceTest &#123; private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125;&#125; 2.2 使用xml配置步骤2.2.1 xml文件中的配置123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 把资源交给spring来管理 --&gt; &lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.2.2 拷贝整合junit的必备jar包 2.2.3 使用@RunWith注解替换原有运行器1234567891011@RunWith(SpringJUnit4ClassRunner.class)public class CustomerServiceTest &#123; private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125; &#125; 2.2.4 使用@ContextConfiguration指定spring配置文件的位置123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:bean.xml\"&#125;)public class CustomerServiceTest &#123; private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125; &#125; 2.2.5 使用@Autowired给测试类中的变量注入数据12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:bean.xml\"&#125;)public class CustomerServiceTest &#123; @Autowired private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125;&#125; 2.3 使用纯注解配置步骤2.3.1 拷贝整合junit的必备jar 2.3.2 把资源都用注解管理123456789101112131415/** * 客户的业务层实现类 */@Service(\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Autowired private ICustomerDao customerDao; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125;&#125; 12345678910111213/** * 客户的持久层实现类 */@Repository(\"customerDao\")public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; System.out.println(\"查询了所有客户\"); return null; &#125;&#125; 2.3.3 使用注解配置方式创建Spring容器12345678910111213@Configuration@ComponentScan(basePackages=&#123;\"com.wgy\"&#125;)public class CustomerServiceTest &#123; @Autowired private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125;&#125; 2.3.4 使用RunWith注解和ContextConfiguration注解配置123456789101112131415@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=&#123;CustomerServiceTest.class&#125;)@Configuration@ComponentScan(basePackages=&#123;\"com.wgy\"&#125;)public class CustomerServiceTest &#123; @Autowired private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125; &#125; 2.4 为什么不把测试类配到xml中 当我们在xml中配置了一个bean，Spring加载配置文件创建容器时，就会创建对象。 测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Spring(一)","date":"2020-06-10T15:26:00.000Z","path":"archives/b9cbcaed.html","text":"1. Spring概述1.1 Spring概述1.1.1 Spring介绍Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 1.1.2 Spring的发展历程1997年IBM提出了EJB的思想 1998年，SUN制定开发标准规范EJB1.0 1999年，EJB1.1发布 2001年，EJB2.0发布 2003年，EJB2.1发布 2006年，EJB3.0发布 Rod Johnson（spring之父） ​ Expert One-to-One J2EE Design and Development(2002) ​ 阐述了J2EE使用EJB开发设计的优点及解决方案 ​ Expert One-to-One J2EE Development without EJB(2004) ​ 阐述了J2EE开发不使用EJB的解决方式（Spring雏形） 1.1.3 Spring的优势方便解耦，简化开发 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀框架 Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。 降低JavaEE API的使用难度 Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 Java源码是经典学习范例 Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。 1.1.4 Spring的体系结构 1.2 程序的耦合和解耦1.2.1 什么是程序的耦合我们在开发中，会写很多的类，而有些类之间不可避免的产生依赖关系，这种依赖关系称之为耦合。 有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。请看下面的示例代码： 1234567/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); &#125; 上面的代码表示：业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。这种依赖关系就是我们可以通过优化代码解决的。 再比如： 下面的代码中，我们的类依赖了MySQL的具体驱动类，如果这时候更换了数据库品牌，我们需要改源码来修改数据库驱动。这显然不是我们想要的。 12345678910111213141516171819202122232425public class JdbcDemo1 &#123; /** * JDBC操作数据库的基本入门中存在什么问题？ * 导致驱动注册两次是个问题，但不是严重的。 * 严重的问题：是当前类和mysql的驱动类有很强的依赖关系。 * 当我们没有驱动类的时候，连编译都不让。 * 那这种依赖关系，就叫做程序的耦合 * * 我们在开发中，理想的状态应该是： * 我们应该尽力达到的：编译时不依赖，运行时才依赖。 * * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接 //3.获取预处理sql语句对象 //4.获取结果集 //5.遍历结果集 &#125;&#125; 1.2.2 解决程序耦合的思路当是我们讲解jdbc时，是通过反射来注册驱动的，代码如下： 1Class.forName(\"com.mysql.jdbc.Driver\"); 这时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除mysql的驱动jar包，依然可以编译。但是因为没有驱动类，所以不能运行。 不过，此处也有个问题，就是我们反射类对象的全限定类名字符串是在java类中写死的，一旦要改还是要修改源码。 解决这个问题也很简单，使用配置文件配置。 1.2.3 工厂模式解耦在实际开发中我们可以把所有的dao和service和action对象使用配置文件配置起来，当启动服务器应用加载的时候，通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 1.2.4 控制反转-Inversion Of Control上面解耦的思路有2个问题： 1、存哪去？ 分析：由于我们是很多对象，肯定要找个集合来存。这时候有Map和List供选择。 ​ 到底选Map还是List就看我们有没有查找需求。有查找需求，选Map。 所以我们的答案就是： ​ 在应用加载时，创建一个Map，用于存放action，Service和dao对象。 ​ 我们把这个map称之为容器。 2、还是没解释什么是工厂？ 工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 原来： ​ 我们在获取对象时，都是采用new的方式。是主动的。 现在： ​ 我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。 这种被动接收的方式获取对象的思想就是控制反转，它是Spring框架的核心之一。 它的作用只有一个：削减计算机程序的耦合。 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 2. 使用Spring的IOC解决程序耦合2.1 案例的前期准备本章我们使用的案例是，客户的业务层和持久层的依赖关系解决。在开始Spring的配置之前，我们要先准备一下环境。由于我们是使用Spring解决依赖关系，并不是真正的要做增伤改查操作，所以此时我们没必要写实体类。并且我们在此处使用的是java工程，不是java web工程。 2.1.1 准备Spring的开发包1234567官网：http:&#x2F;&#x2F;spring.io&#x2F; 下载地址：http:&#x2F;&#x2F;repo.springsource.org&#x2F;libs-release-local&#x2F;org&#x2F;springframework&#x2F;spring解压:(Spring目录结构:) * docs :API和开发规范. * libs :jar包和源码. * schema :约束. 2.1.2 创建业务层接口和实现类123456789101112/** * 模拟：客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 保存客户 */ void saveCustomer();&#125; 12345678910111213141516/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl();//此处有依赖关系 @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\"); customerDao.saveCustomer(); &#125;&#125; 2.1.3 创建持久层接口和实现类12345678910111213/** * 模拟一个客户dao * * @author wgy */public interface ICustomerDao &#123; /** * 保存客户 */ void saveCustomer();&#125; 12345678910111213/** * 模拟客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public void saveCustomer() &#123; System.out.println(\"持久层保存了客户\"); &#125;&#125; 2.2 基于XML的配置（入门案例）2.2.1 拷贝必备的jar包 2.2.2 在类根路径下创建任意名称的xml文件12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 导入schema约束约束的位置在: ..\\spring-framework-4.2.4.RELEASE\\docs\\spring-framework-reference\\html\\xsd-configuration.html文件中。--&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 2.2.3 把资源交给spring来管理12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置资源：把对象的创建交给spring来管理 --&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"/&gt; &lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"/&gt;&lt;/beans&gt; 2.2.4 测试配置是否成功123456789101112131415161718192021/** * spring的入门案例 * * @author wgy */public class Client &#123; /** * ClassPahtXmlApplicationContext：它是只能加载类路径下的配置文件 我们用这个 * FileSystemXmlApplicationContext：它是可以加载磁盘任意位置的配置文件 * * @param args */ public static void main(String[] args) &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据bean的id获取对象 ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); cs.saveCustomer(); &#125;&#125; 2.3 Spring基于XML的IOC细节2.3.1 Spring中工厂的类结构图 2.3.1.1 Bean创建的两种规则1234BeanFactory: 提供的是一种延迟加载思想来创建bean对象。bean对象什么时候用什么时候创建ApplicationContext 提供的是一种立即加载思想来创建bean对象。只要一解析完配置文件，就立马创建bean对象。 123456789public static void main(String[] args) &#123; //1.获取容器 Resource resource = new ClassPathResource(\"bean.xml\"); BeanFactory factory = new XmlBeanFactory(resource); //2.根据bean的id获取对象 ICustomerService cs = (ICustomerService) factory.getBean(\"customerService\"); cs.saveCustomer();&#125; 2.3.2 IOC中bean标签和管理对象细节2.3.2.1 bean标签12345678910111213作用： 用于配置对象让Spring来创建的。 默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。属性： id：给对象在容器中提供一个唯一标识。用于获取对象。 class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。 scope：指定对象的作用范围。 init-method：指定类中的初始化方法名称。 destroy-method：指定类中销毁方法名称。 &lt;bean id&#x3D;&quot;customerService&quot; class&#x3D;&quot;com.wgy.service.impl.CustomerServiceImpl&quot; scope&#x3D;&quot;singleton&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destroy&quot;&gt;&lt;&#x2F;bean&gt; 12345678910111213141516171819202122232425/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; public CustomerServiceImpl() &#123; System.out.println(\"bean对象创建了\"); &#125; public void init()&#123; System.out.println(\"对象初始化了\"); &#125; public void destroy()&#123; System.out.println(\"对象销毁了\"); &#125; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\"); &#125;&#125; 2.3.2.2 Bean的作用范围123456789Bean的作用范围： 它是可以通过配置的方式来调整作用范围。 配置的属性：bean标签的scope属性。 属性的取值： singleton：单例的（默认值） prototype：多例的（当我们让spring接管struts2的action创建时，action必须配置此值） request：作用范围是一次请求，和当前请求的转发。 session：作用范围是一次会话。 globalsession ：作用范围是一次全局会话。 2.3.2.3 Bean的生命周期123456789101112Bean的生命周期： 涉及bean标签的两个属性： init-method destroy-method 单例： 出生：容器创建，对象就出生了。 活着：只要容器在，对象就一直存在。 死亡：容器销毁，对象消亡。 多例： 出生：每次使用时，创建对象 活着：只要对象在使用中，就一直活着 死亡：当对象长时间不使用，并且也没有别的对象引用时，由java的垃圾回收器回收。 2.3.2.4 Bean的三种创建方式第一种方式：调用默认无参构造函数创建 此种方式用的最多 1234&lt;!--在默认情况下： 它会根据默认无参构造函数来创建类对象。如果bean中没有默认无参构造函数，则创建失败，会报异常 --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"/&gt; 第二种方式：使用静态工厂中的方法创建对象 1234567891011/** * 模拟一个静态工厂 * * @author wgy */public class StaticFactory &#123; public static ICustomerService getCustomerService() &#123; return new CustomerServiceImpl(); &#125;&#125; 123456789&lt;!-- 此种方式是: 使用StaticFactory类中的静态方法getCustomerService创建对象，并存入Spring容器 id属性：指定bean的id，用于从容器中获取 class属性：指定静态工厂的全限定类名 factory-method属性：指定生产对象的静态方法 --&gt;&lt;bean id=\"staticCustomerService\" class=\"com.wgy.factory.StaticFactory\" factory-method=\"getCustomerService\"&gt;&lt;/bean&gt; 第三种方式：使用实例工厂中的方法创建 1234567891011/** * 模拟一个实例工厂 * * @author wgy */public class InstanceFactory &#123; public ICustomerService getCustomerService() &#123; return new CustomerServiceImpl(); &#125;&#125; 12345678910&lt;!-- 此种方式是： 先把工厂的创建交给Spring来管理。 然后在使用工厂的bean来调用里面的方法 factory-bean属性：用于指定实例工厂bean的id。 factory-method属性：用于指定实例工厂中创建对象的方法。--&gt;&lt;bean id=\"instancFactory\" class=\"com.wgy.factory.InstanceFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"instanceCustomerService\" factory-bean=\"instancFactory\" factory-method=\"getCustomerService\"&gt;&lt;/bean&gt; 2.3.3 Spring的依赖注入它是spring框架核心ioc的具体实现方式。简单的说，就是坐等框架把对象传入，而不用我们自己去获取。 123456789Spring的依赖注入： 注入的方式有3三种： 第一种：使用构造函数注入 第二种：使用set方法注入 第三种：使用注解注入 注入的数据类型有3类： 第一类：基本类型和String类型 第二类：其他bean类型（必须是在spring的配置文件中出现过的bean） 第三类：复杂类型（集合类型） 2.3.3.1 构造函数注入就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置的方式，让Spring框架来为我们注入。具体代码如下： 123456789101112131415161718192021222324/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private String driver; private Integer port; private Date today; //以上三个类成员，没有具体的实际意义，只是用于演示注入。 public CustomerServiceImpl(String driver, Integer port, Date today) &#123; this.driver = driver; this.port = port; this.today = today; &#125; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\"+driver+\",\"+port+\",\"+today); &#125;&#125; 12345678910111213141516171819&lt;!-- 构造函数注入： 涉及的标签：constructor-arg 标签的属性： type:指定参数的类型。 index:指定参数的索引位置，从0开始。 name:指定参数的名称。 一般用它 ========上面三个属性是指定给哪个参数赋值的，下面两个属性是指定赋什么值的============== value:指定基本数据类型或String类型的数据 ref:指定其他bean类型数据 标签出现的位置： 写在bean标签内部 --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;constructor-arg name=\"driver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"port\" value=\"3306\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"today\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 2.3.3.2 set方法注入就是在类中提供需要注入成员的set方法。具体代码如下： 12345678910111213141516171819202122232425262728293031/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl2 implements ICustomerService &#123; private String driver; private Integer port; private Date today; //以上三个类成员，没有具体的实际意义，只是用于演示注入。 public void setDriver(String driver) &#123; this.driver = driver; &#125; public void setPort(Integer port) &#123; this.port = port; &#125; public void setToday(Date today) &#123; this.today = today; &#125; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\" + driver + \",\" + port + \",\" + today); &#125;&#125; 1234567891011121314151617&lt;!-- set方法注入 涉及的标签：property 标签的属性： name:指定参数的set方法名称。 =========上面三个属性是指定给哪个参数赋值的，下面两个属性是指定赋什么值的============ value:指定基本数据类型或String类型的数据 ref:指定其他bean类型数据 标签出现的位置： 写在bean标签内部 --&gt;&lt;bean id=\"customerService2\" class=\"com.wgy.service.impl.CustomerServiceImpl2\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"port\" value=\"3307\"&gt;&lt;/property&gt; &lt;property name=\"today\" ref=\"now\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 2.3.3.3 复杂类型的注入就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List,Set,Map,Properties。具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl3 implements ICustomerService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String, String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveCustomer() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 复杂类型的注入 结构相同，标签可以互换 List结构的： array,list,set Map结构的 map,entry,props,prop --&gt;&lt;bean id=\"customerService3\" class=\"com.wgy.service.impl.CustomerServiceImpl3\"&gt; &lt;property name=\"myStrs\"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;props&gt; &lt;prop key=\"testF\"&gt;FFF&lt;/prop&gt; &lt;prop key=\"testG\"&gt;GGG&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;map&gt; &lt;entry key=\"testD\" value=\"DDD\"&gt;&lt;/entry&gt; &lt;entry key=\"testE\"&gt; &lt;value&gt;EEE&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Struts2(四)","date":"2020-06-08T07:27:44.000Z","path":"archives/bb3a06c4.html","text":"1. Struts2中的拦截器1.1 Struts2的拦截器基本概念1.1.1 拦截器概述在Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者在定义的action执行的前后加入执行的代码，也可以在一个action执行前阻止其执行。也就是说它提供了一种可以提取action中可重用代码，统一管理和执行的方式。 拦截器链 （Interceptor Chain，在Struts 2中称为拦截器栈Interceptor Stack）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 拦截器和过滤器是有几分相似，但是也有区别： 过滤器是servlet规范中的一部分，任何java web工程都可以使用。 拦截器是struts2框架自己的，只有使用了struts2框架的工程才能用。 过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只有进入struts2核心内部之后，才会起作用，如果访问的是jsp，html,css,image或者js是不会进行拦截的。 同时，拦截器还是AOP编程思想的具体体现形式。AOP（Aspect-Oriented Programming）简单的说就是： 在不修改源码的基础上，已有的方法进行动态增强。 在struts2中，拦截器它就是对我们的动作方法进行增强。（其实就是把重复性的代码提取出来，然后放到拦截器中，统一管理，统一调用） 1.1.2 拦截器的执行时机在访问struts2核心内部时，在动作方法执行之前先正序执行，然后执行动作方法，执行完动作方法和结果视图之后，再倒序执行。所以它是先进后出，是个栈的结构。具体可参考下图： 1.2 自定义拦截器直接或间接的实现Interceptor接口 12345public interface Interceptor extends Serializable &#123; void init(); void destroy(); String intercept(ActionInvocation invocation) throws Exception;&#125; 该接口提供了三个方法，其具体介绍如下。 void init()：该方法在拦截器被创建后会立即被调用, 它在拦截器的生命周期内只被调用一次. 可以在该方法中对相关资源进行必要的初始化。 void destroy()：该方法与init方法相对应，在拦截器实例被销毁之前，将调用该方法来释放和拦截器相关的资源。它在拦截器的生命周期内，也只被调用一次。 String intercept(ActionInvocation invocation) throws Exception：该方法是拦截器的核心方法，用来添加真正执行拦截工作的代码，实现具体的拦截操作。它返回一个字符串作为逻辑视图，系统根据返回的字符串跳转到对应的视图资源。每拦截一个动作请求, 该方法就会被调用一次。该方法的ActionInvocation参数包含了被拦截的Action的引用，可以通过该参数的invoke()方法，将控制权转给下一个拦截器或者转给Action的execute()方法。 继承抽象拦截器类AbstractIntercepter 12345public abstract class AbstractInterceptor implements Interceptor &#123; public void init() &#123;&#125; public void destroy() &#123;&#125; public abstract String intercept(ActionInvocation invocation) throws Exception;&#125; AbstractInterceptor有一个子类MethodFilterInterceptor，该类中提供了两个属性，可以告知拦截器对哪些方法进行拦截或者对哪些方法排除。 1.2.1 第一步：编写普通java类，继承AbstractInterceptor123456789101112131415161718192021222324252627282930313233/** * 自定义拦截器 * 步骤： * 第一步：编写一个普通类，继承AbstractInterceptor（也可以实现Interceptor接口） * 第二步：配置拦截器 * &lt;!-- 声明一个拦截器 --&gt; * &lt;interceptors&gt; * &lt;interceptor name=\"myInterceptor\" class=\"com.itheima.web.interceptors.MyInterceptor\"&gt;&lt;/interceptor&gt; * &lt;/interceptors&gt; * &lt;!-- 引用拦截器：写在action标签的内部。当我们写了自己的拦截器引用时，默认的拦截器栈就失效了 --&gt; * &lt;interceptor-ref name=\"myInterceptor\"&gt;&lt;/interceptor-ref&gt; * 拦截器的放行： * invocation.invoke(); * 返回值的内容是： * 动作方法的返回值 * 关于结果视图的执行时机以及拦截器的返回值问题 * 在放行之前，拦截器的返回值可以控制显示哪个结果视图。一旦放行之后，它一定会显示动作方法返回值所匹配的结果视图，此时已经不管拦截器返回什么内容。 * 多个拦截器的执行顺序问题： * 是由引用顺序决定的，与声明顺序无关 * * @author wgy */public class MyInterceptor extends AbstractInterceptor &#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"访问Action之前：MyInterceptor拦截了。。。。\"); //放行 String rtValue = invocation.invoke(); System.out.println(\"访问Action之后：MyInterceptor拦截了。。。。\"); return rtValue; &#125;&#125; 1.2.2 第二步：在struts.xml中配置拦截器1234567891011121314151617181920&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;!-- 声明一个拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name&#x3D;&quot;myIntercepter&quot; class&#x3D;&quot;com.wgy.web.interceptors.MyInterceptor&quot;&#x2F;&gt; &lt;&#x2F;interceptors&gt; &lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;!-- 引用拦截器：当我们写了自己的拦截器引用时，默认的拦截器栈就失效了 --&gt; &lt;interceptor-ref name&#x3D;&quot;myIntercepter&quot;&#x2F;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 1.3 案例-检查登录拦截器1.3.1 定义拦截器123456789101112131415161718/** * 检查登录拦截器 * * @author wgy */public class CheckLoginInterceptor2 extends MethodFilterInterceptor &#123; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; Object obj = ServletActionContext.getRequest().getSession().getAttribute(\"userinfo\"); if(obj == null)&#123; //没登录，去登录 return \"login\"; &#125; //已登录，就放行 return invocation.invoke(); &#125;&#125; 1.3.2 配置拦截器12345678910111213141516171819&lt;package name&#x3D;&quot;myDefault&quot; extends&#x3D;&quot;struts-default&quot; abstract&#x3D;&quot;true&quot;&gt; &lt;!-- 声明拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name&#x3D;&quot;checkLogin&quot; class&#x3D;&quot;com.wgy.web.interceptors.CheckLoginInterceptor2&quot;&#x2F;&gt; &lt;!-- 定义一个自己的拦截器栈 --&gt; &lt;interceptor-stack name&#x3D;&quot;myDefaultStack&quot;&gt; &lt;interceptor-ref name&#x3D;&quot;checkLogin&quot;&gt; &lt;!-- 告知拦截器，哪些方法需要拦截，哪些方法不需要拦截 --&gt; &lt;param name&#x3D;&quot;excludeMethods&quot;&gt;userLogin&lt;&#x2F;param&gt; &lt;&#x2F;interceptor-ref&gt; &lt;interceptor-ref name&#x3D;&quot;defaultStack&quot;&#x2F;&gt; &lt;&#x2F;interceptor-stack&gt; &lt;&#x2F;interceptors&gt; &lt;!-- 把我们自定义的拦截器栈声明为默认拦截器栈 --&gt; &lt;default-interceptor-ref name&#x3D;&quot;myDefaultStack&quot;&#x2F;&gt; &lt;global-results&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt; &lt;&#x2F;global-results&gt;&lt;&#x2F;package&gt; 1.3.3 编写和配置Action动作类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BBSAction extends ActionSupport implements ServletRequestAware &#123; private HttpServletRequest request; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; /** * 娱乐 * @return */ public String demo1()&#123; System.out.println(request); return SUCCESS; &#125; /** * 体育 * @return */ public String demo2()&#123; System.out.println(request); return SUCCESS; &#125; /** * 军事 * @return */ public String demo3()&#123; System.out.println(request); return SUCCESS; &#125; /** * 登录方法 * @return */ public String userLogin()&#123; //往session域中存入一个登录标记 ServletActionContext.getRequest().getSession().setAttribute(\"userinfo\", \"\"); return SUCCESS; &#125;&#125; 配置 1234567891011121314151617&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;myDefault&quot;&gt; &lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;demo1.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;demo2&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;demo2&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;demo2.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;demo3&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;demo3&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;demo3.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;login&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;userLogin&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;redirect&quot;&gt;&#x2F;main.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 2. Struts2的注解配置2.1 使用前提Struts2框架，它不仅支持基于XML的配置方式，同时也支持基于注解配置的方式。 注解和XML的配置，都是告知struts2框架，当我们jsp页面发送请求，根据配置执行对应动作类的方法，并根据返回值，前往指定的结果视图（jsp页面或者其他动作）。它们只是配置的形式不一样。 其次要想使用struts2的注解，必须要导入一个新的jar包。该jar包是： struts2-convention-plugin-2.3.24.jar 2.2 常用注解2.2.1 @NameSpace1234567891011121314151617出现的位置： 它只能出现在package上或者Action类上。一般情况下都是写在Action类上。作用： 指定当前Action中所有动作方法的名称空间。属性： value：指定名称空间的名称。写法和xml配置时一致。不指定的话，默认名称空间是&quot;&quot;。示例：@Namespace(&quot;&#x2F;customer&quot;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.2.2 @ParentPackage1234567891011121314151617出现的位置： 它只能出现在package上或者Action类上。一般情况下都是写在Action类上。作用： 指定当前动作类所在包的父包。由于我们已经是在类中配置了，所以无需在指定包名了。属性： value：指定父包的名称。示例：@ParentPackage(&quot;struts-default&quot;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.2.3 @Action12345678910111213141516171819出现的位置： 它只能出现在Action类上或者动作方法上。一般情况下都是写在动作方法上。作用： 指定当前动作方法的动作名称。也就是xml配置时action标签的name属性。属性： value：指定动作名称。 results[]：它是一个数组，数据类型是注解。用于指定结果视图。此属性可以没有，当没有该属性时，表示不返回任何结果视图。即使用response输出响应正文。 interceptorRefs[]：它是一个数组，数据类型是注解。用于指定引用的拦截器。示例：&#x2F;** * 获取添加客户页面 * @return *&#x2F;@Action(value&#x3D;&quot;addUICustomer&quot;,results&#x3D;&#123; @Result(name&#x3D;&quot;addUICustomer&quot;,location&#x3D;&quot;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&quot;)&#125;)public String addUICustomer()&#123; return &quot;addUICustomer&quot;;&#125; 2.2.4 @Result123456789101112131415161718192021出现的位置： 它可以出现在动作类上，也可以出现在Action注解中。作用： 出现在类上，表示当前动作类中的所有动作方法都可以用此视图。 出现在Action注解中，表示当前Action可用此视图。属性： name：指定逻辑结果视图名称。 type：指定前往视图的方式。例如：请求转发，重定向，重定向到另外的动作。 location：指定前往的地址。可以是一个页面，也可以是一个动作。示例：&#x2F;** * 保存客户 * @return *&#x2F;@Action(value&#x3D;&quot;addCustomer&quot;,results&#x3D;&#123; @Result(name&#x3D;&quot;addCustomer&quot;,type&#x3D;&quot;redirect&quot;,location&#x3D;&quot;&#x2F;jsp&#x2F;success.jsp&quot;)&#125;)public String addCustomer()&#123; customerService.saveCustomer(customer); return &quot;addCustomer&quot;;&#125; 2.2.5 @Results1234567891011121314151617181920出现的位置： 它可以出现在动作类上，也可以出现在Action注解中。作用： 用于配置多个结果视图。属性： value：它是一个数组，数据类型是result注解。示例：@Results(&#123; @Result(name&#x3D;&quot;login&quot;,location&#x3D;&quot;&#x2F;login.jsp&quot;), @Result(name&#x3D;&quot;error&quot;,location&#x3D;&quot;&#x2F;error.jsp&quot;)&#125;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.2.6 @InterceptorRef123456789101112131415161718192021222324252627282930313233343536出现的位置： 它可以出现在动作类上或者Action注解中。作用： 用于配置要引用的拦截器或者拦截器栈属性： value：用于指定拦截器或者拦截器栈示例：出现在动作方法上：&#x2F;** * 查询所有客户 * @return *&#x2F;@Action(value&#x3D;&quot;findAllCustomer&quot;, results&#x3D;&#123; @Result(name&#x3D;&quot;findAllCustomer&quot;,location&#x3D;&quot;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&quot;) &#125;, interceptorRefs&#x3D;&#123; @InterceptorRef(&quot;myDefaultStack&quot;) &#125;)public String findAllCustomer()&#123; customers &#x3D; customerService.findAllCustomer(); return &quot;findAllCustomer&quot;;&#125;出现在动作类上：@InterceptorRef(&quot;myDefaultStack&quot;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.3 案例-注解实现客户保存和查询列表2.3.1 拷贝必备jar包导入jar包： struts2-convention-plugin-2.3.24.jar 2.3.2 使用注解配置Action1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 客户的动作类 * * @author wgy */@ParentPackage(\"struts-default\")//指定当前包的父包@Namespace(\"/customer\")@Results(&#123; @Result(name=\"customerList\",type=\"redirect\",location=\"findAllCustomer.action\"), @Result(name=\"error\",location=\"/jsp/error.jsp\"), @Result(name=\"addUICustomer\",location=\"/jsp/customer/add.jsp\"), @Result(name=\"findAllCustomer\",location=\"/jsp/customer/list.jsp\")&#125;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private ICustomerService customerService = new CustomerServiceImpl(); private Customer customer = new Customer(); private List&lt;Customer&gt; customers; @Override public Customer getModel() &#123; return customer; &#125; /** * 查询所有客户 * @return */ @Action(\"findAllCustomer\") public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.返回 return \"findAllCustomer\"; &#125; /** * 获取添加客户页面 * @return */ @Action(\"addUICustomer\") public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 添加客户 * @return */ @Action(\"addCustomer\") public String addCustomer()&#123; customerService.saveCustomer(customer); return \"customerList\"; &#125; /** * 删除客户 * @return */ @Action(\"deleteCustomer\") public String deleteCustomer()&#123; customerService.deleteCustomer(customer); return \"customerList\"; &#125; //------getters and setters-------------- public List&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers; &#125;&#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Struts2(三)","date":"2020-06-07T11:48:27.000Z","path":"archives/4179e9cb.html","text":"1. OGNL表达式1.1 OGNL表达式概述1.1.1 什么是OGNL表达式OGNL的全称是对象图导航语言（Object-Graph Navigation Language），它是一种功能强大的开源表达式语言，使用这种表达式语言，可以通过某种表达式语法，存取Java对象的任意属性，调用Java对象的方法，同时能够自动实现必要的类型转换。如果把表达式看作是一个带有语义的字符串，那么OGNL无疑成为了这个语义字符串与Java对象之间沟通的桥梁。 1.1.2 OGNL表达式的由来它原本是xwork2中的默认表达式语言，当年OpenSymphony和apache在合作开发struts2框架时，把这个表达式也引进来了，所以就变成了struts2的默认表达式语言。 1.1.3 OGNL表达式的使用要求要想使用ognl表达式，一般情况下都得需要使用struts2的标签库。 1&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt; 1.1.4 它的特点它不仅可以用于取值，显示。还可以赋值。取值是我们程序员使用框架做的事情。赋值是框架为我们做的。 1.2 OGNL表达式的基本用法1.2.1 s:property标签输出内容到浏览器1.2.1.1 s:property的用法12345678&lt;%--要想使用OGNL表达式获取数据，此时需要借助struts2的标签库 s:property标签实现把数据输出到浏览器上 &lt;s:property value=\"\"/&gt; value属性的取值是一个OGNL表达式。 标签会把value属性取值所对应的内容输出到浏览器上 如果没有任何对应内容，则什么都不显示--%&gt;OGNL的最基本用法：&lt;s:property value=\"OGNLExpression\"/&gt; 1.2.1.2 OGNL表达式和字符串的转换12345678910111213141516&lt;%--OGNL表达式和字符串的转换 表达式转成字符串 %&#123;''&#125; | %&#123;\"\"&#125; 可以把%&#123;&#125;去掉 --%&gt;OGNL转成一个普通的字符串：&lt;s:property value=\"%&#123;'OGNLExpression1'&#125;\"/&gt;&lt;br/&gt;OGNL转成一个普通的字符串：&lt;s:property value='%&#123;\"OGNLExpression2\"&#125;'/&gt;&lt;br/&gt;OGNL转成一个普通的字符串：&lt;s:property value='\"OGNLExpression3\"'/&gt;&lt;br/&gt;OGNL转成一个普通的字符串：&lt;s:property value=\"'OGNLExpression4'\"/&gt;&lt;br/&gt;&lt;!-- 字符串转成表达式 %&#123;&#125;把字符串套起来--&gt;&lt;!-- user.name 看上去是字符串，当它执行user对象的getName方法时，表示用OGNL表达式解释。 --&gt;字符串转成一个OGNL表达式：&lt;s:textfield name=\"username\" value=\"%&#123;user.name&#125;\"/&gt; 1.2.2 OGNL表达式访问对象的方法1234&lt;%--OGNL表达式访问对象的方法 --%&gt;调用字符串的长度方法：&lt;s:property value=\"'OGNLExpression1'.length()\"/&gt;&lt;br/&gt;调用字符串的转大写方法：&lt;s:property value=\"'OGNLExpression1'.toUpperCase()\"/&gt;&lt;br/&gt;调用字符串的分隔方法：&lt;s:property value=\"'OGNLExpression1'.split('E')\"/&gt;&lt;br/&gt; 1.2.3 OGNL表达式访问类的静态属性和静态方法123456&lt;%--OGNL表达式访问类的静态成员(静态属性) 访问静态属性需要按照固定的书写规范来写。 规范是： @包名.包名...类名@静态属性名称--%&gt;OGNL表达式访问静态属性：&lt;s:property value=\"@java.lang.Integer@MAX_VALUE\"/&gt; 123456&lt;%--OGNL表达式访问类的静态方法 访问静态方法需要按照固定的书写规范来写。 规范是： @包名.包名...类名@静态方法名称--%&gt;OGNL表达式访问静态方法：&lt;s:property value=\"@java.lang.Math@random()\"/&gt; 1.2.4 OGNL表达式操作集合1.2.4.1 list集合1234567891011&lt;%--操作List集合 s:radio标签的list取值就是一个OGNL表达式。 &#123;&#125;就表示创建了一个List集合 &#123;'男','女'&#125;=== List list = new ArrayList(); list.add(\"男\"); list.add(\"女\");--%&gt;Struts2的单选按钮：&lt;br/&gt;&lt;s:radio list=\"&#123;'男','女'&#125;\" name=\"gender2\" label=\"性别\"&gt;&lt;/s:radio&gt;HTML的单选按钮：&lt;br/&gt;性别：&lt;input type=\"radio\" name=\"gender1\" value=\"男\"&gt;男&lt;input type=\"radio\" name=\"gender1\" value=\"女\"&gt;女 1.2.4.2 map集合1234567891011&lt;%--操作Map集合 #&#123;&#125;就表示创建了一个Map集合。 #&#123;key:value,key:value&#125; #&#123;'male':'男','female':'女'&#125;=== Map map = new HashMap(); map.put(\"male\",\"男\"); map.put(\"female\",\"女\");--%&gt;Struts2的单选按钮：&lt;br/&gt;&lt;s:radio list=\"#&#123;'male':'男','female':'女'&#125;\" name=\"gender4\" label=\"性别\"&gt;&lt;/s:radio&gt;HTML的单选按钮：&lt;br/&gt;性别：&lt;input type=\"radio\" name=\"gender3\" value=\"male\"&gt;男&lt;input type=\"radio\" name=\"gender3\" value=\"female\"&gt;女 2. OGNL上下文2.1 ContextMap2.1.1 ContextMap概述它是OGNL上下文对象，是struts2中封装数据最大的对象。我们一次请求中所有用到的信息都可以在它里面找到。它是一个Map结构的对象，其中key是字符串，value是一个Object。 2.1.2 ContextMap中封装的数据 我们把这些内容拿出来逐个分析一下，得到下面的表格： Map的key（类型是String） Map的Value （类型是Object） 说明信息 application Java.util.Map&lt;String,Object&gt; 封装的应用域中的所有数据 session Java.util.Map&lt;String,Object&gt; 封装的会话域中的所有数据 request Java.util.Map&lt;String,Object&gt; 封装的请求域中的所有数据 valueStack(特殊) com.opensymphony.xwork2.ognl.OgnlValueStack 它是List结构 parameters Java.util.Map&lt;String,String[]&gt; 封装的是请求参数 attr Java.util.Map&lt;String,Object&gt; 封装的是四大域的组合数据，从最小的域开始搜索 action com.opensymphony.xwork2.ActionSupport 当前执行的动作类对象 2.2 ActionContext2.2.1 ActionContext对象概述它是一个工具类，是struts2框架提供给我们的，可以让我们调用其中的方法，快速的操作ContextMap。用它操作OGNL上下文对象，比直接操作ContextMap要方便很多。 2.2.2 ActionContext对象与ContextMap的关系ActionContext就相当于对ContextMap进行了一次再封装。 2.2.3 ActionContext何时创建由于ActionContext是操作的ContextMap，而ContextMap中封了我们一次请求的所有数据，所以它的创建应该是每次请求访问Action时，即核心控制器(StrutsPrepareAndExecuteFilter)的doFilter方法执行时，下图是代码截取： 2.2.4 ActionContext的线程安全我们都知道，java的web工程是多线程的，那么每个线程在访问Action时，都会创建自己的ActionContext,那么是如何保证在获取ActionContext时，每个线程都能获取到自己的那个呢？ 答案就是，每次创建ActionContext时，把对象绑定到当前线程上。下图是代码截取： 2.2.5 ActionContext的获取使用ActionContext类中的静态方法getContext()从当前线程上获取 2.2.6 获取ContextMap中的数据2.2.6.1 s:debug标签的使用123456&lt;%-- 引入标签库 --%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;%--1、struts2的debug标签 它是一个用于开发阶段的标签，查看我们OGNL上下文中内容的标签 --%&gt;&lt;s:debug/&gt; 2.2.6.2 使用OGNL表达式获取Map中的数据动作类存数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ActionContext的数据存取 * * @author wgy */public class Demo1Action extends ActionSupport &#123; /** * 通过ActionContext往ContextMap中存入数据 * contextMap hello context map * * 往应用域中存入数据：用两种方式实现 * applicationMap hello application map * applicationAttr hello application attr * * 往会话域中存入数据：同上用两种方式 * @return */ public String demo1()&#123; //1.获取ActionContext //从当前线程上获取 ActionContext context = ActionContext.getContext(); //2.存入数据 context.put(\"contextMap\", \"hello context map\"); //3.往应用域中存入数据 //第一种方式：使用原始ServletAPI对象ServletContext ServletContext applicationAttr = ServletActionContext.getServletContext(); applicationAttr.setAttribute(\"applicationAttr\", \"hello application attr\"); //第二种方式：根据key从ActionContext中获取应用域的map，往map中存入数据 Map&lt;String,Object&gt; applicationMap = context.getApplication(); applicationMap.put(\"applicationMap\",\"hello application map\"); //4.往会话域中存入数据 //第一种：使用ServletAPI的HttpSession HttpSession session = ServletActionContext.getRequest().getSession(); session.setAttribute(\"sessionAttr\", \"hello session attr\"); //第二种：获取key为session的map Map&lt;String,Object&gt; sessionMap = context.getSession(); sessionMap.put(\"sessionMap\",\"hello session map\"); return SUCCESS; &#125;&#125; 在页面中使用OGNL表达式获取： 1234567891011&lt;%--借助struts2的s:property标签和OGNL表达式获取ActionContext存入的数据 我们现在获取的数据，都是在map中。 获取Map中的数据，OGNL表达式的写法： #key 如果还想继续向下获取，使用.key的方式--%&gt;&lt;s:property value=\"#contextMap\"/&gt;&lt;br/&gt;&lt;s:property value=\"#application.applicationMap\"/&gt;&lt;br/&gt;&lt;s:property value=\"#session.sessionAttr\"/&gt;&lt;s:property value=\"#session.sessionMap\"/&gt; 2.3 ValueStack对象2.3.1 ValueStack对象概述ValueStack是Struts的一个接口，字面意义为值栈，OgnlValueStack是ValueStack的实现类，客户端发起一个请求struts2架构会创建一个action实例同时创建一个OgnlValueStack值栈实例，OgnlValueStack贯穿整个 Action 的生命周期。 它是ContextMap中的一部分，里面的结构是一个List，是我们可以快速访问数据一个容器。它的封装是由struts2框架完成的。 通常情况下我们是从页面上获取数据。它实现了栈的特性（先进后出）。 2.3.2 ValueStack的内部结构在 OnglValueStack 中包含了一个CompoundRoot的对象，该对象继承了ArrayList，并且提供了只能操作集合第一个元素的方法，所以我们说它实现了栈的特性。同时，它里面定义了一个ContextMap的引用，也就是说，我们有值栈对象，也可以通过值栈来获取ContextMap。 2.3.3 获取ValueStack中的数据2.3.3.1 值栈中都有什么首先我们要明确，值栈中存的都是对象。因为它本质就是一个List，List中只能存对象。 值栈中包含了我们通过调用push方法压栈的对象，当前执行的动作了和一个名称为DefaultTextProvider的类。值栈中的内容如下图： 2.3.3.2 在动作类中往值栈中存入数据12345678910111213141516171819202122232425262728293031/** * ValueStack的数据存取 * * @author wgy */public class Demo2Action extends ActionSupport &#123; //把私有成员放入值栈中 private String name = \"泰斯特\"; public String getName() &#123; return name; &#125; /** * 获取ValueStack，并且压栈操作 * @return */ public String demo2()&#123; //1.获取ActionContext //从当前线程上获取 ActionContext context = ActionContext.getContext(); //2.获取ValueStack对象 ValueStack vs = context.getValueStack(); //3.压栈操作 Student s = new Student(\"张三\",18,\"male\"); vs.push(s); return SUCCESS; &#125;&#125; 2.3.3.3 我们可以获取值栈中的什么一般情况下，我们都是根据debug标签中显示的Property Name来获取Property Value。 当然我们也可以获取栈顶对象。 2.3.3.5 在页面上使用OGNL表达式获取数据123456789101112131415&lt;%--获取值栈的数据也需要借助于struts2的标签库 使用s:property获取 获取值栈的数据，是直接写属性名称，得到的就是属性的值。 OGNL表达式的找法，是从栈顶逐个属性名称开始查找，只要找到之后，就不再继续查找，而是返回结果。 --%&gt;姓名：&lt;s:property value=\"name\"/&gt;&lt;br/&gt;年龄：&lt;s:property value=\"age\"/&gt;&lt;br/&gt;性别：&lt;s:property value=\"gender\"/&gt;&lt;br/&gt;&lt;%--获取指定位置的属性 --%&gt;获取第一个name:&lt;s:property value=\"[0].name\"/&gt;&lt;br/&gt;获取第二个name:&lt;s:property value=\"[1].name\"/&gt;&lt;%--如果使用s:property标签，没有写value属性，取的是栈顶对象 --%&gt;&lt;s:property/&gt; 2.3.3.6 OGNL表达式执行时调用的方法12345678910111213&lt;%--s:property在通过OGNL表达式获取数据时，所调用的方法：ValueStack中的findValue(String expr); --%&gt;&lt;% ActionContext context = ActionContext.getContext(); ValueStack vs = context.getValueStack(); Object o1 = vs.findValue(\"[0].name\"); out.println(o1); out.println(\"&lt;br/&gt;\"); Object o2 = vs.findValue(\"[1].name\"); out.print(o2); out.println(\"&lt;br/&gt;\"); Object o3 = vs.findValue(\"#application.applicationMap\"); out.print(o3);%&gt; 3. Struts2中使用EL表达式3.1 EL表达式回顾EL表达式的写法：${表达式}。 它是从四大域中，由小到大逐个域搜索，根据名称获取值。只要找到了，就不再继续搜索。 它的原理：使用的是PageContext类中的findValue方法。 3.2 Struts2对EL表达式的改变Struts2框架中对EL表达式做了如下改变： 1234EL表达式原来的搜素顺序： page Scope——&gt;request Scope——&gt;session Scope——&gt;application ScopeEL表达式改变后的搜索顺序： page Scope—&gt;request Scope—&gt;valueStack—&gt;contextMap—&gt;session Scope—&gt;application Scope struts2框架对request对象进行了包装，并且对getAttribute方法进行了增强，代码如下： 4. OGNL表达式中的各种符号总结4.1 %121、把OGNL表达式转成普通字符串 %&#123;&quot;&quot;&#125;2、把字符串转成OGNL表达式%&#123;&#125; 4.2 #121、获取ContextMap中的数据。#key2、在页面中可以创建Map集合。 #&#123;&#125; 4.3 $121、EL表达式使用2、可以在struts2的配置中使用OGNL表达式（配置可以是xml文件，也可以是注解）$&#123;&#125; 5. 案例-优化客户列表的展示5.1 改造Action我们把之前查询所有客户的动作方法改造一下，之前我们是把查询结果存入请求域中了，而此时我们只需要在Action中定义一个集合，并且提供get/set方法，它就会出现在值栈中。就可以在页面中使用OGNL表达式获取。 1234567891011121314151617181920/** * 查询所有客户 * @return */private List&lt;Customer&gt; customers;public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.返回 return \"findAllCustomer\";&#125;public List&lt;Customer&gt; getCustomers() &#123; return customers;&#125;public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers;&#125; 5.2 改造jsp在显示客户列表时，我们之前采用的是jstl标签库的c:forEach标签，今天我们将使用struts2提供的迭代标签s:iterator。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%-- &lt;c:forEach items=\"$&#123;customers&#125;\" var=\"customer\"&gt; &lt;TR&gt; &lt;TD&gt;$&#123;customer.custName &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custLevel &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custSource &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custIndustry &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custAddress &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custPhone &#125;&lt;/TD&gt; &lt;/TR&gt; &lt;/c:forEach&gt; --%&gt;&lt;%-- struts2中的迭代标签： 属性： value：它的取值是一个OGNL表达式 var：写了该属性：它会把var的值作为key，把当前遍历的对象作为value，存入contextMap中 没写该属性：它会把每次遍历的对象压入栈顶--%&gt;&lt;%-- &lt;s:iterator value=\"customers\" var=\"cust\"&gt; &lt;TR&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custName\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custLevel\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custSource\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custIndustry\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custAddress\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custPhone\"/&gt;&lt;/TD&gt; &lt;/TR&gt; &lt;/s:iterator&gt; --%&gt;&lt;s:iterator value=\"customers\"&gt; &lt;TR&gt; &lt;TD&gt;&lt;s:property value=\"custName\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custLevel\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custSource\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custIndustry\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custAddress\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custPhone\"/&gt;&lt;/TD&gt; &lt;/TR&gt;&lt;/s:iterator&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Struts2(二)","date":"2020-06-05T09:14:53.000Z","path":"archives/3f8ac9e0.html","text":"1. 结果视图的配置1.1 result标签在sturts.xml文件中，Result的配置非常简单，使用元素来配置Result逻辑视图与物理视图之间的映射，元素可以有name和type属性，但这两种属性都不是必选的。 1234567891011121314151617181920212223242526&lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;!-- result标签： 作用：用于配置结果视图（结果视图可以是一个jsp&#x2F;html，也可以是一个action） 属性： name：指定逻辑结果视图。作用就是和动作方法的返回值进行比较，当一致时，前往配置的页面或者action。不写的话:默认值是success——&gt;去哪 type：指定前往结果视图的方式。以何种方式前往。 ——&gt;怎么去 type取值都是来源于struts-default.xml文件中package名称是struts-default包中定义类型 常用的结果类型： dispatcher：请求转发 （默认值） redirect：重定向(可以是重定向到另外一个动作或者是重定向到一个jsp) redirectAction：重定向到另外一个动作(它由于会自动在后面为我们拼接url后缀，所以只能重定向到动作) 请求转发和重定向的区别： 请求转发：一次请求 地址栏不变 请求域中数据不丢失 服务器行为 只能是在当前应用中转发 重定向： 两次请求 地址栏改变 请求域中数据丢失 浏览器行为 可以定向到当前应用的外部 响应浏览器的三种方式： 请求转发 重定向 使用流输出（如果只有一种方式，那就是此种方式） --&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;redirectAction&quot;&gt;demo2&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;error&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;error.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt;&lt;action name&#x3D;&quot;demo2&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 1.2 配置全局结果视图1.2.1 局部结果视图和全局结果视图配置在action标签内的result，我们成为局部结果视图，它只能由当前action使用。 而在实际开发中，有很多页面，每个action可能都会用到。比如：success.jsp,error.jsp,login.jsp等等。当我们很多action都用到了login.jsp，在每个action标签中都配置一次，显然是不合理的，这个时候我们就用到了全局结果视图。 1.2.2 配置方式12345678910111213141516171819202122&lt;!-- 定义一个公共包 全局结果视图和局部结果视图 定义是放在action标签外面， 在global-results标签内部的结果视图。 可以在多个action中使用 优先级：先找局部，再找全局。--&gt;&lt;package name&#x3D;&quot;myDefault&quot; extends&#x3D;&quot;struts-default&quot; abstract&#x3D;&quot;true&quot;&gt; &lt;global-results&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt; &lt;&#x2F;global-results&gt;&lt;&#x2F;package&gt;&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;myDefault&quot;&gt; &lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;redirectAction&quot;&gt;demo2&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;demo2&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 2. 访问Servlet的API的两种方式2.1 使用ServletActionContext12345678910111213141516171819202122232425262728293031323334353637383940/** * 访问ServletAPI: * 有两种方式： * 第一种方式： * 使用struts2框架提供的一个工具类，该类中包含了相应的静态方法，可以直接获取 * 工具类是：ServletActionContext * 此种方式是我们实际开发中用的最多的方式 * * 输出结果之后，找出其中一个和其他三个不一样： * org.apache.struts2.dispatcher.StrutsRequestWrapper@1c6e453 它和其他三个不一样，它是struts2提供的 * org.apache.catalina.connector.ResponseFacade@b846ae * org.apache.catalina.core.ApplicationContextFacade@287809 * org.apache.catalina.session.StandardSessionFacade@e0d480 * * @author wgy */public class Demo1Action extends ActionSupport &#123; private HttpServletRequest request; private HttpServletResponse response; private HttpSession session; private ServletContext application; /** * 动作方法 * * @return */ public String demo1()&#123; request = ServletActionContext.getRequest(); response = ServletActionContext.getResponse(); application = ServletActionContext.getServletContext(); session = request.getSession(); System.out.println(request); System.out.println(response); System.out.println(application); System.out.println(session); return SUCCESS; &#125;&#125; 2.2 通过实现接口的方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 访问ServletAPI: * 有两种方式： * 第二种方式： * 通过实现不同的接口，获取不同的对象。 * 要想使用request，需要实现ServletRequestAware * 要想使用response，需要实现ServletResponseAware * 要想使用servletContext，需要实现SerlvetContextAware * 输出结果之后，找出其中一个和其他三个不一样： * org.apache.struts2.dispatcher.StrutsRequestWrapper@1c6e453 它和其他三个不一样，它是struts2提供的 * org.apache.catalina.connector.ResponseFacade@b846ae * org.apache.catalina.core.ApplicationContextFacade@287809 * org.apache.catalina.session.StandardSessionFacade@e0d480 * * * 如果说是一种方式获取ServletAPI对象：ActionContext中的get(key) * 如果说是三种方式获取ServletAPI对象，除了我们讲的两种之外，也可以使用ActionContext获取 * * 通过分析源码，我们得知，ActionContext看上去是一个类似Map的结构。 * map的key是String类型，Map的value是Object类型 * * @author wgy */public class Demo2Action extends ActionSupport implements ServletRequestAware, ServletResponseAware, ServletContextAware &#123; private HttpServletRequest request = null; private HttpServletResponse response = null; private ServletContext application = null; /** * 动作方法 * * @return */ public String demo2()&#123; System.out.println(request); System.out.println(response); System.out.println(application); return SUCCESS; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; @Override public void setServletResponse(HttpServletResponse response) &#123; this.response = response; &#125; @Override public void setServletContext(ServletContext application) &#123; this.application = application; &#125;&#125; 3. 请求参数的封装3.1 请求参数封装概述封装请求参数就是把我们通过浏览器发送请求时，要转递给服务器的数据封装到指定的对象中。这个对象一般都是实体类。但是有时就是Action中的一个属性。也就是说，我们封装请求参数时，可以有实体类，也可以没有。同时，我们还需要知道，请求参数的封装和请求方式无关。无论get还是post都可以封装。 3.2 属性驱动3.2.1 没有实体类此种情况，我们一般也称为动作类和模型在一起，也就是说我们在action中定义一些私有成员，并且提供它们的公有get/set方法。具体代码如下 动作类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 请求参数封装 * 第一种情况： * 属性驱动：没有实体类 * 表单数据的接收都定义在动作类中，所以称为动作类和模型数据写在一起 * 要想封装成功，需要按照要求书写： * 要求是：表单元素的name属性取值，必须和动作类中成员get/set方法后面的部分保持一致 * * 细节： * 1、struts2框架会我们解决post请求的中文乱码问题，但是get请求不解决。 * 2、struts2框架会自动为我们转换数据类型： * 基本类型自动转换 * 字符串数组会按照逗号+空格的方式拼接成字符串 * 日期类型会按照本地格式转成日期对象 * 本地格式：yyyy-MM-dd * * 执行参数封装，是一个名称为params的拦截器实现的。 * 封装的规则只有一个，它要去指定位置找属性，找到之后调用set方法赋值。 * * @author wgy */public class Demo1Action extends ActionSupport &#123; private String username; private Integer age; private Date birthday; private String hobby; /** * 动作方法 * * @return */ public String demo1()&#123; System.out.println(username+\"===\"+age+\"===\"+birthday+\"===\"+hobby); return SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125; jsp页面： 1234567891011&lt;%--请求参数封装：第一种情况：属性驱动-没有实体类 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo1.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.2.2 有实体类此种情况是，我们有独立的实体类，在action中定义的是实体类对象，并且提供get/set方法。代码如下： 动作类： 1234567891011121314151617181920212223242526272829303132333435363738/** * 请求参数封装 * 第二种情况： * 属性驱动：有实体类 * 表单数据的接收都定义在实体类中，把实体类定义在动作类中。 * 要想封装成功，需要按照要求书写： * 此时需要使用OGNL表达式来指定表单元素的name取值 * OGNL表达式全称：Object Graphic Navigation Language * 对象 图 导航 语言 * 写法： * user.username user.age * * 执行参数封装，是一个名称为params的拦截器实现的。 * 封装的规则只有一个，它要去指定位置找属性，找到之后调用set方法赋值。 * * @author wgy */public class Demo2Action extends ActionSupport &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; /** * 动作方法 * @return */ public String demo2()&#123; System.out.println(user); return SUCCESS; &#125;&#125; jsp页面： 1234567891011&lt;%--请求参数封装：第二种情况：属性驱动-有实体类 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo2.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"user.username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"user.birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"user.hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"user.hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"user.hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo2&quot; class&#x3D;&quot;com.wgy.web.action.Demo2Action&quot; method&#x3D;&quot;demo2&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3 模型驱动在Struts2中，Action处理请求参数还有另外一种方式，叫做模型驱动（ModelDriven）。通过实现ModelDriven接口来接收请求参数。 动作类： 12345678910111213141516171819202122232425262728293031323334/** * 请求参数封装 * 第三种情况： 我们在后面用的最多的方式 * 模型驱动 * 要想封装成功，需要按照要求书写： * 1、动作类必须实现ModelDriven接口 * 2、动作类中需要定义模型，并且必须实例化出来 * 3、提供接口抽象方法的实现，返回值必须是模型对象 * * 执行参数封装，是一个名称为params的拦截器实现的。 * 模型驱动的实现，除了params拦截器之外，还需要一个叫modelDriven的拦截器配合 * 封装的规则只有一个，它要去指定位置找属性，找到之后调用set方法赋值。 * * @author wgy */public class Demo3Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123; private User user = new User(); @Override public User getModel() &#123; return user; &#125; /** * 动作方法 * * @return */ public String demo3()&#123; System.out.println(user); return SUCCESS; &#125;&#125; jsp页面： 1234567891011&lt;%--请求参数封装：第三种情况：模型驱动 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo3.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo3&quot; class&#x3D;&quot;com.wgy.web.action.Demo3Action&quot; method&#x3D;&quot;demo3&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4 封装集合数据在实际的开发中，有些时候我们需要批量插入用户或者批量插入其他的对象，在Action中需要接受到这多个Action中封装的对象，然后传递给业务层。那么这个时候就需要将表单的数据封装到集合中。 3.4.1 封装到List动作类： 12345678910111213141516171819202122232425262728/** * 请求参数封装 * 复杂类型的封装：List集合封装 * 复杂类型的封装都需要基于第二种情况实现 * * @author wgy */public class Demo4Action extends ActionSupport &#123; private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; /** * 动作方法 * * @return */ public String demo4()&#123; System.out.println(users); return SUCCESS; &#125;&#125; jsp页面： 123456789101112131415161718&lt;%--请求参数封装：List集合类型的封装 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo4.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"users[0].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users[0].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users[0].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users[0].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users[0].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users[0].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; 姓名：&lt;input type=\"text\" name=\"users[1].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users[1].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users[1].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users[1].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users[1].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users[1].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo4&quot; class&#x3D;&quot;com.wgy.web.action.Demo4Action&quot; method&#x3D;&quot;demo4&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4.2 封装到Map动作类： 1234567891011121314151617181920212223242526272829/** * 请求参数封装 * 复杂类型的封装：Map集合封装 * 复杂类型的封装都需要基于第二种情况实现 * * @author wgy */public class Demo5Action extends ActionSupport &#123; private Map&lt;String, User&gt; users; public Map&lt;String, User&gt; getUsers() &#123; return users; &#125; public void setUsers(Map&lt;String, User&gt; users) &#123; this.users = users; &#125; /** * 动作方法 * * @return */ public String demo5()&#123; System.out.println(users); return SUCCESS; &#125;&#125; jsp页面： 123456789101112131415161718&lt;%--请求参数封装：Map集合类型的封装 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo5.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"users['key1'].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users['key1'].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users['key1'].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users['key1'].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users['key1'].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users['key1'].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; 姓名：&lt;input type=\"text\" name=\"users['abc'].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users['abc'].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users['abc'].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users['abc'].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users['abc'].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users['abc'].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo5&quot; class&#x3D;&quot;com.wgy.web.action.Demo5Action&quot; method&#x3D;&quot;demo5&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 4. 案例：Struts2+Hibernate实现保存删除客户4.1 Struts24.1.1 修改jspmenu.jsp 12345&lt;TR&gt; &lt;TD class=menuSmall&gt; &lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/addUICustomer.action\" target=main&gt;－ 新增客户&lt;/A&gt; &lt;/TD&gt;&lt;/TR&gt; add.jsp 123&lt;FORM id=form1 name=form1 action=\"$&#123;pageContext.request.contextPath &#125;/customer/addCustomer.action\" method=post&gt; ...&lt;/FORM&gt; list.jsp 123456789&lt;SCRIPT language=javascript&gt; function delOne(custId)&#123; var sure = window.confirm(\"确定删除吗？\"); if(sure)&#123; window.location.href = \"$&#123;pageContext.request.contextPath&#125;/customer/deleteCustomer?custId=\"+custId; &#125; &#125;&lt;/SCRIPT&gt;&lt;a href=\"javascript:delOne('$&#123;customer.custId&#125;')\" &gt;删除&lt;/a&gt; 4.1.2 配置xml并编写Actionstruts.xml的配置 12345678910111213141516171819202122232425262728293031&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; &lt;!-- 动作配置 --&gt; &lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;!-- 查询所有客户 --&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;!-- 获取添加客户页面 --&gt; &lt;action name&#x3D;&quot;addUICustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;addUICustomer&quot;&gt; &lt;result name&#x3D;&quot;addUICustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;!-- 添加客户 --&gt; &lt;action name&#x3D;&quot;addCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;addCustomer&quot;&gt; &lt;!-- &lt;result name&#x3D;&quot;addCustomer&quot; type&#x3D;&quot;redirect&quot;&gt;&#x2F;jsp&#x2F;success.jsp&lt;&#x2F;result&gt; --&gt; &lt;result name&#x3D;&quot;addCustomer&quot; type&#x3D;&quot;redirect&quot;&gt;findAllCustomer&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;!-- 删除客户 --&gt; &lt;action name&#x3D;&quot;deleteCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;deleteCustomer&quot;&gt; &lt;result name&#x3D;&quot;deleteCustomer&quot; type&#x3D;&quot;redirect&quot;&gt;findAllCustomer&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 动作类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 客户的动作类 * * @author wgy */public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private ICustomerService customerService = new CustomerServiceImpl(); private Customer customer = new Customer(); @Override public Customer getModel() &#123; return customer; &#125; /** * 查询所有客户 * @return */ public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //3.把查询的结果存入请求域中 request.setAttribute(\"customers\", customers); //4.返回 return \"findAllCustomer\"; &#125; /** * 获取添加客户页面 * @return */ public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 添加客户 * @return */ public String addCustomer()&#123; customerService.saveCustomer(customer); return \"addCustomer\"; &#125; /** * 删除客户 * @return */ public String deleteCustomer()&#123; customerService.deleteCustomer(customer); return \"deleteCustomer\"; &#125;&#125; 4.2 Hibernate4.2.1 编写业务层接口及实现类123456789101112131415161718192021222324252627/** * 客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer(); /** * 添加客户 * * @param customer */ void saveCustomer(Customer customer); /** * 删除客户 * @param customer */ void deleteCustomer(Customer customer);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 客户的业务层实现类 * 事务控制在业务层的 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 List&lt;Customer&gt; customers = customerDao.findAllCustomer(); //4.提交事务 tx.commit(); //5.返回结果 return customers; &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125; @Override public void saveCustomer(Customer customer) &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 customerDao.saveCustomer(customer); //4.提交事务 tx.commit(); &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125; @Override public void deleteCustomer(Customer customer) &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 customerDao.deleteCustomer(customer); //4.提交事务 tx.commit(); &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 4.2.2 编写持久层接口及实现类123456789101112131415161718192021222324252627282930313233/** * 客户的持久层接口 * * @author wgy */public interface ICustomerDao &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer(); /** * 添加客户 * @param customer */ void saveCustomer(Customer customer); /** * 删除客户 * @param customer */ void deleteCustomer(Customer customer); /** * 根据id查询客户 * @param custID * @return */ Customer findCustomerById(Long custID);&#125; 123456789101112131415161718192021222324252627/** * 客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return HibernateUtil.getCurrentSession().createQuery(\"from Customer\").list(); &#125; @Override public void saveCustomer(Customer customer) &#123; HibernateUtil.getCurrentSession().save(customer); &#125; @Override public void deleteCustomer(Customer customer) &#123; HibernateUtil.getCurrentSession().delete(findCustomerById(customer.getCustId())); &#125; @Override public Customer findCustomerById(Long custID) &#123; return HibernateUtil.getCurrentSession().get(Customer.class,custID); &#125;&#125; 5. 请求参数封装失败后处理办法5.1 配置input结果视图视图路径应该是从哪来回哪去 1234&lt;action name&#x3D;&quot;demo3&quot; class&#x3D;&quot;com.wgy.web.action.Demo3Action&quot; method&#x3D;&quot;demo3&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;input&quot;&gt;&#x2F;user.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 5.2 提示错误信息引入struts2标签库 1&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt; 1234567891011&lt;%--请求参数封装：类型转换失败的处理方式 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo3.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;s:fielderror fieldName=\"username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;s:fielderror fieldName=\"age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;s:fielderror fieldName=\"birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"hobby\" value=\"写代码\"/&gt;写代码 &lt;s:fielderror fieldName=\"hobby\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; 5.3 把提交的数据回显回来html标签和struts2标签都可以实现 123456&lt;s:form action=\"demo3\"&gt; &lt;s:textfield name=\"username\" label=\"姓名\"/&gt; &lt;s:textfield name=\"age\" label=\"年龄\"/&gt; &lt;s:textfield name=\"birthday\" label=\"生日\"/&gt; &lt;s:submit value=\"提交\"/&gt;&lt;/s:form&gt; 5.4 关于中文提示的问题I18N ： 国际化 Internationalization 同实体类创建.properties文件 1invalid.fieldvalue.birthday=请输入正确的日期格式。正确的格式是：yyyy-MM-dd","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Struts2(一)","date":"2020-06-04T15:33:21.000Z","path":"archives/90bb5282.html","text":"1. Struts2基本概念1.1 三层架构和三大框架各自的位置1.1.1 三层架构我们的开发架构一般都是基于两种形式，一种是C/S架构，也就是客户端/服务器，另一种是B/S架构，也就是浏览器/服务器。在JavaEE开发中，几乎全都是基于B/S架构的开发。那么在B/S架构中，系统标准的三层架构包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层： 也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web层，web需要接收http请求，完成http响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用MVC模型。（MVC是表现层的设计模型，和其他层没有关系） 业务层： 也就是我们常说的service层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web层依赖业务层，但是业务层不依赖web层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制） 持久层： 也就是我们是常说的dao层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。 通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。 1.1.2 三大框架和三层架构的关系 1.2 Struts2概述Struts2是一种基于MVC模式的轻量级Web框架，它自问世以来，就受到了广大Web开发者的关注，并广泛应用于各种企业系统的开发中。目前掌握Struts2框架几乎成为Web开发者的必备技能之一。 在介绍Struts2之前，先来认识一下Struts1。Struts1是最早的基于MVC模式的轻量级Web框架，它能够合理的划分代码结构，并包含验证框架、国际化框架等多种实用工具框架。但是随着技术的进步，Struts1的局限性也越来越多的暴露出来。为了符合更加灵活、高效的开发需求，Struts2框架应运而生。 Struts2是Struts1的下一代产品，是在 Struts1和WebWork技术的基础上进行合并后的全新框架（WebWork是由OpenSymphony组织开发的，致力于组件化和代码重用的J2EE Web框架，它也是一个MVC框架）。虽然Struts2的名字与Struts1相似，但其设计思想却有很大不同。实质上，Struts2是以WebWork为核心的，它采用拦截器的机制来处理用户的请求。这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts2可以理解为WebWork的更新产品。 Struts2拥有优良的设计和功能，其优势具体如下： 项目开源，使用及拓展方便，天生优势。 提供Exception处理机制。 Result方式的页面导航，通过Result标签很方便的实现重定向和页面跳转。 通过简单、集中的配置来调度业务类，使得配置和修改都非常容易。 提供简单、统一的表达式语言来访问所有可供访问的数据。 提供标准、强大的验证框架和国际化框架。 提供强大的、可以有效减少页面代码的标签。 提供良好的Ajax支持。 拥有简单的插件，只需放入相应的JAR包，任何人都可以扩展Struts2框架，比如自定义拦截器、自定义结果类型、自定义标签等，为Struts2定制需要的功能，不需要什么特殊配置，并且可以发布给其他人使用。 拥有智能的默认设置，不需要另外进行繁琐的设置。使用默认设置就可以完成大多数项目程序开发所需要的功能。 2. Struts2的入门2.1 Struts2环境搭建2.1.1 下载struts2开发包Struts2的官网: https://struts.apache.org/ 2.1.2 Struts2开发包目录介绍解压后的目录结构如下： 2.1.3 搭建步骤2.1.3.1 第一步：拷贝struts2必备jar包到web工程的lib目录要进行struts2的基本的开发，可以参考struts-2.3.24中的apps下的一些示例代码，其中struts2-blank.war是一个struts2的空的工程。我们只需要将struts2-blank.war解压后进入到WEB-INF下的lib中查看。 2.1.3.2 第二步：在类的根路径下创建一个名称为struts.xml的文件，并导入约束在开发中需要将struts.xml文件引入到工程的src下，因为src下内容发布到web服务器中就是WEB-INF下的classes中。 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 导入约束： 约束的位置：在struts2的核心jar包中 struts2-core-2.3.24.jar中包含一个名称为： struts-2.3.dtd的约束文件--&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt;&lt;&#x2F;struts&gt; 2.1.3.3 第三步：在web.xml配置struts2的核心控制器Struts2框架要想执行，所有的请求都需要经过这个前端控制器（核心过滤器） 12345678910111213141516&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot; version&#x3D;&quot;4.0&quot;&gt; &lt;!-- 配置struts2的核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;&lt;&#x2F;web-app&gt; 2.1.3.4 验证搭建成功与否把应用部署到tomcat中，启动tomcat，不报异常则表示搭建成功。 2.2 Struts2入门案例2.2.1 案例需求通过点击超链接发送请求，由Struts2中类来负责接收，并且在控制台输出接收到了的语句。 2.2.2 案例实现2.2.2.1 第一步：编写index.jsp 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;struts2的入门案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--struts2的核心控制默认会处理以.action为后缀的url，或者是没有任何后缀的url --%&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/hello\"&gt;访问第一个struts2应用&lt;/a&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/hello.action\"&gt;访问第一个struts2应用.action&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 2.2.2.2 第二步：编写Class12345678910111213141516171819202122232425/** * 我们的第一个动作类。 * 动作类： * 它就是一个概念。它就是struts2框架中用于处理请求的类。 * 我们以后处理请求都写动作类。 * * @author wgy */public class HelloAction &#123; /** * 我们的第一个动作方法 * 动作方法： * 动作类中用于处理请求的方法 * 动作方法有编写规范： * 1、访问修饰符都是public * 2、方法的返回值一般都是String(但是可以是void) * 3、方法都没有参数 * @return */ public String sayHello()&#123; System.out.println(\"HelloAction的sayHello方法执行了。。。。\"+this); return \"success\"; &#125;&#125; 2.2.2.3 第三步：在配置文件中配置我们的动作类123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.0.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 配置文件 --&gt; &lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 2.2.2.4 第四步：编写success.jsp1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;执行结果页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;执行成功！&lt;/body&gt;&lt;/html&gt; 2.2.2.5 第五步：启动tomcat测试访问结果2.3 Struts2的执行过程2.3.1 执行时序首先是，启动tomcat服务器，这时候会加载web.xml，当读到filter标签时，会创建过滤器对象。 Struts2的核心过滤器（StrutsPrepareAndExecuteFilter）会负责加载类路径下的struts.xml配置文件。 接下来，从客户端发送请求过来 先经过前端控制器（核心过滤器StrutsPrepareAndExecuteFilter），前端控制器会根据请求的名称在struts.xml中找到对应的配置，创建我们的动作类对象（每次访问时都会创建新的Action对象），然后执行指定的方法，根据方法的返回值找到Result的配置进行页面的跳转.最后响应浏览器。 2.3.2 内部执行流程Struts2框架在默认情况下核心控制器（StrutsPrepareAndExecuteFilter）默认会拦截以.action为后缀的请求，或者是没有任何后缀的请求。当拦截下来后，送入Struts2的核心内部。如下图所示： 我们通过上面的图解，应该明确在实际开发中我们用struts2要做哪些： 写动作类 写jsp 写配置文件 其中，又以配置文件为重。 3. Struts2的配置文件详解3.1 Struts2中的配置文件3.1.1 配置文件说明在struts2中给我们提供了6个配置文件。他们的加载时机是tomcat启动服务一加载我们的应用时，就加载struts2的配置文件。 他们的加载顺序入如下： 顺序 配置文件名 所在位置 说明 1 default.properties struts2-core-2.3.15.3.jar\\org\\apache\\struts2 不能修改 2 struts-default.xml struts2-core-2.3.15.3.jar 不能修改 3 strtuts-plugin.xml 在struts2提供的插件jar包中 不能修改 4 struts.xml 我们的应用中 我们修改的：推荐 5 struts.properties 我们的应用中 我们修改的 6 web.xml 我们的应用中 我们修改的，可以给过滤器配置参数 3.1.2 配置文件的注意事项 Struts2提供了两种配置的方式。一种是key=value的方式，即使用.properties文件。另一种是xml文件配置。我们推荐使用xml文件（它能描述层级关系）。 当多个配置文件中，有相同的参数，后加载的会把前面的值给覆盖了。 3.1.3 Struts2中的常用常量常量定义在了default.properties配置文件中，体现形式都是key=value。所有的struts2应用都会用到这些常量。 常用的： 常量名 常量值 说明 struts.i18n.encoding UTF-8 应用中使用的编码 struts.objectFactory.spring.autoWire name 和spring框架整合有关 struts.multipart.parser jakarta 指定文件上传用的组件 struts.multipart.maxSize 2097152 文件上传总文件大小限制：2M struts.action.extension action,, 能进入Struts2框架内部的url地址后缀名。多个值用逗号分隔 struts.enable.DynamicMethodInvocation false 是否允许动态方法调用 struts.devMode false 是否是开发模式。开发模式：改了配置文件，不需要重启。输出更多的错误信息。开发阶段建议为true struts.ui.theme xhtml 页面展示用的主题 3.2 Struts.xml中的标签详解3.2.1 constant标签123456789&lt;!-- constant标签： 作用： 用于修改struts2中的常量 属性： name：指定常量的key value：指定常量的值--&gt;&lt;!-- 开启开发者模式 --&gt;&lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; 3.2.2 package标签1234567891011121314151617181920&lt;!-- package标签： 作用：给访问的action进行分包管理。把配置文件按照面向对象的思想来管理。 属性： name：指定包的名称。必须写，并且必须唯一。 extends：指定当前包的父包。子包自动具备父包所定义的配置。我们的包一般都需要继承struts-default包。 该包在struts-defaul.xml文件中定义着。如果不继承该包，则不能使用struts2的核心功能。 abstract：把当前包声明为抽象包。抽象包就是用来被继承的。里面定义一般都是公共的配置。 只有没有action标签的包，才能定义为抽象包。 namespace：指定当前包的名称空间。它可以让我们的访问URL模块化。当我们指定了该属性，访问URL就变成了：名称空间+&#x2F;hello 名称空间的写法：第一个字符必须是&#x2F;，后面紧跟的字符必须是一个字母。其余内容可以是字母，也可以是数字。 例如：我们访问用户 &#x2F;user&#x2F;addUser.action &#x2F;user&#x2F;updateUser.action 名称空间有默认值。默认值是：&quot;&quot;--&gt;&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;n1&quot;&gt; &lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.2.3 action标签12345678910&lt;!-- action标签： 作用：建立动作名称，动作类和动作方法的对应关系 属性： name:指定动作名称。它是唯一的 class:指定动作类的全限定类名 method：指定动作方法名称--&gt;&lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3 action的三种创建方式3.3.1 第一种：无侵入式创建(实际开发中基本不用)12345678910111213/** * 我们的第一个动作类 * 动作类的第一种创建方式： * 无侵入式的创建。 */public class HelloAction &#123; public String sayHello()&#123; System.out.println(this); System.out.println(\"HelloAction中的sayHello方法执行了。。。。\"); return \"success\"; &#125;&#125; 123&lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3.2 第二种：实现Action接口的定义方式 (实际开发中用的也不多)12345678910111213/** * 通过实现接口的方式创建动作类 * * @author wgy */public class Hello2Action implements Action &#123; @Override public String execute() throws Exception &#123; System.out.println(\"Hello2Action的execute方法执行了。。。。\"); return SUCCESS; &#125;&#125; 1234&lt;!-- 默认动作方法：当我们要是执行的是execute方法时，method属性可以不写。 --&gt;&lt;action name&#x3D;&quot;hello2&quot; class&#x3D;&quot;com.wgy.web.action.Hello2Action&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; Action接口中的常量 SUCCESS：一般多用于成功 ERROR：一般多用于动作方法执行失败 LOGIN：一般多用于返回登录页面 NONE：一般用于不返回任何结果视图，和return null作用是一样的 INPUT：一般多用于数据回显，也是struts2中数据回显时的默认返回值。 3.3.3 第三种：继承ActionSupport (实际开发中采用的方式)12345678/** * 通过继承ActionSupport的方式创建动作类 * * @author wgy */public class Hello3Action extends ActionSupport &#123;&#125; 123&lt;action name&#x3D;&quot;hello3&quot; class&#x3D;&quot;com.wgy.web.action.Hello3Action&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3.4 默认动作类：ActionSupport类1234&lt;!-- 通过struts-default.xml中我们知道默认的动作类是ActionSupport，所以如果实现该类的execute方法，则可以不用指定class和method属性 --&gt;&lt;action name&#x3D;&quot;hello4&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4 action的三种访问方式12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 用户的动作类 * * @author wgy */public class UserAction extends ActionSupport &#123; /** * 保存 * @return */ public String addUser() &#123; System.out.println(\"保存了用户\"); return SUCCESS; &#125; /** * 更新 * @return */ public String updateUser() &#123; System.out.println(\"更新了用户\"); return SUCCESS; &#125; /** * 查询 * @return */ public String deleteUser() &#123; System.out.println(\"删除了用户\"); return SUCCESS; &#125; /** * 删除 * @return */ public String findUser() &#123; System.out.println(\"查询了用户\"); return SUCCESS; &#125;&#125; 3.4.1 第一种：全匹配配置访问方式1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUser\"&gt;查询用户&lt;/a&gt; 1234567891011121314&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;addUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;addUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;updateUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;updateUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;deleteUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;deleteUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;findUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;findUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.4.2 第二种：使用通配符的方式* 通配符基本用法 1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUser\"&gt;查询用户&lt;/a&gt; 123456&lt;!-- 通配符基本用法 --&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;*&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;&#123;1&#125;&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 通配符的高级用法 1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/add_User\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/update_User\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/delete_User\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/find_User\"&gt;查询用户&lt;/a&gt; 123456&lt;!-- 通配符的高级用法 --&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;*_*&quot; class&#x3D;&quot;com.wgy.web.action.&#123;2&#125;Action&quot; method&#x3D;&quot;&#123;1&#125;&#123;2&#125;&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.4.3 第三种：使用动态方法调用的方式1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!findUser\"&gt;查询用户&lt;/a&gt; 1234567&lt;!-- 使用动态方法调用的方式 --&gt;&lt;constant name&#x3D;&quot;struts.enable.DynamicMethodInvocation&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;user&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 4. 案例：Strut2+Hibernate查询客户列表4.1 第一步：搭建hibernate开发环境并准备实体类和映射配置可参考Hibernate环境搭建。 Hibernate开发环境 1234567891011121314151617181920212223242526272829303132&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory--&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;struts2&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;property&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;&#x2F;property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping class&#x3D;&quot;com.wgy.domain.Customer&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 实体类和映射配置 123456789101112131415161718192021222324252627282930313233/** * 客户的实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name = \"cust_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 4.2 第二步：搭建struts2环境参考2.1.3章节的步骤去做。 4.3 第三步：导入crm的jsp页面把下图中红框内文件夹下所有内容都拷贝到WebContent目录中 4.4 第四步：修改menu.jsp12345&lt;TR&gt; &lt;TD class=menuSmall&gt; &lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/findAllCustomer.action\" target=main&gt;－ 客户列表&lt;/A&gt; &lt;/TD&gt;&lt;/TR&gt; 4.5 第五步：在配置文件中配置findAllCustomer.action1234567891011121314&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; &lt;!-- 动作配置 --&gt; &lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 4.6 第六步：创建动作类并提供动作方法123456789101112131415161718192021222324/** * 客户的动作类 * * @author wgy */public class CustomerAction extends ActionSupport &#123; private ICustomerService customerService = new CustomerServiceImpl(); /** * 查询所有客户 * @return */ public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //3.把查询的结果存入请求域中 request.setAttribute(\"customers\", customers); //4.返回 return \"findAllCustomer\"; &#125;&#125; 4.7 第七步：编写service接口和实现类1234567891011121314/** * 客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617181920212223242526272829303132/** * 客户的业务层实现类 * 事务控制在业务层的 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 List&lt;Customer&gt; customers = customerDao.findAllCustomer(); //4.提交事务 tx.commit(); //5.返回结果 return customers; &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 4.8 第八步：编写dao接口和实现类1234567891011121314/** * 客户的持久层接口 * * @author wgy */public interface ICustomerDao &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 123456789101112/** * 客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return HibernateUtil.getCurrentSession().createQuery(\"from Customer\").list(); &#125;&#125; 4.9 第九步：页面展示jsp/customer/list.jsp12345678910&lt;c:forEach items=\"$&#123;customers&#125;\" var=\"customer\"&gt; &lt;TR&gt; &lt;TD&gt;$&#123;customer.custName &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custLevel &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custSource &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custIndustry &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custAddress &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custPhone &#125;&lt;/TD&gt; &lt;/TR&gt; &lt;/c:forEach&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Hibernate(四)","date":"2020-06-03T14:33:02.000Z","path":"archives/c4c4045f.html","text":"1. JPA相关概念1.1 JPA概述全称是：Java Persistence API。是SUN公司推出的一套基于ORM的规范。Hibernate框架中提供了JPA的实现。 JPA通过JDK 5.0注解或XML描述对象—关系表的映射关系，并将运行期的实体对象持久化到数据库中。 1.2 JPA的优势 标准化 JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。 容器级特性的支持 JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。 简单方便 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成。 查询能力 JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。 高级特性 JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。 1.3 学习JPA要明确的 JPA是一套ORM规范，Hibernate实现了JPA规范 hibernate中有自己的独立ORM操作数据库方式，也有JPA规范实现的操作数据库方式。 2. JPA入门2.1 需求介绍本章节我们实现基于JPA注解的对象关系映射，配置实体类和数据库表的对应关系。并且使用JPA规范中的方法实现CRUD操作。 2.2 JPA环境搭建2.2.1 第一步：拷贝jar包 2.2.2 第二步：创建配置文件在src下面的META-INF文件夹下面创建一个名称为persistence.xml的文件。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;persistence xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence&#x2F;persistence_2_0.xsd&quot; version&#x3D;&quot;2.0&quot;&gt; &lt;!-- 配置持久化单元，可以配置多个，但是名称不能重复 name:用于指定持久化单元名称 transaction-type:指定事务的类型。 JTA：Java Transaction API RESOURCE_LOCAL:指的是本地代码事务。（我们用这个） --&gt; &lt;persistence-unit name&#x3D;&quot;myJPAUnit&quot; transaction-type&#x3D;&quot;RESOURCE_LOCAL&quot;&gt; &lt;!-- JPA规范的提供商 可以不写。--&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;&#x2F;provider&gt; &lt;!-- 指定由Jpa注解的实体类位置 可以不写。--&gt; &lt;class&gt;com.wgy.domain.Customer&lt;&#x2F;class&gt; &lt;!-- 连接库相关的一些配置 --&gt; &lt;properties&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot; value&#x3D;&quot;org.hibernate.dialect.MySQLDialect&quot;&#x2F;&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot; value&#x3D;&quot;update&quot;&#x2F;&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;persistence-unit&gt;&lt;&#x2F;persistence&gt; 2.2.3 第三步：编写工具类，用于获取JPA的操作数据库对象1234567891011121314151617181920212223/** * JPA的工具类 * * @author wgy */public class JPAUtil &#123; //它就相当于SessionFactory private static EntityManagerFactory factory; static &#123; //注意：该方法参数必须和persistence.xml中persistence-unit标签name属性取值一致 factory = Persistence.createEntityManagerFactory(\"myJPAUnit\"); &#125; /** * 获取EntityManager对象 * * @return */ public static EntityManager createEntityManager() &#123; return em.createEntityManager(); &#125;&#125; 2.2.4 第四步：编写实体类并使用注解配置12345678910111213141516171819202122232425262728293031323334/** * 客户实体类 * 使用的注解都是JPA规范，所以导包，都需要导入javax.persistence包下的 * * @author wgy */@Entity//表明该类是一个实体类@Table(name = \"cst_customer\")//建立当前类和数据库表的对应关系public class Customer implements Serializable &#123; @Id//表明当前字段是主键 @Column(name = \"cust_id\")//表明对应数据库的主键字段是cust_id @GeneratedValue(strategy = GenerationType.IDENTITY)//指定主键生成策略。 private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 2.3 JPA的CRUD操作2.3.1 保存123456789101112131415161718192021/** * 保存 */@Testpublic void test1() &#123; //创建客户对象 Customer c = new Customer(); c.setCustName(\"JPA Customer\"); //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行保存操作 em.persist(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.2 快照更新12345678910111213141516171819/** * 更新操作 */@Testpublic void test3() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //修改客户的地址为：顺义区 c.setCustAddress(\"顺义区\"); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.3 merge更新12345678910111213141516171819202122/** * 更新的另一种操作方式 * merge是合并 （两个实体合并） */@Testpublic void test4() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //修改客户的地址为：顺义区 c.setCustAddress(\"北京市顺义区\"); em.merge(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.4 删除1234567891011121314151617181920/** * 删除操作 */@Testpublic void test5() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //删除操作 em.remove(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.5 查询一个12345678910111213141516171819202122232425262728293031323334353637/** * 查询一个实体 立即加载 */@Testpublic void test2() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); System.out.println(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125;/** * 查询一个实体 延迟加载 */@Testpublic void test2_1() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.getReference(Customer.class, 1L); System.out.println(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.6 查询所有12345678910111213141516171819202122232425262728293031323334353637/** * 查询所有 * * 涉及的对象是： * JPA的Query * 如何获取该对象： * EntityManager的createQuery(String jpql) * 参数含义： * JPQL：Java Persistence Query Language * 他的写法和HQL很相似。也是把表名换成类名，把字段名换成属性名称 * 它在写查询所有时，不能直接用 from 实体类 * 需要使用select关键字 * select c from Customer c */@Testpublic void test6() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.获取JPA的查询对象Query Query query = em.createQuery(\"select c from Customer c where custName like ? and custLevel = ? \"); //给占位符赋值 query.setParameter(1, \"%集%\"); query.setParameter(2, \"23\"); //执行方法获取结果集 //getSingleResult()：查询结果是一个对象 List list = query.getResultList(); for (Object o : list) &#123; System.out.println(o); &#125; //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 3. JPA的多表操作3.1 一对多关系配置及操作3.1.1 配置123456789101112131415161718192021222324252627282930313233343536373839404142/** * 客户实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name = \"cust_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; /** * 一对多关系映射：一个客户可以有多个联系人 * mappedBy 取消维护 * cascade 级联保存 * fetch 查询加载时机 */ @OneToMany(targetEntity = LinkMan.class,mappedBy = \"customer\",cascade = CascadeType.ALL,fetch = FetchType.EAGER) private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); ...&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 联系人的实体类 * * @author wgy */@Entity@Table(name = \"cst_linkman\")public class LinkMan implements Serializable &#123; @Id @Column(name = \"lkm_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long lkmId; @Column(name = \"lkm_name\") private String lkmName; @Column(name = \"lkm_gender\") private String lkmGender; @Column(name = \"lkm_phone\") private String lkmPhone; @Column(name = \"lkm_mobile\") private String lkmMobile; @Column(name = \"lkm_email\") private String lkmEmail; @Column(name = \"lkm_position\") private String lkmPosition; @Column(name = \"lkm_memo\") private String lkmMemo; /** * 一对多关系映射，多的一方。 * 从表实体包含主表实体的对象引用 */ @ManyToOne(targetEntity = Customer.class,fetch = FetchType.LAZY) @JoinColumn(name = \"lkm_cust_id\",referencedColumnName = \"cust_id\") private Customer customer; ...&#125; 3.1.2 操作3.1.2.1 保存123456789101112131415161718192021222324/** * 保存操作 * 创建一个客户和一个联系人 * 建立客户和联系人的双向关联关系 * 先保存客户，再保存联系人 */@Testpublic void test1() &#123; Customer c = new Customer(); LinkMan l = new LinkMan(); c.setCustName(\"JPA One To Many Customer\"); l.setLkmName(\"JPA One To Many LinkMan\"); c.getLinkmans().add(l); l.setCustomer(c); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); em.persist(c); em.persist(l); tx.commit(); em.close();&#125; 3.1.2.2 更新1234567891011121314151617181920212223/** * 更新操作 * 创建一个联系人 * 查询id为5的客户 * 为5这个客服分配该联系人 * 更新客户 */@Testpublic void test2() &#123; LinkMan l = new LinkMan(); l.setLkmName(\"JPA One To Many LinkMan 2\"); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer c = em.find(Customer.class, 5L); c.getLinkmans().add(l); l.setCustomer(c); tx.commit(); em.close();&#125; 3.1.2.3 删除123456789101112131415/** * 删除操作 */@Testpublic void test3() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer c = em.find(Customer.class, 5L); em.remove(c); tx.commit(); em.close();&#125; 3.1.2.4 查询12345678910111213141516171819202122232425262728293031323334353637/** * 根据客户查询客户下的联系人 */@Testpublic void test1() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //1.查询id为1的客户 Customer c = em.find(Customer.class, 1l); System.out.println(c); //查询当前客户下的联系人 Set&lt;LinkMan&gt; linkmans = c.getLinkmans(); System.out.println(linkmans); tx.commit(); em.close();&#125;/** * 根据联系人，查询联系人的所属客户 */@Testpublic void test2() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //1.查询id为1的客户 LinkMan l = em.find(LinkMan.class, 1l); System.out.println(l); //查询当前客户下的联系人 Customer c = l.getCustomer(); System.out.println(c); tx.commit(); em.close();&#125; 3.2 多对多关系配置及操作3.2.1 配置12345678910111213141516171819202122232425262728293031/** * 角色的实体类 * * @author wgy */@Entity@Table(name = \"sys_role\")public class SysRole implements Serializable &#123; @Id @Column(name = \"role_id\") @GenericGenerator(name = \"uuid\", strategy = \"uuid\")//声明一个主键生成器 name属性：给生成器起个名字。strategy：指定的就是hibernate中包含的生成策略 @GeneratedValue(generator = \"uuid\") private String roleId; @Column(name = \"role_name\") private String roleName; @Column(name = \"role_memo\") private String roleMemo; //多对多关系映射：一个角色可以赋予多个用户 @ManyToMany(cascade=CascadeType.ALL) //加入一张表 @JoinTable(name=\"user_role_ref\", joinColumns = &#123;@JoinColumn(name=\"role_id\",referencedColumnName=\"role_id\")&#125;,//写的是当前实体在中间表的外键字段 inverseJoinColumns=&#123;@JoinColumn(name=\"user_id\",referencedColumnName=\"user_id\")&#125;//写的是对方实体在中间表的外键字段 ) private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); ...&#125; 1234567891011121314151617181920212223242526272829/** * 用户的实体类 * * @author wgy */@Entity@Table(name = \"sys_user\")public class SysUser implements Serializable &#123; @Id @Column(name = \"user_id\") @GenericGenerator(name = \"uuid\", strategy = \"uuid\") @GeneratedValue(generator = \"uuid\") private String userId; @Column(name = \"user_name\") private String userName; @Column(name = \"user_password\") private String userPassword; @Column(name = \"user_state\") private Integer userState; //多对多关系映射：一个用户可以具备多个角色 @ManyToMany(mappedBy=\"users\",cascade= CascadeType.ALL) private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); ...&#125; 3.2.2 操作3.2.2.1 保存1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 保存操作 * 创建两个用户 * 创建三个角色 * 让1号用户具备1号和2号角色 * 让2号用户具备2号和3号角色 * 保存用户和角色 */@Testpublic void test1() &#123; SysUser u1 = new SysUser(); SysUser u2 = new SysUser(); u1.setUserName(\"JPA Many to Many u1\"); u2.setUserName(\"JPA Many to Many u2\"); SysRole r1 = new SysRole(); SysRole r2 = new SysRole(); SysRole r3 = new SysRole(); r1.setRoleName(\"JPA Many to Many r1\"); r2.setRoleName(\"JPA Many to Many r2\"); r3.setRoleName(\"JPA Many to Many r3\"); //建立用户和角色的关联关系 u1.getRoles().add(r1); u1.getRoles().add(r2); u2.getRoles().add(r2); u2.getRoles().add(r3); r1.getUsers().add(u1); r2.getUsers().add(u1); r2.getUsers().add(u2); r3.getUsers().add(u2); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //保存操作 em.persist(u1); tx.commit(); em.close();&#125; 3.2.2.2 删除123456789101112131415/** * 删除操作 * 双向级联删除，不管是hibernate还是Jpa,多对多中都不能配置 */@Testpublic void test2() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //查询用户 SysUser u1 = em.find(SysUser.class, \"8a7e83cc5fbf19b6015fbf19bada0000\"); em.remove(u1); tx.commit(); em.close();&#125; 4. JPA的其他说明4.1 JPA中使用C3P0连接池4.1.1 第一步：拷贝C3P0所必须的3个jar包 4.1.2 第二步：在persistence.xml配置文件中配置12&lt;!-- 配置使用C3P0数据源 --&gt;&lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot; value&#x3D;&quot;org.hibernate.connection.C3P0ConnectionProvider&quot;&#x2F;&gt; 4.1.3 验证是否配置成功1234567891011121314151617/** * 验证c3p0连接池是否配置成功 */@Testpublic void test1() &#123; //1.获取jpa中的操作对象 EntityManager em = JPAUtil.createEntityManager(); //2. Session session = em.unwrap(Session.class); //3.执行session的doWork方法 session.doWork(new Work() &#123; @Override public void execute(Connection conn) throws SQLException &#123; System.out.println(conn.getClass().getName()); &#125; &#125;);&#125; 12345678@Testpublic void test2() &#123; //1.获取jpa中的操作对象 EntityManager em1 = JPAUtil.createEntityManager(); EntityManager em2 = JPAUtil.createEntityManager(); //false System.out.println(em1 == em2);&#125; 4.2 JPA与Hibernate中操作数据的方法对照 5. Hibernate中使用JPA注解映射配置5.1 编写主配置文件(hibernate.cfg.xml)1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!-- 在类的根路径下创建名称为hibernate.cfg.xml的配置文件导入约束：dtd约束 --&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory SessionFactory的作用就是用于创建Session对象的。 Session对象就是hibernate中操作数据库的核心对象。 此处的配置不要求背，但是要求记住创建SessionFactory必须的三部分信息 第一部分： 连接数据库的信息 第二部分： hibernate的可选配置 第三部分： 映射文件的位置 --&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider &lt;&#x2F;property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping class&#x3D;&quot;com.wgy.domain.Customer&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 5.2 编写实体类并使用JPA注解配置123456789101112131415161718192021222324252627282930313233/** * 客户实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name=\"cust_id\") @GeneratedValue(strategy=GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 5.2 操作5.2.1 保存12345678910111213/** * 保存 */@Testpublic void test1() &#123; Customer c = new Customer(); c.setCustName(\"hibernate jpa customer\"); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); s.save(c); tx.commit();&#125; 5.2.2 查询1234567891011/** * 查询一个 */@Testpublic void test2() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); System.out.println(c); tx.commit();&#125; 5.2.3 修改1234567891011/** * 修改 */@Testpublic void test3() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); c.setCustAddress(\"顺义区\"); tx.commit();&#125; 5.2.4 删除1234567891011/** * 删除操作 */@Testpublic void test4() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); s.delete(c); tx.commit();&#125;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(三)","date":"2020-05-31T08:27:38.000Z","path":"archives/3e87eb50.html","text":"1. 多表设计1.1 表之间的关系划分 一对一 一对多（多对一） 多对多 2. 如何确立和实现数据库中的表关系2.1 一对多的表关系在数据库中如何实现?使用外键约束。我们一般习惯把一的方称为主表，把多的一方称为从表。 什么是外键： 从表中有一列，该列的取值除了null之外，只能来源于主表的主键。默认情况下，外键字段的值是可以重复的。 2.2 多对多的表关系在数据库中如何实现？使用中间表。中间表中只有两个外键，引用两个多对多表的主键。不能有其他字段信息，至于中间表的主键，应该采用联合主键。 任何一个多方的表和中间表去比较，都是一对多的关系。 2.3 一对一的表关系在数据库中如何实现？有两种： 第一种：建立外键的方式： 使用外键约束，唯一约束，非空约束。它是把外键字段加了非空和唯一约束。从而实现了一对一。 第二种：使用主键的方式： 让其中一张表既是主键，又是外键。 2.4 如何确立两张表之间的关系：找外键。 3. 学习多表映射配置要遵循的步骤 第一步：确定两张表之间的关系 第二步：在数据库中实现两张表之间的关系建立 第三步：在实体类中描述出两个实体之间的关系 第四步：在映射配置文件中建立两个实体和两张表之间的关系 4. 一对多关系映射配置示例：客户和联系人两张表 4.1 确定两张表之间的关系一个客户可以包含多个联系人，多个联系人可以属于同一个客户。所以：客户和联系人之间的关系是一对多。 4.2 在数据库中实现两张表之间的关系建立实现一对多的关系，靠外键。客户表是主表，联系人表是从表。我们需要在联系人表中添加外键。 4.3 在实体类中描述出两个实体之间的关系主表的实体类应该包含从表实体类的集合引用，从表的实体类应该包含主表实体类的对象引用 123456789101112131415161718192021/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; /** * 一对多关系映射：一的一方 * 主表实体应该包含从表实体的集合引用 */ private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); ...&#125; 1234567891011121314151617181920212223/** * 联系人的实体类 * * @author wgy */public class LinkMan implements Serializable &#123; private Long lkmId; private String lkmName; private String lkmGender; private String lkmPhone; private String lkmMobile; private String lkmEmail; private String lkmPosition; private String lkmMemo; /** * 一对多关系映射，多的一方。 * 从表实体包含主表实体的对象引用 */ private Customer customer; ...&#125; 4.4 在映射配置文件中建立两个实体和两张表之间的关系客户配置文件： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml导入约束：dtd约束 --&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot; lazy&#x3D;&quot;true&quot;&gt; &lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&#x2F;&gt; &lt;!-- 一对多关系映射：主表实体的映射配置 涉及的标签： set： 作用：用于配置set集合属性。 属性： name：指定实体类中set集合的属性名称。 table：指定从表的名称。在一对多配置时可以不写。 key: 作用：用于映射外键字段。 属性： column：指定外键字段名称 one-to-many: 作用：用于建立一对多的映射配置 属性： class：用于指定从表实体的名称 --&gt; &lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 联系人配置文件： 1234567891011121314151617181920212223242526272829&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;LinkMan&quot; table&#x3D;&quot;cst_linkman&quot;&gt; &lt;id name&#x3D;&quot;lkmId&quot; column&#x3D;&quot;lkm_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;lkmName&quot; column&#x3D;&quot;lkm_name&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmGender&quot; column&#x3D;&quot;lkm_gender&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmPhone&quot; column&#x3D;&quot;lkm_phone&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmMobile&quot; column&#x3D;&quot;lkm_mobile&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmEmail&quot; column&#x3D;&quot;lkm_email&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmPosition&quot; column&#x3D;&quot;lkm_position&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmMemo&quot; column&#x3D;&quot;lkm_memo&quot;&#x2F;&gt; &lt;!-- 一对多关系映射：从表实体的映射配置 涉及的标签： many-to-one： 作用：建立多对一的映射配置 属性： name：从表实体中引用主表实体对象引用的名称 class：指定属性所对应的实体类名称 column：指定从表中外键字段的名称 --&gt; &lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 5. 多对多关系映射配置示例：用户和角色 5.1 确定两张表之间的关系一个用户可以有多个角色，一个角色可以赋给多个用户，所以用户和角色之间是多对多。 5.2 在数据库中实现两张表之间的关系建立在数据库中实现多对多要靠中间表。中间表中只能出现用户和角色主键。 5.3 在实体类中描述出两个实体之间的关系各自包含对方一个集合引用 12345678910111213141516/** * 用户的实体类 * * @author wgy */public class SysUser implements Serializable &#123; private Long userId; private String userName; private String userPassword; private Integer userState; //多对多关系映射：一个用户可以具备多个角色 private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); ...&#125; 123456789101112131415/** * 角色的实体类 * * @author wgy */public class SysRole implements Serializable &#123; private Long roleId; private String roleName; private String roleMemo; //多对多关系映射：一个角色可以赋予多个用户 private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); ...&#125; 5.4 在映射配置文件中建立两个实体和两张表之间的关系用户配置文件： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;SysUser&quot; table&#x3D;&quot;sys_user&quot;&gt; &lt;id name&#x3D;&quot;userId&quot; column&#x3D;&quot;user_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;userName&quot; column&#x3D;&quot;user_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;userPassword&quot; column&#x3D;&quot;user_password&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;userState&quot; column&#x3D;&quot;user_state&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 多对多关系映射 涉及的标签： set: 作用：用于映射set集合属性 属性： name：指定集合的名称 table：指定的是中间表的名称 key: 作用：用于映射外键字段 属性： column：指定的是当前实体在中间表的外键字段名称 many-to-many 作用：用于映射多对多的关系 属性： class：对方的实体类名称 column：对方在中间表的外键字段名称 --&gt; &lt;set name&#x3D;&quot;roles&quot; table&#x3D;&quot;user_role_ref&quot;&gt; &lt;key column&#x3D;&quot;user_id&quot;&gt;&lt;&#x2F;key&gt; &lt;many-to-many class&#x3D;&quot;SysRole&quot; column&#x3D;&quot;role_id&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 角色配置文件： 12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;SysRole&quot; table&#x3D;&quot;sys_role&quot;&gt; &lt;id name&#x3D;&quot;roleId&quot; column&#x3D;&quot;role_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;roleName&quot; column&#x3D;&quot;role_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;roleMemo&quot; column&#x3D;&quot;role_memo&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 多对多关系映射 --&gt; &lt;set name&#x3D;&quot;users&quot; table&#x3D;&quot;user_role_ref&quot; inverse&#x3D;&quot;true&quot;&gt; &lt;key column&#x3D;&quot;role_id&quot;&gt;&lt;&#x2F;key&gt; &lt;many-to-many class&#x3D;&quot;SysUser&quot; column&#x3D;&quot;user_id&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 6. 多表增删改操作6.1 一对多关系的操作6.1.1 保存操作6.1.1.1 正常保存12345678910111213141516171819/** * 保存操作 * 正常的保存：创建一个新的联系人，需要关联一个客户 */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c1 = s.get(Customer.class, 1L); //2.创建一个新的联系人 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人\"); //3.建立客户和联系人的关联关系（让联系人知道属于哪个客户即可） l.setCustomer(c1); //4.保存联系人 s.save(l); tx.commit();&#125; 6.1.1.2 特殊情况1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 特殊的情况： * 创建一个客户和一个联系人 * 建立联系人和客户的双向关联关系 * 使用符合原则的保存 * 原则是：先保存主表实体，再保存从表实体 * * 此时保存会有问题： * 我们保存两个实体，应该只有两条insert语句。 * 而执行结果却是多了一条update的语句。 * * 解决办法： * 让客户在执行操作的时候，放弃维护关联关系的权利。 * 配置的方式： * 在Customer的映射配置文件中的set标签上使用inverse属性。 * inverse含义：是否放弃维护关联关系的权利 * true：放弃 * false：不放弃（默认值） * */@Testpublic void test2()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_4\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_4\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 //持久态 有一级缓存和快照 s.save(c1); //持久态 有一级缓存和快照 s.save(l); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 6.1.1.3 级联保存级联操作是指当主控方执行保存、更新或者删除操作时，其关联对象（被控方）也执行相同的操作。 保存客户 123456789101112131415161718192021222324252627282930/** * 保存操作： * 级联保存 * 使用级联保存，配置的方式，仍然是找到Customer的映射配置文件的Set标签， * 也可以配置在many-to-one上。 * 在上面加入cascade属性 * cascade：配置级联操作 * 级联保存更新的取值：save-update */@Testpublic void test3()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_5\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_5\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 s.save(c1); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 保存联系人 123456789101112131415161718192021@Testpublic void test4()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_6\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_6\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 s.save(l); tx.commit();&#125; 1&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot;&#x2F;&gt; 6.1.2 更新操作123456789101112131415161718192021222324/** * 更新操作 * 需求： * 创建一个新的联系人，查询一个已有客户 * 联系人新联系人和已有客户的双向关联关系 * 更新客户 */@Testpublic void test5()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c1 = s.get(Customer.class, 1L); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人\"); //3.建立客户和联系人的关联关系（双向） l.setCustomer(c1); c1.getLinkmans().add(l); //4.更新客户 s.update(c1); tx.commit();&#125; 6.1.3 删除操作123456789101112131415161718192021/** * 删除操作 * 删除从表数据就是单表 * 删除主表数据： * 看有没有从表数据引用 * 有引用： * 在删除是，hibernate会把从表中的外键字段置为null，然后再删除主表数据。 * 如果外键字段有非空约束，则hibernate不能更新外键字段为null，会报错。 * 如果仍然想删除，此时需要使用级联删除。同时必须配置inverse属性是true。 * 没有引用： 就是单表，直接删 */@Testpublic void test6()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c9 = s.get(Customer.class, 5L); //2.删除id为5的客户 s.delete(c9); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update,delete&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 6.2 多对多关系的操作6.2.1 保存操作12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 保存操作 * 需求： * 创建2个用户和3个角色 * 让1号用户具备1号和2号角色 * 让2号用户具备2号和3号角色 * 保存用户和角色 */@Testpublic void test1()&#123; SysUser u1 = new SysUser(); u1.setUserName(\"用户1\"); SysUser u2 = new SysUser(); u2.setUserName(\"用户2\"); SysRole r1 = new SysRole(); r1.setRoleName(\"角色1\"); SysRole r2 = new SysRole(); r2.setRoleName(\"角色2\"); SysRole r3 = new SysRole(); r3.setRoleName(\"角色3\"); //建立双向关联关系 //先建立用户的 u1.getRoles().add(r1); u1.getRoles().add(r2); u2.getRoles().add(r2); u2.getRoles().add(r3); //再建立角色 r1.getUsers().add(u1); r2.getUsers().add(u1); r2.getUsers().add(u2); r3.getUsers().add(u2); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); s.save(u1); s.save(u2); s.save(r1); s.save(r2); s.save(r3); tx.commit();&#125; 6.2.2 删除操作12345678910111213141516/** * 删除操作 * 实际开发中：多对多的双向级联删除是禁止使用的 */@Testpublic void test2()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1查询id为3的用户 SysUser u3 = s.get(SysUser.class, 3L); //删除 s.delete(u3); tx.commit();&#125; 7. Hibernate中的多表查询7.1 对象导航查询7.1.1 概述对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。 例如：我们通过OID查询方式查出一个客户，可以调用Customer类中的getLinkMans()方法来获取该客户的所有联系人。 对象导航查询的使用要求是：两个对象之间必须存在关联关系。 7.1.2 对象导航检索示例查询联系人 123456789101112131415/** * 查询id为1的客户下所属联系人 * 一对多时，根据一的一方查询多的一方时，需要使用延迟加载。（默认配置即可） */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //查询id为1的客户 Customer c = s.get(Customer.class, 1L); System.out.println(c); Set&lt;LinkMan&gt; linkmans = c.getLinkmans(); System.out.println(linkmans); tx.commit();&#125; 查询客户 12345678910111213141516171819/** * 查询id为5的联系人属于哪个客户 * 多对一时，根据多的一方查询一的一方时，不需要使用延迟加载，而是使用立即加载，需要配置一下 * 需要找到联系人的映射配置文件：在many-to-one标签上使用lazy属性。 * 取值有： * false：使用立即加载。 * proxy：是看load方法是延迟加载还是立即加载 * no-proxy：不管 */@Testpublic void test2()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); LinkMan l = s.get(LinkMan.class, 5L); System.out.println(l); Customer c = l.getCustomer(); System.out.println(c); tx.commit();&#125; 1&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot; lazy&#x3D;&quot;false&quot;&#x2F;&gt; load方法加载 1234567891011121314/** * 关于load方法改为立即加载的方式 * 找到查询实体的映射配置文件，它的class标签上也有一个lazy属性。含义是：是否延迟加载 * true：延迟加载(默认值) * false：立即加载 */@Testpublic void test3()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.load(Customer.class, 1L); System.out.println(c); tx.commit();&#125; class标签的lazy：它只能管load方法是否是延迟加载。 set标签的lazy：它管查询关联的集合对象是否是延迟加载。 many-to-one的lazy：它管查询关联的主表实体是否是立即加载。","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(二)","date":"2020-05-28T16:09:27.000Z","path":"archives/4074cb7b.html","text":"1. Hibernate的持久化类和对象标识符1.1 持久化类的编写规范1.1.1 什么是持久化类Hibernate是持久层的ORM映射框架，专注于数据的持久化工作。 持久化就是将内存中的数据永久存储到关系型数据库中。 持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为是持久化类。其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。 1.1.2 持久化类的编写规范应该遵循JavaBean的编写规范: Bean：在软件开发中是指的可重用的组件。 JavaBean：指的是用java语言编写的可重用组件。在我们的实际项目中：domain,service,dao都可以看成是JavaBean。 编写规范： 类都是public的 一般实现序列化接口 类成员（字段）都是私有的 私有类成员都有公有get/set方法 类都有默认无参构造函数 细节： 数据类型的选择问题： 基本类型和包装类，选择哪个？由于包装类可以有null值。所以实际开发中都是用包装类。 1.2 Hibernate中对象标识符（OID）OID全称是Object Identifier，又叫做对象标识符。 它是hibernate用于区分两个对象是否是同一个对象的标识。 我们都知道，虚拟机内存区分两个对象看的是内存的地址是否一致。数据库区分两个对象，靠的是表的主键。Hibernate负责把内存中的对象持久化到数据库表中，靠的就是对象标识符来区分两个对象是否是同一个。实体类中映射主键的字段就是OID，如下图所示： 1.3 Hibernate的主键生成策略 2. Hibernate的一级缓存和对象状态2.1 Hibernate的一级缓存什么缓存？ 它就是内存中的临时数据。 什么样的数据适用于缓存，什么样的数据不适用缓存？ 适用缓存的数据： 经常查询的，并且不经常修改的。同时数据一旦出现问题，对最终结果影响不大的。 不适用缓存的数据： 不管是否经常查询，只要是经常修改的，都可以不用缓存。并且如果数据由于使用缓存，产生了异常数据，对最终结果影响很大，则不能使用。例如：股市的牌价，银行的汇率，商品的库存等等。 2.1.1 Hibernate中的一级缓存Hibernate的一级缓存就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。Hibernate的一级缓存的作用就是减少对数据库的访问次数。 在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存。只要 Session 实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。 Hibernate的一级缓存有如下特点： 当应用程序调用Session接口的save()、update()、saveOrUpdate时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。 当调用Session接口的load()、get()方法，以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中。 当调用Session的close()方法时，Session缓存会被清空。 2.1.2 测试一级缓存123456789101112131415161718192021/** * 证明一级缓存确实存在 */@Testpublic void test1() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //1.根据id查询客户 //先去数据库查询，并且把查询的结果存入了一级缓存之中 Customer c1 = s.get(Customer.class, 1L); System.out.println(c1); //2.根据id再次查询客户 //先去一级缓存中看看有没有，如果有的话，直接拿过来用，如果没有的话，再去查询。 Customer c2 = s.get(Customer.class, 1L); System.out.println(c2); //true 一级缓存缓存的是对象的地址 System.out.println(c1 == c2); tx.commit(); //session关闭，一级缓存就消失了 s.close();&#125; 2.1.3 快照机制Hibernate 向一级缓存放入数据时，同时复制一份数据放入到Hibernate快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。 1234567891011121314151617181920212223@Testpublic void test2() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //1.根据id查询客户 Customer c5 = s.get(Customer.class, 2L); //输出客户的地址：北京市顺义区 System.out.println(c5.getCustAddress()); //2.修改客户的地址为 湖北省 c5.setCustAddress(\"湖北省\"); //输出客户的地址：湖北省 System.out.println(c5.getCustAddress()); //没有写update语句 tx.commit(); //session关闭，一级缓存就消失了 s.close(); //打印c5的address，这个c5能不能用 答案是可以使用。 //此时输出是什么 北京市顺义区 | 湖北省 System.out.println(c5.getCustAddress());&#125; 2.2 对象的状态2.2.1 对象的状态说明Hibernate为了更好的来管理持久化类，特将持久化类分成了三种状态。在Hibernate中持久化的对象可以划分为四种状态，分别是瞬时态、持久态、脱管态和删除状态，一个持久化类的实例可能处于四种不同状态中的某一种，四种状态的详细介绍如下。 瞬时态（transient） 瞬时态也称为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，不存在持久化标识OID（相当于主键值），尚未与Hibernate Session关联，在数据库中也没有记录，失去引用后将被JVM回收。瞬时状态的对象在内存中是孤立存在的，与数据库中的数据无任何关联，仅是一个信息携带的载体。 持久态（persistent） 持久态的对象存在持久化标识OID ，加入到了Session缓存中，并且相关联的Session没有关闭，在数据库中有对应的记录，每条记录只对应唯一的持久化对象，需要注意的是，持久态对象是在事务还未提交前变成持久态的。 脱管态（detached） 脱管态也称离线态或者游离态，当某个持久化状态的实例与Session的关联被关闭时就变成了脱管态。脱管态对象存在持久化标识OID，并且仍然与数据库中的数据存在关联，只是失去了与当前Session的关联，脱管状态对象发生改变时Hibernate不能检测到。 删除状态（了解） 2.2.2 学习对象状态我们要明确的 是为了更好的掌握hibernate中操作的方法。 区分状态只有两个标识：一是否有OID，二是否和Session建立的关系 瞬时状态（临时状态） 标志：没有OID，和Session没有关系。 持久化状态 标志：有OID，和Session有关系。只有持久化状态的对象才会有一级缓存的概念。 脱管状态（游离状态） 标志：有OID，和Session没有关系。 删除状态（了解）： 标志：有OID，和Session有关系。同时已经调用了删除方法，即将从数据库中把记录删除。但是事务还没有提交，此时的对象状态是删除态。 1234567891011@Testpublic void test2() &#123; //瞬时状态 Customer c = new Customer(); c.setCustName(\"测试_saveOrUpdate\"); Session s1 = HibernateUtil.openSession(); Transaction tx1 = s1.beginTransaction(); s1.saveOrUpdate(c); tx1.commit(); s1.close();&#125; 1234567891011121314151617181920@Testpublic void test3() &#123; Session s1 = HibernateUtil.openSession(); Transaction tx1 = s1.beginTransaction(); //持久化状态 Customer c = s1.get(Customer.class, 9L); tx1.commit(); s1.close(); c.setCustAddress(\"顺义校区\"); //脱管状态 System.out.println(c); Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); //持久化状态 session.saveOrUpdate(c); tx.commit(); session.close();&#125; 3. Hibernate的事务控制3.1 配置Session和线程绑定保证在Service中开启的事务时使用的Session对象和DAO中多个操作使用的是同一个Session对象。 在hibernate.cfg.xml文件中配置 12&lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt;&lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; 获取Session时使用的方法 1234567891011121314151617181920212223242526272829/** * 抽取hibernate的工具类 * * @author wgy */public class HibernateUtil &#123; private static SessionFactory factory; //了解：hibernate把可以预见的异常都转成了运行时异常 static &#123; try &#123; Configuration configuration = new Configuration(); configuration.configure(); factory = configuration.buildSessionFactory(); &#125; catch (ExceptionInInitializerError e) &#123; throw new ExceptionInInitializerError(\"初始化SessionFactory失败,请检查配置文件\"); &#125; &#125; /** * 从当前线程上获取Session对象 * @return session */ public static Session getCurrentSession()&#123; //只有配置了把session和线程绑定之后，才能使用此方法，否则返回值是null return factory.getCurrentSession(); &#125;&#125; 验证session和线程绑定的配置 12345678910111213141516171819202122@Testpublic void test1() &#123; Session s1 = HibernateUtil.getCurrentSession(); Session s2 = HibernateUtil.getCurrentSession(); // true System.out.println(s1 == s2);&#125;/** * 当我们把session和线程绑定之后，hibernate就会在提交或者回滚事务之后，自动帮我们关闭session */@Testpublic void test2() &#123; //瞬时状态 Customer c = new Customer(); c.setCustName(\"测试_getCurrentSession\"); Session s1 = HibernateUtil.getCurrentSession(); Transaction tx1 = s1.beginTransaction(); s1.saveOrUpdate(c); tx1.commit(); //s1.close();&#125; 4. Hibernate中的查询方式hibernate中一共有5种查询方式 OID查询： 根据id查询一个实体。涉及的方法：get和load SQL查询： 使用SQL语句查询数据库。涉及两种方式： 第一种：SQLQuery（一般不怎么用） 1234567891011121314151617@Testpublic void testFindAll() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //使用session对象，获取一个查询对象Query SQLQuery sqlquery = s.createSQLQuery(\"select * from cst_customer\"); //使用sqlquery对象获取结果集 List&lt;Object[]&gt; list = sqlquery.list(); for (Object[] os : list) &#123; System.out.println(\"------------数组中的内容-----------\"); for (Object o : os) &#123; System.out.println(o); &#125; &#125; tx.commit(); s.close();&#125; 第二种：session的doWork方法，它可以拿到Connection 1234567891011121314151617181920/** * hibernate中如何使用原始JDBC API * JDBC的API： * Connection * Statement * PreparedStatement * ResultSet */@Testpublic void test1() &#123; //1.获取Session对象 Session s = HibernateUtil.openSession(); //2.调用doWork方法 s.doWork(new Work() &#123; @Override public void execute(Connection conn) throws SQLException &#123; System.out.println(conn.getClass().getName()); &#125; &#125;);&#125; HQL查询： 使用HQL语句查询数据库 QBC查询： 使用Criteria对象查询数据库 对象导航查询： 对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。 5. Hibernate查询对象的API5.1 Query5.1.1 概述Query代表面向对象的一个Hibernate查询操作。 在Hibernate中，通常使用session.createQuery()方法接受一个HQL语句，然后调用Query的list()或uniqueResult()方法执行查询。 所谓的HQL是Hibernate Query Language缩写，其语法很像SQL语法，但它是完全面向对象的。 在Hibernate中使用Query对象的步骤，具体所示： 获得Hibernate的Session对象 编写HQL语句 调用session.createQuery 创建查询对象 如果HQL语句包含参数，则调用Query的setXxx设置参数 调用Query对象的方法执行查询 HQL的说明： ​ 把表的名称换成实体类名称。把表字段名称换成实体类属性名称。 例如： 12345SQL：select * from cst_customer where cust_name like ?HQL：select * from Customer where custName &#x3D; ?其中select * 可以省略，写为：from Customer where custName &#x3D; ? 5.1.2 常用查询5.1.2.1 基本查询12345678910111213141516/** * 基本查询 */@Testpublic void test1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.2 条件查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 条件查询 */@Testpublic void test2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer where custLevel = ? and custName like ?\"); //给参数占位符赋值 //hibernate的参数占位符是从0开始的 query.setString(0, \"23\"); query.setString(1, \"%集%\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125;/** * 条件查询 * 给参数占位符提供一个具体的名称 * 参数占位符的写法： * :名称 * 赋值的时候不需要写冒号，直接写名称 */@Testpublic void test3()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.获取Query对象 Query query = s.createQuery(\"from Customer where custName like :custName and custLevel = :custLevel\"); //2.给参数占位符赋值 //query.setString(\"custName\", \"%集%\"); //query.setString(\"custLevel\", \"普通客户\"); query.setParameter(\"custLevel\", \"23\"); query.setParameter(\"custName\", \"%集%\"); //3.执行对象的方法，获取结果集 List list = query.list(); for(Object o : list)&#123; System.out.println(o); &#125; tx.commit();&#125; 5.1.2.3 分页查询123456789101112131415161718192021222324252627282930/** * 分页查询 * mysql分页关键字 * limit * Limit的两个参数含义 * 第一个：查询的开始记录索引 * 第二个：每次查询的条数 * hibernate为我们提供了两个方法： * setFirstResult：设置查询的开始记录索引 * setMaxResults：设置每次查询的条数 * * 不管是用什么数据库，涉及分页的都是这两个方法。 * 因为SQL语句的生成已经是hibernate的事了。 */@Testpublic void test5() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer\"); //设置分页的方法 query.setFirstResult(2); query.setMaxResults(2); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.4 排序查询12345678910111213141516/** * 排序查询 */@Testpublic void test4() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer order by custId desc\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.5 统计查询12345678910111213141516171819202122232425/** * HQL使用聚合函数： * 统计查询 * 聚合函数： * count sum max min avg * * sql语句使用聚合函数时，在不使用group by子句的情况下，返回的结果，永远只有一行一列的情况。 * * 在SQL语句时： * select count(*) from table 它是统计所有字段，效率没有只统计主键字段高 * select count(主键) from table 它和第一个的结果是一样的，但是效率更高 * select count(非主键) from table 只统计不为null的字段 */@Testpublic void test1()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.获取Query对象 Query query = s.createQuery(\"select count(*) from Customer\"); //2.获取结果集 //当返回的结果唯一时，可以使用此方法。如果返回的结果不唯一，使用了此方法会抛异常。 Long total = (Long)query.uniqueResult(); System.out.println(total); tx.commit();&#125; 5.1.2.6 投影查询12345678910111213141516171819202122/** * 投影查询 * 当我们在查询实体时，只需要部分字段，而是全部。并且希望它的返回结果使用实体类来封装，而不是Object[] * 这个时候我们称之为创建实体类的投影 * * 投影查询的用法： * 1.查询语句需要时使用new关键字 * 2.在实体类中添加对应参数列表的构造函数 */@Testpublic void test7() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"select new com.wgy.domain.Customer(custId,custName) from Customer\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 123456789101112131415161718192021222324252627/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; public Customer() &#123; &#125; /** * //提供对应参数列表的构造函数 * @param custId * @param custName */ public Customer(Long custId, String custName) &#123; this.custId = custId; this.custName = custName; &#125; ..... 5.1.3 Query中的方法说明 list方法：该方法用于查询语句，返回的结果是一个list集合。 uniqueResult方法：该方法用于查询，返回的结果是一个Object对象。 setter方法：Query接口中提供了一系列的setter方法用于设置查询语句中的参数，针对不同的数据类型，需要用到不同的setter方法。 uniqueResult()方法：该方法用于返回唯一的结果，在确保只有一条记录的查询时可以使用该方法。 setFirstResult()方法：该方法可以设置获取第一个记录的位置，也就是它表示从第几条记录开始查询，默认从0开始计算。 setMaxResult()方法：该方法用于设置结果集的最大记录数，通常与setFirstResult()方法结合使用，用于限制结果集的范围，以实现分页功能。 5.2 Criteria5.2.1 概述Criteria是一个完全面向对象，可扩展的条件查询API，通过它完全不需要考虑数据库底层如何实现，以及SQL语句如何编写，它是Hibernate框架的核心查询对象。 Criteria 查询，又称为QBC查询（Query By Criteria），它是Hibernate的另一种对象检索方式。 通常，使用Criteria对象查询数据的主要步骤，具体如下： 获得Hibernate的Session对象 通过Session获得Criteria对象 使用Restrictions的静态方法创建Criterion条件对象。Restrictions类中提供了一系列用于设定查询条件的静态方法，这些静态方法都返回Criterion实例，每个Criterion实例代表一个查询条件 向Criteria对象中添加Criterion 查询条件。Criteria的add()方法用于加入查询条件 执行Criterita的 list() 或uniqueResult() 获得结果 细节： HQL能查的，QBC都能查，反之亦然。 5.2.2 常用查询5.2.2.1 基本查询1234567891011121314151617/** * 基本查询 */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 //它就相当于HQL的from Customer Criteria c = s.createCriteria(Customer.class); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.2 条件查询12345678910111213141516171819/** * 条件查询 */@Testpublic void test2() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //使用criteria对象的add方法来添加条件 c.add(Restrictions.eq(\"custLevel\", \"23\")); c.add(Restrictions.like(\"custName\", \"%集%\")); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.3 分页查询1234567891011121314151617181920/** * 分页查询 * QBC的分页查询和HQL的分页查询所用的方法和方法的含义都是一模一样的 */@Testpublic void test4() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //设置分页条件 c.setFirstResult(2); c.setMaxResults(2); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.4 排序查询123456789101112131415161718/** * 排序查询 */@Testpublic void test3() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //添加排序 c.addOrder(Order.desc(\"custId\")); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.5 统计查询1234567891011121314151617/** * 统计（投影）查询 */@Testpublic void test5() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //设置聚合函数 //c.setProjection(Projections.rowCount()); c.setProjection(Projections.count(\"custId\")); //2. 获取结果集 Long count = (Long)c.uniqueResult(); System.out.println(count); tx.commit();&#125; 5.2.2.6 离线查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 离线查询 * 离线： * 它是和在线对应的。 * Criteria对象是一个在线对象，它是由一个可用的（活动的）Session对象获取的出来的。 * 当session失效时，就无法再获取该对象了。 * 有一个对象，它也可以用于设置条件，但是获取的时候并不需要Session对象。该对象就叫做离线对象： * DetachedCriteria对象 * 使用该对象进行的查询就叫做：离线查询 * * 如何获取该对象 * DetachedCriteria dCriteria = DetachedCriteria.forClass(要查询的实体类字节码); */@Testpublic void testServlet()&#123; //1.获取离线对象，不需要Session DetachedCriteria dc = DetachedCriteria.forClass(Customer.class); //2.封装查询条件 dc.add(Restrictions.eq(\"custLevel\", \"23\")); dc.add(Restrictions.like(\"custName\",\"%集%\")); List list = testService(dc); for(Object o : list)&#123; System.out.println(o); &#125;&#125;private List testService(DetachedCriteria dc) &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); List list = testDao(dc); tx.commit(); return list; &#125;catch(Exception e)&#123; tx.rollback(); &#125; return null;&#125;private List testDao(DetachedCriteria dc) &#123; Session s = HibernateUtil.getCurrentSession(); //把离线对象转成在线对象 Criteria c = dc.getExecutableCriteria(s); return c.list();&#125; 5.2.3 QBC常用查询条件说明 短语 含义 Restrictions.eq 等于= Restrictions.allEq 使用Map,使用key/value进行多个等于的判断 Restrictions.gt 大于&gt; Restrictions.ge 大于等于&gt;= Restrictions.lt 小于&lt; Restrictions.le 小于等于&lt;= Restrictions.between 对应sql的between子句 Restrictions.like 对应sql的like子句 Restrictions.in 对应sql的in子句 Restrictions.and and 关系 Restrictions.or or关系 Restrictions.sqlRestriction Sql限定查询 Restrictions.asc() 根据传入的字段进行升序排序 Restrictions.desc() 根据传入的字段进行降序排序 运算类型 HQL运算符 QBC运算方法 type = Restrictions.eq() Restrictions.not(Restrictions.eq()) >= Restrictions.ge()","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(一)","date":"2020-05-28T06:17:43.000Z","path":"archives/ef455019.html","text":"1. Hibernate和ORM的概念1.1 Hibrenate概述它是一个轻量级，企业级，开源的ORM持久层框架。是可以操作数据库的框架。 框架：它就是一个架构。 通常情况下，软件工程的持久层解决方案，一个为主一个为辅。两者并存（写SQL语句的和不写SQL语句的 轻量级：指的是使用时依赖的资源很少。（目前我们使用的阶段，只依赖log4j，c3p0连接池） 企业级：指的是在企业级应用中使用的比较多 开源的：开放源代码。 ORM的操作方式：建立对象关系映射，实现操作实体类就相当于操作数据库表。 Hibernate框架是当今主流的Java持久层框架之一，由于它具有简单易学、灵活性强、扩展性强等特点，能够大大地简化程序的代码量，提高工作效率，因此受到广大开发人员的喜爱。 Hibernate是一个开放源代码的ORM框架，它对JDBC进行了轻量级的对象封装，使得Java开发人员可以使用面向对象的编程思想来操作数据库。 1.2 ORMObject Relational Mapping 对象关系映射 就是建立实体类和数据库表的对应关系。 实现操作实体类对象就相当于操作数据库表 Object Relation Mapping 对象关系映射。 对象-关系映射（OBJECT/RELATIONALMAPPING，简称ORM），是随着面向对象的软件开发方法发展而产生的。用来把对象模型表示的对象映射到基于S Q L 的关系模型数据库结构中去。这样，我们在具体的操作实体对象的时候，就不需要再去和复杂的 SQ L 语句打交道，只需简单的操作实体对象的属性和方法[2] 。O R M 技术是在对象和关系之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化[1] 。 简单的说就是把我们程序中的实体类和数据库表建立起来对应关系。 1.3 为什么要学习Hibernate与其它操作数据库的技术相比，Hibernate具有以下几点优势： Hibernate对JDBC访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了DAO（Data Access Object，数据访问对象）层编码工作。 Hibernate的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。 可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。 明确： ​ 操作实体类就相当于操作数据库表 使用传统的JDBC开发应用系统时，如果是小型应用系统，并不觉得有什么麻烦，但是对于大型应用系统的开发，使用JDBC就会显得力不从心。例如对几十、几百张包含几十个字段的表进行插入操作时，编写的SQL语句不但很长，而且繁琐，容易出错；在读取数据时，需要写多条getXxx语句从结果集中取出各个字段的信息，不但枯燥重复，并且工作量非常大。为了提高数据访问层的编程效率，Gavin King开发出了一个当今最流行的的ORM框架，它就是Hibernate框架。 所谓的ORM就是利用描述对象和数据库表之间映射的元数据，自动把Java应用程序中的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库表的操作。可以把ORM理解为关系型数据和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。ORM原理如图所示。 2. CRMCRM：客户关系管理系统 CRM（Customer Relationship Management）客户关系管理，是利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，向客户提供创新式的个性化的客户交互和服务的过程。 其最终目标是将面向客户的各项信息和活动集成起来，组建一个以客户为中心的企业，实现对面向客户的活动的全面管理。 3. Hibernate快速入门3.1 需求介绍保存一个客户到数据库的客户表中。 3.2 搭建Hibernate开发环境3.2.1 第一步：拷贝必备的jar包到开发目录数据库驱动包，如下图： Hibernate/lib/required/*.jar，如下图： 日志记录的包，如下图: 3.2.2 第二步：创建数据库和实体类持久化类是应用程序中的业务实体类，这里的持久化是指类的对象能够被持久化保存到数据库中。Hibernate使用普通Java对象（Plain Old Java Object），即POJO的编程模式来进行持久化。POJO类中包含的是与数据库表相对应的各个属性，这些属性通过getter和setter方法来访问，对外部隐藏了内部的实现细节。下面就来编写Customer持久化类。 在项目src目录下，创建cn.wgy.domain包，并在包中创建实体类Customer（对应数据库表cst_customer），Customer类包含与cst_customer数据表字段对应的属性，以及相应的getXxx ()和setXxx ()方法。 1234567891011&#x2F;*创建客户表*&#x2F;CREATE TABLE &#96;cst_customer&#96; ( &#96;cust_id&#96; bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#39;客户编号(主键)&#39;, &#96;cust_name&#96; varchar(32) NOT NULL COMMENT &#39;客户名称(公司名称)&#39;, &#96;cust_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户信息来源&#39;, &#96;cust_industry&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户所属行业&#39;, &#96;cust_level&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户级别&#39;, &#96;cust_address&#96; varchar(128) DEFAULT NULL COMMENT &#39;客户联系地址&#39;, &#96;cust_phone&#96; varchar(64) DEFAULT NULL COMMENT &#39;客户联系电话&#39;, PRIMARY KEY (&#96;cust_id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;94 DEFAULT CHARSET&#x3D;utf8; 123456789101112131415/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; ...&#125; 3.2.3 第三步：编写映射配置文件（xml）实体类Customer目前还不具备持久化操作的能力，而Hibernate需要知道实体类Customer映射到数据库Hibernate中的哪个表，以及类中的哪个属性对应数据库表中的哪个字段，这些都需要在映射文件中配置。 在实体类Customer所在的包中，创建一个名称为Customer.hbm.xml的映射文件，在该文件中定义了实体类Customer的属性是如何映射到cst_customer表的列上的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml --&gt;&lt;!-- 导入约束:dtd约束 位置：在Hibernate的核心jar包中名称为hibernate-mapping-3.0.dtd 明确该文件中的内容： 实体类和表的对应关系 实体类中属性和表的字段的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;!-- package属性用于设定包的名称，接下来该配置文件中凡是用到此包中的对象时都可以省略包名 --&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;!-- class标签 作用：建立实体类和表的对应关系 属性： name：指定实体类的名称 table：指定数据库表的名称 --&gt; &lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot;&gt; &lt;!-- id标签 作用：用于映射主键 属性： name：指定的是属性名称。也就是get&#x2F;set方法后面的部分，并且首字母要转小写。 column:指定的是数据库表的字段名称 --&gt; &lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt; &lt;!-- generator标签： 作用：配置主键的生成策略。 属性： class:指定生成方式的取值。 取值之一：native。使用本地数据库的自动增长能力。 mysql数据库的自动增长能力是让某一列自动+1。但是不是所有数据库都支持这种方式。 --&gt; &lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;!-- property标签： 作用：映射其他字段 属性： name：指定属性的名称。和id标签的name属性含义一致 column：指定数据库表的字段名称 --&gt; &lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 3.2.4 第四步：编写主配置文件（hibernate.cfg.xml）Hibernate的映射文件反映了持久化类和数据库表的映射信息，而Hibernate的配置文件则主要用来配置数据库连接以及Hibernate运行时所需要的各个属性的值。在项目的src下创建一个名称为hibernate.cfg.xml的文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 在类的根路径下创建名称为hibernate.cfg.xml的配置文件 --&gt;&lt;!-- 导入dtd约束： 位置：在核心jar包中的名称为hibernate-configuration-3.0.dtd中--&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory SessionFactory的作用就是用于创建Session对象的。 Session对象就是hibernate中操作数据库的核心对象。 此处的配置不要求背，但是要求记住创建SessionFactory必须的三部分信息 第一部分： 连接数据库的信息 第二部分： hibernate的可选配置 第三部分： 映射文件的位置 --&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;property&gt; &lt;!-- 是否让hibernate根据表结构的变化来生成DDL语句 DDL:数据定义语言 hibernate可以根据映射文件来为我们生成数据库的表结构。但是他不能生成数据库。 hbm2ddl.auto的取值 * none:不用Hibernate自动生成表. * create:每次都会创建一个新的表.(测试) * create-drop:每次都会创建一个新的表，执行程序结束后删除这个表.(测试) * update:如果数据库中有表，使用原来的表，如果没有表，创建一个新表.可以更新表结构。 * validate:只会使用原有的表.对映射关系进行校验. --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping resource&#x3D;&quot;com&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 3.4 实现保存操作在项目中新建一个名称为cn.wgy.test的包，然后在包中建立一个名为HibernateDemo1Test.java的文件，该文件是用来测试的类文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * hibernate的入门案例 * 需求： * 实现保存一个客户到数据库 * * @author wgy */public class HibernateDemo1Test &#123; /** * 步骤分析 * 1、解析主配置文件 * 2、根据配置文件创建SessionFactory * 3、根据SessionFactory创建Session * 4、开启事务 * 5、执行操作（保存） * 6、提交事务 * 7、释放资源 */ @Test public void test1() &#123; Customer customer = new Customer(); customer.setCustName(\"测试1\"); // 1、解析主配置文件 Configuration configuration = new Configuration(); configuration.configure(); // 2、根据配置文件创建SessionFactory SessionFactory sessionFactory = configuration.buildSessionFactory(); // 3、根据SessionFactory创建Session Session session = sessionFactory.openSession(); // 4、开启事务 Transaction transaction = session.beginTransaction(); // 5、执行操作（保存） session.save(customer); // 6、提交事务 transaction.commit(); // 7、释放资源 session.close(); sessionFactory.close(); &#125;&#125; 3.5 入门案例的执行过程首先创建Configuration类的实例，并通过它来读取并解析配置文件hibernate.cfg.xml。然后创建SessionFactory读取解析映射文件信息，并将Configuration对象中的所有配置信息拷贝到SessionFactory内存中。接下来，打开Session，让SessionFactory提供连接，并开启一个事务，之后创建对象，向对象中添加数据，通过session.save()方法完成向数据库中保存数据的操作。最后提交事务，并关闭资源。 4. Hibernate中API介绍4.1 Configuration对象4.1.1 作用在使用Hibernate时，首先要创建Configuration实例，Configuration实例主要用于启动、加载、管理hibernate的配置文件信息。在启动Hibernate的过程中，Configuration实例首先确定Hibernate配置文件的位置，然后读取相关配置，最后创建一个唯一的SessionFactory实例。Configuration对象只存在于系统的初始化阶段，它将SessionFactory创建完成后，就完成了自己的使命。 Hibernate通常使用Configuration config = new Configuration().configure();的方式创建实例，此种方式默认会去src下读取 hibernate.cfg.xml配置文件。如果不想使用默认的hibernate.cfg.xml配置文件，而是使用指定目录下（或自定义）的配置文件，则需要向configure()方法中传递一个文件路径的参数，其代码写法如下： 1Configuration config &#x3D; new Configuration().configure(&quot;xml文件位置&quot;); 此种写法hibernate会去指定位置查找配置文件，例如，想要使用src下config包中的 hibernate.cfg.xml文件，只需将文件位置加入configure()中即可，其代码如下所示： 1Configuration config = new Configuration().configure(\"/config/hibernate.cfg.xml\"); 【加载映射文件】 Hibernate除了可以使用Configuration对象加载核心配置文件以外，还可以利用该对象加载映射文件。因为如何使用properties文件作为Hibernate的核心配置文件，其他的属性可以使用key=value的格式来设置，但是映射没有办法加载。这时这个对象就有了用武之地。可以在手动编写代码的时候去加载映射文件。 123Configuration configuration &#x3D; new Configuration().configure(&quot;xml文件位置&quot;);configuration.addResource(&quot;cn&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;); 4.1.2 常用方法1234567891011121314默认构造函数： 它只能加载类的根路径下，名称为hibernate.properties的配置文件。不能加载xmlconfigure()： 它用于加载类的根路径下，名称为hibernate.cfg.xml的配置文件。 configuration.configure();buildSessionFactory()： 根据配置文件，构建SessionFactory SessionFactory sessionFactory &#x3D; configuration.buildSessionFactory();addResource(String url); 指定映射文件的位置 configuration.addResource(&quot;com&#x2F;itheima&#x2F;domain&#x2F;Customer.hbm.xml&quot;);addClass(Class clazz); 指定实体类的字节码 configuration.addClass(Customer.class); 4.2 SessionFactory4.2.1 作用SessionFactory接口负责Hibernate的初始化和建立Session对象。它在Hibernate中起到一个缓冲区作用，Hibernate可以将自动生成的SQL语句、映射数据以及某些可重复利用的的数据放在这个缓冲区中。同时它还保存了对数据库配置的所有映射关系，维护了当前的二级缓存。 SessionFactory 实例是通过Configuration对象获取的，其获取方法如下所示。 1SessionFactory sessionFactory = config.buildSessionFactory(); 4.2.2 常用方法1openSession()：每次都是生成一个新的Session 4.2.3 细节该对象维护了很多信息： 连接数据库的信息 hibernate的基本配置 映射文件的位置，以及映射文件中的配置 一些预定义的SQL语句（这些语句都是通用的） 比如：全字段保存，根据id的全字段更新，根据id的全字段查询，根据id的删除等等。 hibernate的二级缓存（了解） 同时，它是一个线程安全的对象，所有由该工厂生产的Session都共享工厂中维护的数据。 4.2.4 使用原则由于SessionFactory维护了很多信息同时又是线程安全的，一般情况下，一个项目中只需要一个SessionFactory，只有当应用中存在多个数据源时，才为每个数据源建立一个SessionFactory实例。因此，不应该反复的创建和销毁。 原则：一个应用应该只有一个SessionFactory。在应用加载时创建，应用卸载时销毁。 4.2.5 在hibernate中使用数据源(连接池)SessionFactory内部还维护了一个连接池，如果我们需要使用第三方的连接池如C3P0，那么需要我们自己手动进行配置 配置C3P0步骤如下： 导入连接池的jar包 在hibernate主配置文件中配置 1234&lt;!-- 配置数据源的提供商 --&gt;&lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt; org.hibernate.connection.C3P0ConnectionProvider&lt;&#x2F;property&gt; 4.3 Session4.3.1 作用Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。 创建SessionFactory实例后，就可以通过它获取Session实例。获取Session实例有两种方式，一种是通过openSession()方法，另一种是通过getCurrentSession()方法。两种方法获取session的代码如下所示： 12345//采用openSession方法创建sessionSession session = sessionFactory.openSession();//采用getCurrentSession()方法创建sessionSession session = sessionFactory.getCurrentSession(); 以上两种获取session实例方式的主要区别是，采用openSession方法获取Session实例时，SessionFactory直接创建一个新的Session实例，并且在使用完成后需要调用close方法进行手动关闭。而getCurrentSession方法创建的Session实例会被绑定到当前线程中，它在提交或回滚操作时会自动关闭。 4.3.2 常用方法123456789save(Object entity); ：保存一个实体到数据库update(Object entity);：更新一个实体delete(Object entity);：删除一个实体get(Class clazz,Serializable id);：根据id查询一个实体。参数的含义：Class表示要查询的实体类字节码。Serializable就是查询的条件。beginTransaction();：开启事务，并返回事务对象 4.3.3 细节由于SessionFactory已经维护了很多数据，所以Session就维护较少的内容。 它是一个轻量级对象。并且：它不是线程安全的！！！！！！！ 它维护了hibernate的一级缓存。 它的反复创建销毁不会消耗太多资源。 4.3.4 使用原则每个线程都只有一个Session对象。 4.4 Transaction4.4.1 作用Transaction接口主要用于管理事务，它是Hibernate的数据库事务接口，且对底层的事务接口进行了封装。Transaction接口的事务对象是通过Session对象开启的，其开启方式如下所示。 1Transaction transaction &#x3D; session.beginTransaction(); 4.4.2 常用方法123commit()：提交事务rollback()：回滚事务 Session执行完数据库操作后，要使用Transaction接口的commit()方法进行事务提交，才能真正的将数据操作同步到数据库中。发生异常时，需要使用rollback()方法进行事务回滚，以避免数据发生错误。因此，在持久化操作后，必须调用Transaction接口的commit()方法和rollback()方法。如果没有开启事务，那么每个Session的操作，都相当于一个独立的操作。 123456789101112131415161718@Testpublic void testSave1() &#123; Customer c = new Customer(); c.setCustName(\"测试保存功能\"); Transaction tx = null; Session s = null; try &#123; s = HibernateUtil.openSession(); tx = s.beginTransaction(); //保存客户 s.save(c); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); &#125; finally &#123; s.close(); &#125;&#125; 5. 抽取HibernateUtil工具类1234567891011121314151617181920212223242526272829/** * hibernate的工具类 * 用于生产一个Session对象 * * @author wgy */public class HibernateUtil &#123; private static SessionFactory factory; static&#123; try &#123; Configuration cfg = new Configuration(); cfg.configure(); factory = cfg.buildSessionFactory(); &#125; catch (Exception e) &#123; //e.printStackTrace(); throw new ExceptionInInitializerError(\"初始化SessionFactory失败\"); &#125; &#125; /** * 获取一个新的Session对象 * @return */ public static Session openSession()&#123; return factory.openSession(); &#125;&#125; 6. 案例：使用Hibernate实现CRUD6.1 保存操作12345678910111213141516@Testpublic void testAdd()&#123; Customer c = new Customer(); c.setCustName(\"测试保存功能\"); //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 //Transaction tx = session.beginTransaction(); //3.保存客户 session.save(c); //4.提交事务 //tx.commit(); //5.释放资源 session.close();&#125; 6.2 查询一个实体1234567891011121314@Testpublic void testFindOne()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为2的客户 Customer c = session.get(Customer.class, 2L); System.out.println(c); //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.3 修改操作1234567891011121314151617@Testpublic void testUpdate()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为2的客户 Customer c = session.get(Customer.class, 2L); //修改客户的地址为：湖北省 c.setCustAddress(\"湖北省\"); //执行更新 session.update(c); //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.4 删除操作123456789101112131415@Testpublic void testDelete()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为1的客户 Customer c = session.get(Customer.class, 1L); //删除实体 session.delete(c);//delete from cst_customer where cust_id = ? //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.5 实体查询get和load方法6.5.1 实体查询的概念所谓实体查询即OID查询，就是使用主键作为条件来查询一个实体。其中涉及的方法是Session对象get方法和load方法。 6.5.2 方法的说明get方法： 12345678910111213141516/** * 根据id查询一个实体 * @param entityType 指的是要查询的实体类字节码对象 * @param id 查询的条件，即主键的值。 * @return 返回的是实体类对象 */&lt;T&gt; T get(Class&lt;T&gt; entityType, Serializable id);@Testpublic void testGet()&#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 2L); System.out.println(\"get : \"+c.toString()); tx.commit();&#125; load方法： 12345678910111213141516/** * 根据id查询一个实体 * @param theClass 指的是要查询的实体类字节码 * @param id查询的条件，即主键的值。 * @return 返回的是实体类对象或者是实体类对象的代理对象 */&lt;T&gt; T load(Class&lt;T&gt; theClass, Serializable id);@Testpublic void testLoad()&#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); Customer c = s.load(Customer.class, 2L); System.out.println(\"load : \"+c.toString()); tx.commit();&#125; 6.5.3 get和load的区别 查询的时机不一样。 get的查询时机：每次调用get方法时，马上发起查询。 立即加载 load的查询时机：每次真正使用的时候，发起查询。 延迟加载 懒加载 惰性加载 返回的结果不一样。 get方法返回的对象是实体类类型 load方法返回的对象是实体类类型的代理对象 load方法默认情况下是延迟，可以通过配置的方式改为立即加载。 12&lt;!-- 由于load方法是hibernate的方法所以只有XML的方式：--&gt;&lt;class name=\"Customer\" table=\"cst_customer\" lazy=\"false\"&gt;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"使用hexo+github搭建免费个人博客","date":"2020-05-15T11:40:37.000Z","path":"archives/52429b60.html","text":"前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi wgy1993! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置： 12$ git config --global user.name &quot;yourname&quot;&#x2F;&#x2F; 你的github用户名，非昵称$ git config --global user.email &quot;xxx@163.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱 具体这个配置是干嘛的我没仔细深究。 使用hexo写博客hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装1$ npm install -g hexo 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\\MyGitWorkSpace\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /e/MyGitWorkSpace/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了 浏览目录 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： 12$ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里： 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法： 1234deploy: type: git repository: git@github.com:wgy1993&#x2F;wgy1993.github.io.git branch: master 错误写法： 1234deploy: type: github repository: https:&#x2F;&#x2F;github.com&#x2F;wgy1993&#x2F;wgy1993.github.io.git branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件： 1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 保留README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 常用hexo命令常见命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写： 1234hexo n &#x3D;&#x3D; hexo newhexo g &#x3D;&#x3D; hexo generatehexo s &#x3D;&#x3D; hexo serverhexo d &#x3D;&#x3D; hexo deploy 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 写博客定位到我们的hexo根目录，执行命令： 1hexo new &#39;my-first-blog&#39; hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 那么hexo new page &#39;postName&#39;命令和hexo new &#39;postName&#39;有什么区别呢？ 1hexo new page &quot;my-second-blog&quot; 生成如下： 最终部署时生成：hexo\\public\\my-second-blog\\index.html，但是它不会作为文章出现在博文目录。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上``即可，例如： 12345678910111213# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； 最终效果：","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wgy1993.gitee.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://wgy1993.gitee.io/tags/GitHub/"}]}]