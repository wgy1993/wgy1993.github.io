[{"title":"SpringMVC(三)","date":"2020-06-26T07:55:56.000Z","path":"archives/94a25162.html","text":"1. SSM 整合1.1 搭建整合环境1.1.1 整合说明SSM整合可以使用多种方式，选择XML + 注解的方式 1.1.2 整合的思路 先搭建整合的环境 先把Spring的配置搭建完成 再使用Spring整合SpringMVC框架 最后使用Spring整合MyBatis框架 1.1.3 创建数据库和表结构1234567create database ssm;use ssm;create table account( id int primary key auto_increment, name varchar(20), money double); 1.1.4 创建maven的工程1234&lt;groupId&gt;com.wgy&lt;/groupId&gt;&lt;artifactId&gt;ssm&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt; 1.1.5 导入依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1.1.6 编写实体类123456789101112/** * 帐户 * * @author wgy */public class Account implements Serializable &#123; private Integer id; private String name; private Double money; ...&#125; 1.1.7 编写dao接口123456789101112131415161718192021/** * 帐户dao接口 * * @author wgy */public interface AccountDao &#123; /** * 查询所有账户 * * @return */ public List&lt;Account&gt; findAll(); /** * 保存帐户信息 * * @param account */ public void saveAccount(Account account);&#125; 1.1.8 编写service接口和实现类接口: 12345678910111213141516171819202122/** * 账户业务接口 * * @author wgy */public interface AccountService &#123; /** * 查询所有账户 * * @return */ public List&lt;Account&gt; findAll(); /** * 保存帐户信息 * * @param account */ public void saveAccount(Account account);&#125; 实现类: 12345678910111213141516171819/** * 账户业务实现类 * * @author wgy */@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; @Override public List&lt;Account&gt; findAll() &#123; System.out.println(\"业务层：查询所有账户...\"); return null; &#125; @Override public void saveAccount(Account account) &#123; System.out.println(\"业务层：保存帐户...\"); &#125;&#125; 1.2 整合步骤1.2.1 保证 Spring 框架在 web 工程中独立运行1.2.1.1 编写 spring 配置文件并导入约束123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt; &lt;context:component-scan base-package=\"com.wgy\"&gt; &lt;!--配置哪些注解不扫描--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 1.2.1.2 测试 spring1234567891011121314151617/** * 测试spring * * @author wgy */public class SpringTest &#123; @Test public void run1() &#123; // 加载配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\"); // 获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); // 调用方法 as.findAll(); &#125;&#125; 1.2.2 保证 SpringMVC 在 web 工程中独立运行1.2.2.1 在 web.xml 中配置核心控制器123456789101112131415161718192021222324252627282930&lt;!--配置前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc.xml配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动服务器，创建该servlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--解决中文乱码的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 1.2.2.2 编写 SpringMVC 的配置文件12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开启注解扫描，只扫描Controller注解--&gt; &lt;context:component-scan base-package=\"com.wgy\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!--配置的视图解析器对象--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--过滤静态资源--&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!--开启SpringMVC注解的支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 1.2.2.3 编写 Controller 和 和 jsp 页面JSP: 1&lt;a href=\"account/findAll\"&gt;查询所有&lt;/a&gt; 12345678910111213141516&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;查询所有的帐户&lt;/h3&gt;&lt;c:forEach items=\"$&#123;list&#125;\" var=\"account\"&gt; $&#123;account.name&#125;&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; controller: 123456789101112131415/** * 帐户控制器 * * @author wgy */@Controller@RequestMapping(\"/account\")public class AccountController &#123; @RequestMapping(\"/findAll\") public String findAll(Model model) &#123; System.out.println(\"表现层：查询所有账户...\"); return \"list\"; &#125;&#125; 1.2.3 整合 Spring 和 SpringMVC目的：在controller中能成功的调用service对象中的方法。 1.2.3.1 配置监听器实现启动服务创建容器web.xml 123456789&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--设置配置文件的路径--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 1.2.3.2 在controller中注入service对象123456789101112131415161718192021/** * 帐户控制器 * * @author wgy */@Controller@RequestMapping(\"/account\")public class AccountController &#123; @Autowired private AccountService accountService; @RequestMapping(\"/findAll\") public String findAll(Model model) &#123; System.out.println(\"表现层：查询所有账户...\"); // 调用service的方法 List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(\"list\", list); return \"list\"; &#125;&#125; 1.2.4 保证 MyBatis 框架在 web 工程中独立运行1.2.4.1 编写SqlMapConfig.xml的配置文件1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"dev\"&gt; &lt;environment id=\"dev\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///ssm\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 使用的是注解 --&gt; &lt;mappers&gt; &lt;!-- 该包下所有的dao接口都可以使用 --&gt; &lt;package name=\"com.wgy.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1.2.4.2 AccountDao使用注解编写SQL语句123456789101112131415/** * 查询所有账户 * * @return */@Select(\"select * from account\")public List&lt;Account&gt; findAll();/** * 保存帐户信息 * * @param account */@Insert(\"insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)\")public void saveAccount(Account account); 1.2.4.3 测试MyBatis1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 测试mybatis * * @author wgy */public class MyBatisTest &#123; /** * 测试查询 * * @throws Exception */ @Test public void run1() throws Exception &#123; // 加载配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建SqlSessionFactory对象 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); // 创建SqlSession对象 SqlSession session = factory.openSession(); // 获取到代理对象 AccountDao dao = session.getMapper(AccountDao.class); // 查询所有数据 List&lt;Account&gt; list = dao.findAll(); for (Account account : list) &#123; System.out.println(account); &#125; // 关闭资源 session.close(); in.close(); &#125; /** * 测试保存 * * @throws Exception */ @Test public void run2() throws Exception &#123; Account account = new Account(); account.setName(\"熊大\"); account.setMoney(400d); // 加载配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建SqlSessionFactory对象 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); // 创建SqlSession对象 SqlSession session = factory.openSession(); // 获取到代理对象 AccountDao dao = session.getMapper(AccountDao.class); // 保存 dao.saveAccount(account); // 提交事务 session.commit(); // 关闭资源 session.close(); in.close(); &#125;&#125; 1.2.5 整合 Spring 和 MyBatis目的：把SqlMapConfig.xml配置文件中的内容配置到applicationContext.xml配置文件中，SqlMapConfig.xml文件删除。 1.2.5.1 Spring 接管 MyBatis 的 Session 工厂12345678910111213&lt;!--Spring整合MyBatis框架--&gt;&lt;!--配置连接池--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///ssm\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt;&lt;/bean&gt;&lt;!--配置SqlSessionFactory工厂--&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 1.2.5.2 配置自动扫描所有 Mapper 接口1234&lt;!--配置AccountDao接口所在包--&gt;&lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.wgy.dao\"/&gt;&lt;/bean&gt; 1.2.5.3 配置 spring 的事务123456789101112131415161718&lt;!--配置Spring框架声明式事务管理--&gt;&lt;!--配置事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--配置事务通知--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt; &lt;tx:method name=\"*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置AOP增强--&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt;&lt;/aop:config&gt; 1.2.5.4 在service中注入dao对象1234567891011121314151617181920212223/** * 账户业务实现类 * * @author wgy */@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public List&lt;Account&gt; findAll() &#123; System.out.println(\"业务层：查询所有账户...\"); return accountDao.findAll(); &#125; @Override public void saveAccount(Account account) &#123; System.out.println(\"业务层：保存帐户...\"); accountDao.saveAccount(account); &#125;&#125; 1.2.6 测试 SSM 整合结果1.2.6.1 编写测试 jsp12345678910111213141516171819&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"account/findAll\"&gt;测试查询&lt;/a&gt;&lt;h3&gt;测试包&lt;/h3&gt;&lt;form action=\"account/save\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"name\"/&gt;&lt;br/&gt; 金额：&lt;input type=\"text\" name=\"money\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"保存\"/&gt;&lt;br/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1.2.6.2 修改控制器中的方法123456789101112131415161718192021222324252627282930313233/** * 帐户控制器 * * @author wgy */@Controller@RequestMapping(\"/account\")public class AccountController &#123; @Autowired private AccountService accountService; @RequestMapping(\"/findAll\") public String findAll(Model model) &#123; System.out.println(\"表现层：查询所有账户...\"); // 调用service的方法 List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(\"list\", list); return \"list\"; &#125; /** * 保存 * * @return */ @RequestMapping(\"/save\") public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; accountService.saveAccount(account); response.sendRedirect(request.getContextPath() + \"/account/findAll\"); return; &#125;&#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://wgy1993.gitee.io/tags/SpringMVC/"}]},{"title":"SpringMVC(二)","date":"2020-06-25T15:07:54.000Z","path":"archives/ea517149.html","text":"1. 响应数据和结果视图1.1 返回值分类1.1.1 void如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到。 默认会跳转到@RequestMapping(value=”/testVoid”) testVoid的页面。 可以使用请求转发或者重定向跳转到指定的页面 123456789101112131415161718192021/** * 是void * 请求转发一次请求，不用编写项目的名称 */@RequestMapping(\"/testVoid\")public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; System.out.println(\"testVoid方法执行了...\"); // 编写请求转发的程序 // request.getRequestDispatcher(\"/WEB-INF/pages/success.jsp\").forward(request,response); // 重定向 // response.sendRedirect(request.getContextPath()+\"/index.jsp\"); // 设置中文乱码 response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=UTF-8\"); // 直接会进行响应 response.getWriter().print(\"你好\"); return;&#125; 1.1.2 字符串controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 123456789101112131415161718/** * 返回String * 指定逻辑视图名，经过视图解析器解析为 jsp 物理路径：/WEB-INF/pages/success.jsp * @param model * @return */@RequestMapping(\"/testString\")public String testString(Model model) &#123; System.out.println(\"testString方法执行了...\"); // 模拟从数据库中查询出User对象 User user = new User(); user.setUsername(\"美美\"); user.setPassword(\"123\"); user.setAge(30); // model对象 model.addAttribute(\"user\", user); return \"success\";&#125; 1.1.3 ModelAndViewModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。 该对象中有两个方法： 示例代码: 123456789101112131415161718192021/** * 返回ModelAndView * * @return */@RequestMapping(\"/testModelAndView\")public ModelAndView testModelAndView() &#123; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); System.out.println(\"testModelAndView方法执行了...\"); // 模拟从数据库中查询出User对象 User user = new User(); user.setUsername(\"小凤\"); user.setPassword(\"456\"); user.setAge(30); // 把user对象存储到mv对象中，也会把user对象存入到request对象 mv.addObject(\"user\", user); // 跳转到哪个页面 mv.setViewName(\"success\"); return mv;&#125; JSP: 1234567891011&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;执行成功&lt;/h3&gt; $&#123;user.username&#125; $&#123;user.password&#125;&lt;/body&gt;&lt;/html&gt; 1.2 转发和重定向1.2.1 forward 转发controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成： 1234567891011/** * 使用关键字的方式进行转发 * * @return */@RequestMapping(\"/testForward\")public String testForward() &#123; System.out.println(\"testForward方法执行了...\"); // 请求的转发 return \"forward:/WEB-INF/pages/success.jsp\";&#125; 需要注意的是，如果用了 formward ：则路径必须写成实际视图 url，不能写逻辑视图。 它相当于“request.getRequestDispatcher(“url”).forward(request,response)”。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器方法。 1.2.2 Redirect 重定向contrller 方法提供了一个 String 类型返回值之后，它需要在返回值里使用redirect: 1234567891011/** * 使用关键字的方式进行转发或者重定向 * * @return */@RequestMapping(\"/testRedirect\")public String testRedirect() &#123; System.out.println(\"testRedirect方法执行了...\"); // 重定向 return \"redirect:/index.jsp\";&#125; 它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不能写在 WEB-INF 目录中，否则无法找到。 1.3 @ResponseBody 响应 json 数据1.3.1 &lt;mvc:resources/&gt;DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置 12345678&lt;!--前端控制器，哪些静态资源不拦截 mvc:resources标签配置不过滤 location元素表示webapp目录下的包下的所有文件 mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b--&gt;&lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;!-- 样式 --&gt;&lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;!-- 图片 --&gt;&lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!-- javascript --&gt; 1.3.2 @RequestBody获取请求体数据JSP: 123456789101112131415161718192021222324252627282930&lt;head&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // 页面加载，绑定单击事件 $(function () &#123; $(\"#btn\").click(function () &#123; // alert(\"hello btn\"); // 发送ajax请求 $.ajax(&#123; // 编写json格式，设置属性和值 url: \"user/testAjax\", contentType: \"application/json;charset=UTF-8\", data: '&#123;\"username\":\"hehe\",\"password\":\"123\",\"age\":30&#125;', dataType: \"json\", type: \"post\", success: function (data) &#123; // data服务器端响应的json的数据，进行解析 alert(data); alert(data.username); alert(data.password); alert(data.age); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;发送ajax的请求&lt;/button&gt;&lt;/body&gt; 控制器: 12345678910/** * 获取请求体的数据 */@RequestMapping(\"/testAjax\")public void testAjax(@RequestBody String body)) &#123; System.out.println(\"testAjax方法执行了...\"); // 客户端发送ajax的请求，传的是json字符串 System.out.println(body); return;&#125; 1.3.3 json 字符串转换成JavaBean 对象12345678910/** * 模拟异步请求响应 */@RequestMapping(\"/testAjax\")public void testAjax(@RequestBody User user) &#123; System.out.println(\"testAjax方法执行了...\"); // 客户端发送ajax的请求，传的是json字符串，后端把json字符串封装到user对象中 System.out.println(user); return;&#125; 1.3.4 @ResponseBody响应JSON数据1234567891011121314/** * 模拟异步请求响应 */@RequestMapping(\"/testAjax\")public @ResponseBody User testAjax(@RequestBody User user) &#123; System.out.println(\"testAjax方法执行了...\"); // 客户端发送ajax的请求，传的是json字符串，后端把json字符串封装到user对象中 System.out.println(user); // 做响应，模拟查询数据库 user.setUsername(\"haha\"); user.setAge(40); // 做响应 return user;&#125; json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包： 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 2. SpringMVC实现文件上传2.1 文件上传的回顾2.1.1 文件上传的必要前提1234567form 表单的 enctype 取值必须是：multipart&#x2F;form-data (默认值是:application&#x2F;x-www-form-urlencoded) enctype:是表单请求正文的类型 method 属性取值必须是 Post提供一个文件选择域&lt;input type&#x3D;”file” &#x2F;&gt; 2.1.2 文件上传的原理分析12345678910111213141516当 form 表单的 enctype 取值不是默认值后，request.getParameter()将失效。enctype&#x3D;”application&#x2F;x-www-form-urlencoded”时，form 表单的正文内容是： key&#x3D;value&amp;key&#x3D;value&amp;key&#x3D;value当 form 表单的 enctype 取值为 Mutilpart&#x2F;form-data 时，请求正文内容就变成：每一部分都是 MIME 类型描述的正文-----------------------------7de1a433602ac 分界符Content-Disposition: form-data; name&#x3D;&quot;userName&quot; 协议头aaa 协议的正文-----------------------------7de1a433602acContent-Disposition: form-data; name&#x3D;&quot;file&quot;;filename&#x3D;&quot;C:\\Users\\zhy\\Desktop\\fileupload_demofile\\b.txt&quot;Content-Type: text&#x2F;plain 协议的类型（MIME 类型）bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb-----------------------------7de1a433602ac-- 2.1.3 文件上传2.1.3.1 导jar包12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 2.1.3.2 编写文件上传的JSP页面123456&lt;h3&gt;传统文件上传&lt;/h3&gt;&lt;form action=\"/user/fileupload1\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"upload\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt;&lt;/form&gt; 2.1.3.3 Controller控制器123456789101112131415161718192021222324252627282930313233343536373839404142/** * 文件上传 * * @return */@RequestMapping(\"/fileupload1\")public String fileuoload1(HttpServletRequest request) throws Exception &#123; System.out.println(\"文件上传...\"); // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); // 判断，该路径是否存在 File file = new File(path); if (!file.exists()) &#123; // 创建该文件夹 file.mkdirs(); &#125; // 解析request对象，获取上传文件项 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); // 解析request List&lt;FileItem&gt; items = upload.parseRequest(request); // 遍历 for (FileItem item : items) &#123; // 进行判断，当前item对象是否是上传文件项 if (item.isFormField()) &#123; // 说明普通表单向 &#125; else &#123; // 说明上传文件项 // 获取上传文件的名称 String filename = item.getName(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid + \"_\" + filename; // 完成文件上传 item.write(new File(path, filename)); // 删除临时文件 item.delete(); &#125; &#125; return \"success\";&#125; 2.2 SpringMVC文件上传SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单file标签的 name属性名称相同。 2.2.1 导jar包12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 2.2.2 编写文件上传的JSP页面123456&lt;h3&gt;Springmvc文件上传&lt;/h3&gt;&lt;form action=\"/user/fileupload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"upload\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt;&lt;/form&gt; 2.2.3 Controller控制器12345678910111213141516171819202122232425262728/** * SpringMVC文件上传 * * @return */@RequestMapping(\"/fileupload2\")public String fileuoload2(HttpServletRequest request, MultipartFile upload) throws Exception &#123; System.out.println(\"springmvc文件上传...\"); // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); // 判断，该路径是否存在 File file = new File(path); if (!file.exists()) &#123; // 创建该文件夹 file.mkdirs(); &#125; // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid + \"_\" + filename; // 完成文件上传 upload.transferTo(new File(path, filename)); return \"success\";&#125; 2.2.4 配置文件解析器对象123456&lt;!--配置文件解析器对象--&gt;&lt;!--id 的值是固定的--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设置上传文件的最大尺寸为 10MB --&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt;&lt;/bean&gt; 2.3 SpringMVC跨服务器方式文件上传2.3.1 分服务器的目的12345在实际开发中，我们会有很多处理不同功能的服务器。例如： 应用服务器：负责部署我们的应用 数据库服务器：运行我们的数据库 缓存和消息服务器：负责处理大并发访问的缓存和消息 文件服务器：负责存储用户上传文件的服务器。 (注意：此处说的不是服务器集群） 分服务器处理的目的是让服务器各司其职，从而提高我们项目 2.3.2 搭建图片服务器配置端口不同的Tomcat项目 2.3.3 实现SpringMVC跨服务器方式文件上传2.3.3.1 导jar包1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; 2.3.3.2 编写文件上传的JSP页面123456&lt;h3&gt;跨服务器文件上传&lt;/h3&gt;&lt;form action=\"/user/fileupload3\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"upload\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt;&lt;/form&gt; 2.3.3.3 Controller控制器123456789101112131415161718192021222324/** * 跨服务器文件上传 * * @return */@RequestMapping(\"/fileupload3\")public String fileuoload3(MultipartFile upload) throws Exception &#123; System.out.println(\"跨服务器文件上传...\"); // 定义上传文件服务器路径 String path = \"http://localhost:9090/uploads/\"; // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid + \"_\" + filename; // 创建 sun 公司提供的 jersey 包中的 Client 对象 Client client = Client.create(); // 和图片服务器进行连接 WebResource webResource = client.resource(path + filename); // 上传文件 webResource.put(upload.getBytes()); return \"success\";&#125; 2.3.3.4 配置文件解析器对象123456&lt;!--配置文件解析器对象--&gt;&lt;!--id 的值是固定的--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设置上传文件的最大尺寸为 10MB --&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt;&lt;/bean&gt; 3. SpringMVC的异常处理3.1 异常处理思路系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 系统的 dao、service、controller 出现都通过 throws Exception 向上抛出，最后由 springmvc 前端控制器交由异常处理器进行异常处理，如下图： 3.2 SpringMVC的异常处理3.2.1 自定义异常类1234567891011121314151617181920212223/** * 自定义异常类 * * @author wgy */public class SysException extends Exception &#123; // 存储提示信息的 private String message; public SysException(String message) &#123; this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 3.2.2 控制器123456789101112131415161718192021222324/** * 控制器 * * @author wgy */@Controller@RequestMapping(\"/user\")public class UserController &#123; @RequestMapping(\"/testException\") public String testException() throws SysException &#123; System.out.println(\"testException执行了...\"); try &#123; // 模拟异常 int a = 10 / 0; &#125; catch (Exception e) &#123; // 打印异常信息 e.printStackTrace(); // 抛出自定义异常信息 throw new SysException(\"查询所有用户出现错误了...\"); &#125; return \"success\"; &#125;&#125; 3.2.3 自定义异常处理器1234567891011121314151617181920212223242526272829303132/** * 异常处理器 * * @author wgy */public class SysExceptionResolver implements HandlerExceptionResolver &#123; /** * 处理异常业务逻辑 * * @param request * @param response * @param handler * @param ex * @return */ @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; // 获取到异常对象 SysException e = null; if (ex instanceof SysException) &#123; e = (SysException) ex; &#125; else &#123; e = new SysException(\"系统正在维护....\"); &#125; // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"errorMsg\", e.getMessage()); mv.setViewName(\"error\"); return mv; &#125;&#125; 3.2.4 配置异常处理器12&lt;!--配置异常处理器--&gt;&lt;bean id=\"sysExceptionResolver\" class=\"com.wgy.exception.SysExceptionResolver\"/&gt; 4. SpringMVC框架中的拦截器4.1 拦截器的概述SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。 可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。 拦截器和过滤器的功能比较类似，有区别 过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。 拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。 过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。 拦截器也是AOP思想的一种实现方式。 想要自定义拦截器，需要实现HandlerInterceptor接口。 4.2 自定义拦截器步骤4.2.1 实现HandlerInterceptor接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 自定义拦截器 * * @author wgy */public class MyInterceptor1 implements HandlerInterceptor &#123; /** * 预处理，controller方法执行前 * return true 放行，执行下一个拦截器，如果没有，执行controller中的方法 * return false不放行 * * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"preHandle 拦截器拦截了\"); // request.getRequestDispatcher(\"/WEB-INF/pages/error.jsp\").forward(request,response); return true; &#125; /** * 后处理方法，controller方法执行后，success.jsp执行之前 * * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"postHandle 方法执行了\"); // request.getRequestDispatcher(\"/WEB-INF/pages/error.jsp\").forward(request,response); &#125; /** * success.jsp页面执行后，该方法会执行 * * @param request * @param response * @param handler * @param ex * @throws Exception */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"afterCompletion 方法执行了\"); &#125;&#125; 4.2.2 配置拦截器123456789101112&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体的方法--&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!--不要拦截的方法 &lt;mvc:exclude-mapping path=\"\"/&gt; --&gt; &lt;!--配置拦截器对象--&gt; &lt;bean class=\"com.wgy.interceptor.MyInterceptor1\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 4.2.3 运行结果 4.3 拦截器的细节4.3.1 HandlerInterceptor接口中的方法preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 postHandle方法是在JSP执行后执行 request或者response不能再跳转页面了 4.3.2 多个拦截器的执行顺序多个拦截器是按照配置的顺序决定的。先进后出 12345678910111213141516171819202122&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体的方法--&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!--不要拦截的方法 &lt;mvc:exclude-mapping path=\"\"/&gt; --&gt; &lt;!--配置拦截器对象--&gt; &lt;bean class=\"com.wgy.interceptor.HandlerInterceptorDemo1\"/&gt; &lt;/mvc:interceptor&gt; &lt;!--配置第二个拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体的方法--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--不要拦截的方法 &lt;mvc:exclude-mapping path=\"\"/&gt; --&gt; &lt;!--配置拦截器对象--&gt; &lt;bean class=\"com.wgy.interceptor.HandlerInterceptorDemo2\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://wgy1993.gitee.io/tags/SpringMVC/"}]},{"title":"SpringMVC(一)","date":"2020-06-24T11:53:20.000Z","path":"archives/4560ea2b.html","text":"1. SpringMVC 的基本概念1.1 三层架构和MVC1.1.1 三层架构开发服务器端程序，一般都基于两种形式，一种C/S(客户端/服务器)架构程序，一种B/S(浏览器/服务器)架构程序。 使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构 ： 表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型 业务层：处理公司具体的业务逻辑的 持久层：用来操作数据库的 1.1.2 MVC模型MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职： Model：数据模型，JavaBean的类，用来进行数据封装。 View：指JSP、HTML用来展示数据给用户 Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 1.2 SpringMVC 概述1.2.1 SpringMVC 是什么 是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级WEB框架。 Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建Web 应用程序的全功能 MVC 模块。 使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的 SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2等。 1.2.2 SpringMVC 在三层架构的位置 1.2.3 SpringMVC 和 Struts2 的优略分析共同点： 它们都是表现层框架，都是基于 MVC 模型编写的。 它们的底层都离不开原始 ServletAPI。 它们处理请求的机制都是一个核心控制器。 区别： Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所以 Spring MVC 会稍微比 Struts2 快些。 Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便(JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。) Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提升，尤其是 struts2 的表单标签，远没有 html 执行效率高。 2. SpringMVC 的入门2.1 SpringMVC 的入门案例2.1.1 创建WEB工程，引入jar包1234567891011121314151617181920212223242526272829303132333435363738&lt;groupId&gt;com.wgy&lt;/groupId&gt;&lt;artifactId&gt;SpringMVC01_start&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;!-- 版本锁定 --&gt;&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.1.2 配置核心的控制器12345678910111213141516&lt;!-- 配置 spring mvc 的核心控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，用于读取 SpringMVC 的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置 servlet 的对象的创建时间点：应用加载时创建。取值只能是非 0 正整数，表示启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2.1.3 编写springmvc.xml的配置文件123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com.wgy\"/&gt; &lt;!-- 视图解析器对象 --&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 开启SpringMVC框架注解的支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 2.1.4 编写index.jsp1234&lt;body&gt;&lt;h3&gt;入门案例&lt;/h3&gt; &lt;a href=\"$&#123; pageContext.request.contextPath &#125;/hello\"&gt;入门案例&lt;/a&gt;&lt;/body&gt; 2.1.5 编写HelloController控制器类12345678910111213141516171819/** * 控制器类 * * @author wgy */@Controllerpublic class HelloController &#123; /** * 入门案例 * * @return */ @RequestMapping(path = \"/hello\") public String sayHello() &#123; System.out.println(\"Hello StringMVC\"); return \"success\"; &#125;&#125; 2.1.6 编写success.jsp123&lt;body&gt; &lt;h3&gt;入门成功！！&lt;/h3&gt;&lt;/body&gt; 2.1.7 测试启动Tomcat服务器，进行测试 2.2 入门案例的执行过程及原理分析2.2.1 案例的执行过程 服务器启动，应用被加载。读取到 web.xml 中的配置创建 spring 容器并且初始化容器中的对象。 浏览器发送请求，被 DispatherServlet 捕获，该 Servlet 并不处理请求，而是把请求转发出去。转发的路径是根据请求 URL，匹配@RequestMapping 中的内容。 匹配到了后，执行对应方法。该方法有一个返回值。 根据方法的返回值，借助 InternalResourceViewResolver 找到对应的结果视图。 渲染结果视图，响应浏览器。 2.2.2 SpringMVC 的请求响应流程 2.3 入门案例中涉及的组件2.3.1 前端控制器（DispatcherServlet）用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 2.3.2 处理器映射器（HandlerMapping）HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 2.3.3 处理器（Handler）它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 2.3.4 处理器适配器（HandlAdapter）通过 HandlerAdapter 对处理器进行执行 2.3.5 视图解析器（View Resolver）View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 2.3.6 视图（View）SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。 2.3.7 &lt;mvc:annotation-driven&gt; 说明在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 使 用 &lt;mvc:annotation-driven&gt; 自 动加载 RequestMappingHandlerMapping （处理映射器） 和RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。 2.4 RequestMapping 注解2.4.1 使用说明RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系 RequestMapping注解可以作用在方法和类上 作用在类上：第一级的访问目录 作用在方法上：第二级的访问目录 RequestMapping的属性 path：指定请求路径的url value：value属性和path属性是一样的 mthod：指定该方法的请求方式 params：指定限制请求参数的条件。例如： params = {“accountName”}，表示请求参数必须有 accountName params = {“moeny!100”}，表示请求参数中 money 不能是 100。 headers：发送的请求中必须包含的请求头 2.4.2 使用示例2.4.2.1 出现位置的示例控制器： 1234567891011121314151617181920/** * 控制器类 * * @author wgy */@Controller(\"accountController\")@RequestMapping(path = \"/account\")public class AccountController &#123; /** * RequestMapping注解 * * @return */ @RequestMapping(value = \"/findAccount\") public String findAccount() &#123; System.out.println(\"查询了账户。。。。\"); return \"success\"; &#125;&#125; JSP: 12345678&lt;body&gt; &lt;!-- 第一种访问方式 --&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/account/findAccount\"&gt;查询账户&lt;/a&gt; &lt;br/&gt; &lt;!-- 第二种访问方式 --&gt; &lt;a href=\"account/findAccount\"&gt;查询账户&lt;/a&gt;&lt;/body&gt; 在 jsp 中第二种写法时，不要在访问 URL 前面加/ ，否则无法找到资源。 2.4.2.2 method 属性的示例控制器： 12345678910/** * 保存账户 * * @return */@RequestMapping(value=\"/saveAccount\",method=RequestMethod.POST)public String saveAccount() &#123; System.out.println(\"保存了账户\"); return \"success\";&#125; JSP: 1234567&lt;!-- 请求方式的示例 --&gt;&lt;a href=\"account/saveAccount\"&gt;保存账户，get 请求&lt;/a&gt;&lt;br/&gt;&lt;form action=\"account/saveAccount\" method=\"post\"&gt; &lt;input type=\"submit\" value=\" 保存账户， post 请求 \"&gt;&lt;/form&gt; 当使用 get 请求时，提示错误信息是 405，信息是方法不支持 get 方式请求 2.4.2.3 params 属性的示例控制器： 123456789/** * 删除账户 * @return */@RequestMapping(value=\"/removeAccount\",params= &#123;\"accountName\",\"money&gt;100\"&#125;)public String removeAccount() &#123; System.out.println(\"删除了账户\"); return \"success\";&#125; JSP: 12345&lt;!-- 请求参数的示例 --&gt;&lt;a href=\"account/removeAccount?accountName=aaa&amp;money&gt;100\"&gt;删除账户，金额 100&lt;/a&gt;&lt;br/&gt;&lt;a href=\"account/removeAccount?accountName=aaa&amp;money&gt;150\"&gt;删除账户，金额 150&lt;/a&gt; 当我们点击第一个超链接时,可以访问成功。当我们点击第二个超链接时，无法访问。如下图： 3. 请求参数的绑定3.1 绑定说明3.1.1 绑定的机制表单中请求参数都是基于 key=value 的。SpringMVC 绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。 JSP: 123&lt;a href=\"account/findAccount?accountId=10\"&gt;查询账户&lt;/a&gt;请求参数是：accountId=10 控制器： 12345678910/** * 查询账户 * * @return */@RequestMapping(\"/findAccount\")public String findAccount(Integer accountId) &#123; System.out.println(\"查询了账户。。。。\"+accountId); return \"success\";&#125; 3.1.2 支持的数据类型12345678基本类型参数 ： 包括基本类型和 String 类型POJO 类型参数 ： 包括实体类，以及关联的实体类数组和集合类型参数 ： 包括 List 结构和 Map 结构的集合（包括数组）SpringMVC 绑定请求参数是自动实现的，但是要想使用，必须遵循使用要求。 3.1.3 使用要求12345678910111213如果是基本类型或者 String 类型： 要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写)如果是 POJO 类型，或者它的关联对象 ： 要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。如果是集合类型, 有两种方式： 第一种： 要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。 给 List 集合中的元素赋值，使用下标。 给 Map 集合中的元素赋值，使用键值对。 第二种： 接收的请求参数是 json 格式数据。需要借助一个注解实现。它可以实现一些数据类型自动转换,如遇特殊类型转换要求，需要我们自己编写自定义类型转换器。 3.1.4 使用示例3.1.4.1 基本类型和 String 类型作为参数JSP: 12&lt;!-- 基本类型示例 --&gt;&lt;a href=\"account/findAccount?accountId=10&amp;accountName=zhangsan\"&gt;查询账户&lt;/a&gt; 控制器: 12345678910/** * 查询账户 * * @return */@RequestMapping(\"/findAccount\")public String findAccount(Integer accountId,String accountName) &#123; System.out.println(\"查询了账户。。。。\"+accountId+\",\"+accountName); return \"success\";&#125; 运行结果： 3.1.4.2 POJO 类型作为参数实体类： 123456789101112/** * 账户信息 * * @author wgy */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; private Address address; ...&#125; 12345678910/** * 地址的实体类 * * @author wgy */public class Address implements Serializable &#123; private String provinceName; private String cityName; ...&#125; JSP: 12345678&lt;!-- pojo 类型演示 --&gt;&lt;form action=\"account/saveAccount\" method=\"post\"&gt; 账户名称：&lt;input type=\"text\" name=\"name\" &gt;&lt;br/&gt; 账户金额：&lt;input type=\"text\" name=\"money\" &gt;&lt;br/&gt; 账户省份：&lt;input type=\"text\" name=\"address.provinceName\" &gt;&lt;br/&gt; 账户城市：&lt;input type=\"text\" name=\"address.cityName\" &gt;&lt;br/&gt; &lt;input type=\"submit\" value=\" 保存 \"&gt;&lt;/form&gt; 控制器: 1234567891011/** * 保存账户 * * @param account * @return */@RequestMapping(\"/saveAccount\")public String saveAccount(Account account) &#123; System.out.println(\"保存了账户。。。。\"+account); return \"success\";&#125; 运行结果: 3.1.4.3 POJO 类中包含集合类型参数实体类: 12345678910111213/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private String username; private String password; private Integer age; private List&lt;Account&gt; accounts; private Map&lt;String,Account&gt; accountMap; ...&#125; JSP: 123456789101112131415&lt;!-- POJO 类包含集合类型演示 --&gt;&lt;form action=\"account/updateAccount\" method=\"post\"&gt; 用户名称：&lt;input type=\"text\" name=\"username\" &gt;&lt;br/&gt; 用户密码：&lt;input type=\"password\" name=\"password\" &gt;&lt;br/&gt; 用户年龄：&lt;input type=\"text\" name=\"age\" &gt;&lt;br/&gt; 账户 1 名称：&lt;input type=\"text\" name=\"accounts[0].name\" &gt;&lt;br/&gt; 账户 1 金额：&lt;input type=\"text\" name=\"accounts[0].money\" &gt;&lt;br/&gt; 账户 2 名称：&lt;input type=\"text\" name=\"accounts[1].name\" &gt;&lt;br/&gt; 账户 2 金额：&lt;input type=\"text\" name=\"accounts[1].money\" &gt;&lt;br/&gt; 账户 3 名称：&lt;input type=\"text\" name=\"accountMap['one'].name\" &gt;&lt;br/&gt; 账户 3 金额：&lt;input type=\"text\" name=\"accountMap['one'].money\" &gt;&lt;br/&gt; 账户 4 名称：&lt;input type=\"text\" name=\"accountMap['two'].name\" &gt;&lt;br/&gt; 账户 4 金额：&lt;input type=\"text\" name=\"accountMap['two'].money\" &gt;&lt;br/&gt; &lt;input type=\"submit\" value=\" 保存 \"&gt;&lt;/form&gt; 控制器: 12345678910/** * 更新账户 * * @return */@RequestMapping(\"/updateAccount\")public String updateAccount(User user) &#123; System.out.println(\"更新了账户。。。。\"+user); return \"success\";&#125; 运行结果: 3.1.4.4 请求参数乱码问题post 请求方式： 12345678910111213141516在 web.xml 中配置一个过滤器&lt;!-- 配置 springMVC 编码过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 设置过滤器中的属性值 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!-- 过滤所有请求 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; get 请求方式： 1234567tomacat对GET和POST请求处理方式是不同的，GET请求的编码问题，要改tomcat的server.xml配置文件，如下：&lt;Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" edirectPort=\"8443\"/&gt;改为：&lt;Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" useBodyEncodingForURI=\"true\"/&gt;如果遇到 ajax 请求仍然乱码，请把：useBodyEncodingForURI=\"true\"改为 URIEncoding=\"UTF-8\"即可。 3.2 特殊情况3.2.1 自定义类型转换器表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明 Spring框架内部会默认进行数据类型转换。 如果想自定义数据类型转换，可以实现Converter的接口 3.2.1.1 自定义类型转换器1234567891011121314151617181920212223242526272829/** * 把字符串转换日期 * * @author wgy */public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; /** * String source 传入进来字符串 * * @param source * @return */ @Override public Date convert(String source) &#123; // 判断 if (source == null) &#123; throw new RuntimeException(\"请您传入数据\"); &#125; DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\"); try &#123; // 把字符串转换日期 return df.parse(source); &#125; catch (Exception e) &#123; throw new RuntimeException(\"数据类型转换出现错误\"); &#125; &#125;&#125; 3.2.1.2 注册自定义类型转换器1234567891011121314&lt;!-- 配置类型转换器工厂 --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;!-- 给工厂注入一个新的类型转换器 --&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;!-- 配置自定义类型转换器 --&gt; &lt;bean class=\"com.wgy.utils.StringToDateConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启SpringMVC框架注解的支持 --&gt;&lt;!-- 引用自定义类型转换器 --&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt; 3.2.2 使用 ServletAPI 对象作为方法参数SpringMVC 还支持使用原始 ServletAPI 对象作为控制器方法的参数。 12345678910111213141516171819/** * 原生的API * * @return */@RequestMapping(\"/testServlet\")public String testServlet(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(\"执行了...\"); System.out.println(request); HttpSession session = request.getSession(); System.out.println(session); ServletContext servletContext = session.getServletContext(); System.out.println(servletContext); System.out.println(response); return \"success\";&#125; 4. 常用注解4.1 RequestParam4.1.1 使用说明12345作用： 把请求中指定名称的参数给控制器中的形参赋值。属性： value：请求参数中的名称。 required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。 4.1.2 使用示例JSP: 12&lt;!-- requestParams 注解的使用 --&gt;&lt;a href=\"springmvc/useRequestParam?name=test\"&gt;requestParam 注解&lt;/a&gt; 控制器: 1234567891011/** * requestParam 注解的使用 * * @param username * @return */@RequestMapping(\"/useRequestParam\")public String useRequestParam(@RequestParam(\"name\")String username,@RequestParam(value=\"age\",required=false)Integer age)&#123; System.out.println(username+\",\"+age); return \"success\";&#125; 运行结果: 4.2 RequestBody4.2.1 使用说明12345作用： 用于获取请求体内容。直接使用得到是 key&#x3D;value&amp;key&#x3D;value...结构的数据。 get 请求方式不适用。属性： required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。 4.2.2 使用示例JSP: 123456789&lt;!-- request body 注解 --&gt;&lt;form action=\"springmvc/useRequestBody\" method=\"post\"&gt; 用户名称：&lt;input type=\"text\" name=\"username\" &gt;&lt;br/&gt; 用户密码：&lt;input type=\"password\" name=\"password\" &gt;&lt;br/&gt; 用户年龄：&lt;input type=\"text\" name=\"age\" &gt;&lt;br/&gt; &lt;input type=\"submit\" value=\" 保存 \"&gt;&lt;/form&gt;&lt;a href=\"springmvc/useRequestBody?body=test\"&gt;requestBody 注解 get 请求&lt;/a&gt; 控制器: 1234567891011/** * RequestBody 注解 * * @param user * @return */@RequestMapping(\"/useRequestBody\")public String useRequestBody(@RequestBody(required=false) String body)&#123; System.out.println(body); return \"success\";&#125; post 请求运行结果: get 请求运行结果: 4.3 PathVaribale4.3.1 使用说明123456作用： 用于绑定 url 中的占位符。例如：请求 url 中 &#x2F;delete&#x2F;&#123;id&#125;，这个&#123;id&#125;就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。属性： value：用于指定 url 中占位符名称。 required：是否必须提供占位符。 4.3.2 使用示例JSP: 12&lt;!-- PathVariable 注解 --&gt;&lt;a href=\"springmvc/usePathVariable/100\"&gt;pathVariable 注解&lt;/a&gt; 控制器: 1234567891011/** * PathVariable 注解 * * @param user * @return */@RequestMapping(\"/usePathVariable/&#123;id&#125;\")public String usePathVariable(@PathVariable(\"id\") Integer id)&#123; System.out.println(id); return \"success\";&#125; 运行结果: 4.3.3 REST 风格 URL4.3.3.1 什么是 restREST（英文：Representational State Transfer，简称 REST）描述了一个架构样式的网络系统，比如 web 应用程序。它首次出现在 2000 年 Roy Fielding 的博士论文中，他是 HTTP 规范的主要编写者之一。在目前主流的三种 Web 服务交互方案中，REST 相比于 SOAP（Simple Object Access protocol，简单对象访问协议）以及 XML-RPC 更加简单明了，无论是对 URL 的处理还是对 Payload 的编码，REST 都倾向于用更加简单轻量的方法设计和实现。值得注意的是 REST 并没有一个明确的标准，而更像是一种设计的风格。 它本身并没有什么实用性，其核心价值在于如何设计出符合 REST 风格的网络接口。 4.3.3.2 restful 的优点它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 请求路径一样，可以根据不同的请求方式去执行后台的不同方法 4.3.3.3 restful 的特性 资源（ Resources）：网络上的一个实体，或者说是网络上的一个具体信息。 它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI （统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。 表现层（ Representation）：把资源具体呈现出来的形式，叫做它的表现层 （ Representation）。 比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。 状态转化（ State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。 HTTP 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生 “状态转化 ”（ State Tran sfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化 ”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词： GET、 POST、 PUT、DELETE。它们分别对应四种基本操作： GET 用来获取资源， POST 用来新建资源， PUT 用来更新资源， DELETE 用来删除资源。 4.3.3.4 restful 的示例1234&#x2F;account&#x2F;1 HTTP GET ： 得到 id &#x3D; 1 的 account&#x2F;account&#x2F;1 HTTP DELETE： 删除 id &#x3D; 1 的 account&#x2F;account&#x2F;1 HTTP PUT： 更新 id &#x3D; 1 的 account&#x2F;account HTTP POST： 新增 account 4.4 RequestHeader4.4.1 使用说明1234567作用： 用于获取请求消息头。属性： value：提供消息头名称 required：是否必须有此消息头注： 在实际开发中一般不怎么用。 4.4.2 使用示例JSP: 12&lt;!-- RequestHeader 注解 --&gt;&lt;a href=\"springmvc/useRequestHeader\"&gt;获取请求消息头&lt;/a&gt; 控制器: 1234567891011/** * RequestHeader 注解 * * @param user * @return */@RequestMapping(\"/useRequestHeader\")public String useRequestHeader(@RequestHeader(value=\"Accept-Language\",required=false)String requestHeader)&#123; System.out.println(requestHeader); return \"success\";&#125; 运行结果: 4.5 CookieValue4.5.1 使用说明12345作用： 用于把指定 cookie 名称的值传入控制器方法参数。属性： value：指定 cookie 的名称。 required：是否必须有此 cookie。 4.5.2 使用示例JSP: 12&lt;!-- CookieValue 注解 --&gt;&lt;a href=\"springmvc/useCookieValue\"&gt;绑定 cookie 的值&lt;/a&gt; 控制器: 1234567891011/** * Cookie 注解注解 * * @param user * @return */@RequestMapping(\"/useCookieValue\")public String useCookieValue(@CookieValue(value=\"JSESSIONID\",required=false) String cookieValue)&#123; System.out.println(cookieValue); return \"success\";&#125; 运行结果: 4.6 ModelAttribute4.6.1 使用说明12345678910作用： 该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。属性： value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。应用场景： 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 例如： 我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。 4.6.2 使用示例4.6.2.1 基于 POJO 属性的基本使用JSP: 12&lt;!-- ModelAttribute 注解的基本使用 --&gt;&lt;a href=\"springmvc/testModelAttribute?username=test\"&gt;测试 modelattribute&lt;/a&gt; 控制器: 1234567891011121314151617181920/** * 被 ModelAttribute 修饰的方法 * * @param user */@ModelAttributepublic void showModel(User user) &#123; System.out.println(\"执行了 showModel 方法\"+user.getUsername());&#125;/** * 接收请求的方法 * * @param user * @return */@RequestMapping(\"/testModelAttribute\")public String testModelAttribute(User user) &#123; System.out.println(\"执行了控制器的方法\"+user.getUsername()); return \"success\";&#125; 运行结果: 4.6.2.2 基于 Map 的应用场景1ModelAttribute 修饰方法带返回值 修改用户信息，要求用户的密码不能修改 JSP: 123456&lt;!-- 修改用户信息 --&gt;&lt;form action=\"springmvc/updateUser\" method=\"post\"&gt; 用户名称：&lt;input type=\"text\" name=\"username\" &gt;&lt;br/&gt; 用户年龄：&lt;input type=\"text\" name=\"age\" &gt;&lt;br/&gt; &lt;input type=\"submit\" value=\" 保存 \"&gt;&lt;/form&gt; 控制器: 1234567891011121314151617181920212223242526272829303132333435363738/** * 查询数据库中用户信息 * * @param user */@ModelAttributepublic User showModel(String username) &#123; //模拟去数据库查询 User abc = findUserByName(username); System.out.println(\"执行了 showModel 方法\"+abc); return abc;&#125;/** * 模拟修改用户方法 * * @param user * @return */@RequestMapping(\"/updateUser\")public String testModelAttribute(User user) &#123; System.out.println(\"控制器中处理请求的方法：修改用户：\"+user); return \"success\";&#125;/** * 模拟去数据库查询 * * @param username * @return */private User findUserByName(String username) &#123; User user = new User(); user.setUsername(username); user.setAge(19); user.setPassword(\"123456\"); return user;&#125; 运行结果: 4.6.2.3 基于 Map 的应用场景2ModelAttribute 修饰方法不带返回值 修改用户信息，要求用户的密码不能修改 JSP: 123456&lt;!-- 修改用户信息 --&gt;&lt;form action=\"springmvc/updateUser\" method=\"post\"&gt; 用户名称：&lt;input type=\"text\" name=\"username\" &gt;&lt;br/&gt; 用户年龄：&lt;input type=\"text\" name=\"age\" &gt;&lt;br/&gt; &lt;input type=\"submit\" value=\" 保存 \"&gt;&lt;/form&gt; 控制器: 1234567891011121314151617181920212223242526272829303132333435363738/** * 查询数据库中用户信息 * * @param user */@ModelAttributepublic void showModel(String username,Map&lt;String,User&gt; map) &#123; //模拟去数据库查询 User user = findUserByName(username); System.out.println(\"执行了 showModel 方法\"+user); map.put(\"abc\",user);&#125;/** * 模拟修改用户方法 * * @param user * @return */@RequestMapping(\"/updateUser\")public String testModelAttribute(@ModelAttribute(\"abc\")User user) &#123; System.out.println(\"控制器中处理请求的方法：修改用户：\"+user); return \"success\";&#125;/** * 模拟去数据库查询 * * @param username * @return */private User findUserByName(String username) &#123; User user = new User(); user.setUsername(username); user.setAge(19); user.setPassword(\"123456\"); return user;&#125; 运行结果: 4.7 SessionAttribute4.7.1 使用说明12345作用： 用于多次执行控制器方法间的参数共享。属性： value：用于指定存入的属性名称 type：用于指定存入的数据类型。 4.7.2 使用示例JSP: 123456&lt;!-- SessionAttribute 注解的使用 --&gt;&lt;a href=\"springmvc/testPut\"&gt;存入 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"springmvc/testGet\"&gt;取出 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"springmvc/testClean\"&gt;清除 SessionAttribute&lt;/a&gt; 控制器: 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 控制器 * * @author wgy */@Controller(\"sessionAttributeController\")@RequestMapping(\"/springmvc\")// 把数据存入到session域对象中@SessionAttributes(value =&#123;\"username\",\"password\"&#125;,types=&#123;Integer.class&#125;)public class SessionAttributeController &#123; /** * 把数据存入 SessionAttribute * * @param model * @return * Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap * 该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类 */ @RequestMapping(\"/testPut\") public String testPut(Model model)&#123; System.out.println(\"存入了数据\"); model.addAttribute(\"username\", \"泰斯特\"); model.addAttribute(\"password\",\"123456\"); model.addAttribute(\"age\", 31); //跳转之前将数据保存到 username、password 和 age 中，因为注解@SessionAttribute 中有 这几个参数 return \"success\"; &#125; @RequestMapping(\"/testGet\") public String testGet(ModelMap model)&#123; System.out.print(\"获取了数据:\"); System.out.println(model.get(\"username\")+\";\"+model.get(\"password\")+\";\"+model.get(\"age\")); return \"success\"; &#125; @RequestMapping(\"/testClean\") public String complete(SessionStatus sessionStatus)&#123; System.out.print(\"清除了数据\"); sessionStatus.setComplete(); return \"success\"; &#125;&#125; 运行结果:","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://wgy1993.gitee.io/tags/SpringMVC/"}]},{"title":"MyBatis(四)","date":"2020-06-23T14:38:54.000Z","path":"archives/bf2fe2d.html","text":"1. Mybatis 延迟加载策略1.1 何为延迟加载就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。 好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 坏处 ：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 1.2 实现需求查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加载。 1.3 使用 assocation 实现延迟加载1.3.1 在 Account 实体类中加入 user 属性123456789101112131415/** * 账户实体类 * * @author wgy */public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //从表实体应该包含一个主表实体的对象引用 private User user; ...&#125; 1.3.2 账户的持久层 DAO 接口1234567891011121314/** * 账户持久层接口 * * @author wgy */public interface IAccountDao &#123; /** * 查询所有账户，同时还要获取到当前账户的所属用户信息 * * @return */ List&lt;Account&gt; findAll();&#125; 1.3.3 账户的持久层映射文件123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IAccountDao\"&gt; &lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"uid\" column=\"uid\"/&gt; &lt;result property=\"money\" column=\"money\"/&gt; &lt;!-- 一对一的关系映射：配置封装user的内容 select属性指定的内容：查询用户的唯一标识： column属性指定的内容：用户根据id查询时，所需要的参数的值 --&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\" select=\"com.wgy.dao.IUserDao.findById\"/&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultMap=\"accountUserMap\"&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; 1.3.4 用户的持久层接口和映射文件123456789101112131415/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 根据id查询用户信息 * * @param userId * @return */ User findById(Integer userId);&#125; 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 1.3.5 开启 Mybatis 的延迟加载策略进入 Mybaits 的官方文档，找到 settings 的说明信息： 我们需要在 Mybatis 的配置文件 SqlMapConfig.xml 文件中添加延迟加载的配置。 123456&lt;!--配置参数--&gt;&lt;settings&gt; &lt;!--开启Mybatis支持延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"&gt;&lt;/setting&gt;&lt;/settings&gt; 1.3.6 编写测试只查账户信息不查用户信息12345678/** * 测试查询所有 */@Testpublic void testFindAll() &#123; //5.执行操作 List&lt;Account&gt; accounts = accountDao.findAll();&#125; 测试结果如下： 我们发现，因为本次只是将Account对象查询出来放入List集合中，并没有涉及到User对象，所以就没有发出 SQL 语句查询账户所关联的 User 对象的查询。 1.4 使用 Collection 实现延迟加载1.4.1 在 User 实体类中加入List&lt;Account&gt;属性12345678910111213141516/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //一对多关系映射：主表实体应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; ...&#125; 1.4.2 用户的持久层 DAO 接口123456/** * 查询所有用户，同时获取到用户下所有账户的信息 * * @return */List&lt;User&gt; findAll(); 1.4.3 用户的持久层映射文件12345678910111213141516&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=\"userAccountMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"account\" select=\"com.wgy.dao.IAccountDao.findAccountByUid\" column=\"id\"/&gt;&lt;/resultMap&gt;&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; select * from user&lt;/select&gt; 1.4.4 账户的持久层接口和映射文件1234567/** * 根据用户id查询账户信息 * * @param uid * @return */List&lt;Account&gt; findAccountByUid(Integer uid); 123456&lt;!-- 根据用户id查询账户列表 --&gt;&lt;select id=\"findAccountByUid\" resultType=\"account\" parameterType=\"int\"&gt; select * from account where uid = #&#123;id&#125;&lt;/select&gt; 1.4.5 编写测试只查用户信息不查账户信息12345678/** * 测试查询所有 */@Testpublic void testFindAll() &#123; //5.执行操作 List&lt;User&gt; users = userDao.findAll();&#125; 测试结果如下： 我们发现并没有加载 Account 账户信息。 2. Mybatis 缓存像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。 Mybatis 中缓存分为一级缓存，二级缓存。 2.1 Mybatis 一级缓存2.1.1 证明一级缓存的存在一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close或clearCache，它就存在。 2.1.1.1 编写用户持久层 Dao 接口123456789101112131415/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 根据id查询用户信息 * * @param userId * @return */ User findById(Integer userId);&#125; 2.1.1.2 编写用户持久层映射文件12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 2.1.1.3 编写测试方法123456789101112/** * 测试一级缓存 */@Testpublic void testFirstLevelCache() &#123; //5.执行操作 User user1 = userDao.findById(41); System.out.println(user1); User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125; 测试结果如下： 我们可以发现，虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis 提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询 id为41的记录时，并没有发出sql语句从数据库中查询数据，而是从一级缓存中查询。 2.1.2 一级缓存的分析一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。 得到用户信息，将用户信息存储到一级缓存中。 如果 sqlSession 去执行 commit 操作（执行插入、更新、删除），清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。 2.1.3 测试一级缓存的清空12345678910111213141516/** * 测试一级缓存 */@Testpublic void testFirstLevelCache() &#123; User user1 = userDao.findById(41); System.out.println(user1);// sqlSession.close(); //再次获取SqlSession对象// sqlSession = factory.openSession(); sqlSession.clearCache();//此方法也可以清空缓存 userDao = sqlSession.getMapper(IUserDao.class); User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125; 1234567891011121314151617181920/** * 测试缓存的同步 */@Testpublic void testClearlCache() &#123; //1.根据id查询用户 User user1 = userDao.findById(41); System.out.println(user1); //2.更新用户信息 user1.setUsername(\"update user clear cache\"); user1.setAddress(\"北京市海淀区\"); userDao.updateUser(user1); //3.再次查询id为41的用户 User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125; 当执行sqlSession.close()后，再次获取sqlSession并查询id=41的User对象时，又重新执行了sql语句，从数据库进行了查询操作。 2.2 Mybatis 二级缓存二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 2.2.1 二级缓存结构图 首先开启 mybatis 的二级缓存。 sqlSession1 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。 如果 SqlSession3 去执行相同 mapper 映射下 sql，执行 commit 提交，将会清空该 mapper 映射下的二级缓存区域的数据。 sqlSession2 去查询与 sqlSession1 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。 2.2.2 二级缓存的开启与关闭2.2.2.1 在 SqlMapConfig.xml 文件开启二级缓存123456&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt;因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。 2.2.2.2 配置相关的 Mapper 映射文件1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!--开启user支持二级缓存--&gt; &lt;cache/&gt;&lt;/mapper&gt;&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。 2.2.2.3 配置 statement 上面的 useCache12345678&lt;!-- 根据id查询用户 --&gt;&lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\" useCache=\"true\"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt;&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。 2.2.3 二级缓存测试12345678910111213141516171819/** * 测试二级缓存 */@Testpublic void testFirstLevelCache() &#123; SqlSession sqlSession1 = factory.openSession(); IUserDao dao1 = sqlSession1.getMapper(IUserDao.class); User user1 = dao1.findById(41); System.out.println(user1); sqlSession1.close();//一级缓存消失 SqlSession sqlSession2 = factory.openSession(); IUserDao dao2 = sqlSession2.getMapper(IUserDao.class); User user2 = dao2.findById(41); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2);&#125; 经过上面的测试，我们发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二次查询时，我们发现并没有对数据库发出 sql 语句，所以此时的数据就只能是来自于我们所说的二级缓存。 2.2.4 二级缓存注意事项当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。 3. Mybatis 注解开发3.1 mybatis 的常用注解说明1234567891011@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace:实现注解二级缓存的使用 3.2 使用 Mybatis 注解实现基本 CRUD3.2.1 编写实体类1234567891011121314/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; ...&#125; 3.2.2 使用注解方式开发持久层接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 在mybatis中针对CRUD一共有四个注解 * * @author wgy * @Select @Insert @Update @Delete */public interface IUserDao &#123; /** * 查询所有用户 * * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll(); /** * 保存用户 * * @param user */ @Insert(\"insert into user(username,address,sex,birthday)values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)\") void saveUser(User user); /** * 更新用户 * * @param user */ @Update(\"update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;\") void updateUser(User user); /** * 删除用户 * * @param userId */ @Delete(\"delete from user where id=#&#123;id&#125; \") void deleteUser(Integer userId); /** * 根据id查询用户 * * @param userId * @return */ @Select(\"select * from user where id=#&#123;id&#125; \") User findById(Integer userId); /** * 根据用户名称模糊查询 * * @param username * @return */ @Select(\"select * from user where username like #&#123;username&#125; \")// @Select(\"select * from user where username like '%$&#123;value&#125;%' \") List&lt;User&gt; findUserByName(String username); /** * 查询总用户数量 * * @return */ @Select(\"select count(*) from user \") int findTotalUser();&#125; 3.2.3 编写 SqlMapConfig 配置文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置properties--&gt; &lt;properties resource=\"jdbcConfig.properties\"/&gt; &lt;!--使用typeAliases配置别名，它只能配置domain中类的别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.wgy.domain\"/&gt; &lt;/typeAliases&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置映射文件的位置 --&gt; &lt;mappers&gt; &lt;!-- 配置 dao 接口的位置，它有两种方式 第一种：使用 mapper 标签配置 class 属性 第二种：使用 package 标签，直接指定 dao 接口所在的包 --&gt; &lt;package name=\"com.wgy.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.2.4 编写测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @author wgy */public class AnnotationCRUDTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before public void init() throws Exception &#123; in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); factory = new SqlSessionFactoryBuilder().build(in); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; session.commit(); session.close(); in.close(); &#125; @Test public void testSave() &#123; User user = new User(); user.setUsername(\"mybatis annotation\"); user.setAddress(\"北京市昌平区\"); userDao.saveUser(user); &#125; @Test public void testUpdate() &#123; User user = new User(); user.setId(57); user.setUsername(\"mybatis annotation update\"); user.setAddress(\"北京市海淀区\"); user.setSex(\"男\"); user.setBirthday(new Date()); userDao.updateUser(user); &#125; @Test public void testDelete() &#123; userDao.deleteUser(51); &#125; @Test public void testFindOne() &#123; User user = userDao.findById(57); System.out.println(user); &#125; @Test public void testFindByName() &#123; List&lt;User&gt; users = userDao.findUserByName(\"%mybatis%\");// List&lt;User&gt; users = userDao.findUserByName(\"mybatis\"); for (User user : users) &#123; System.out.println(user); &#125; &#125; @Test public void testFindTotal() &#123; int total = userDao.findTotalUser(); System.out.println(total); &#125;&#125; 3.3 使用注解实现复杂关系映射开发实现复杂关系映射之前我们可以在映射文件中通过配置&lt;resultMap&gt;来实现，在使用注解开发时我们需要借助@Results 注解，@Result 注解，@One 注解，@Many 注解。 3.3.1 复杂关系映射的注解说明123456789101112131415161718192021222324252627@Results 注解代替的是标签&lt;resultMap&gt;该注解中可以使用单个@Result 注解，也可以使用@Result 集合@Results（&#123;@Result（），@Result（）&#125;）或@Results（@Result（））@Resutl 注解代替了 &lt;id&gt; 标签和&lt;result&gt; 标签@Result 中 属性介绍： id 是否是主键字段 column 数据库的列名 property 需要装配的属性名 one 需要使用的@One 注解（@Result（one&#x3D;@One）（））） many 需要使用的@Many 注解（@Result（many&#x3D;@many）（）））@One 注解（一对一） 代替了&lt;assocation&gt; 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。@One 注解属性介绍： select 指定用的 来多表查询的 sqlmapper fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。 使用格式： @Result(column&#x3D;&quot; &quot;,property&#x3D;&quot;&quot;,one&#x3D;@One(select&#x3D;&quot;&quot;))@Many 注解（多对一） 代替了&lt;Collection&gt; 标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType（一般为 ArrayList）但是注解中可以不定义； 使用格式： @Result(property&#x3D;&quot;&quot;,column&#x3D;&quot;&quot;,many&#x3D;@Many(select&#x3D;&quot;&quot;)) 3.3.2 使用注解实现一对一 复杂关系映射及延迟加载加载账户信息时并且加载该账户的用户信息，根据情况可实现延迟加载。（注解方式实现） 3.3.2.1 添加 User 实体类及 Account 实体类1234567891011121314/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer userId; private String userName; private String userAddress; private String userSex; private Date userBirthday; ...&#125; 1234567891011121314/** * 账户实体类 * * @author wgy */public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //多对一（mybatis中称之为一对一）的映射：一个账户只能属于一个用户 private User user; ...&#125; 3.3.2.2 添加账户的持久层接口并使用注解配置123456789101112131415161718192021/** * 账户持久层接口 * * @author wgy */public interface IAccountDao &#123; /** * 查询所有账户，并且获取每个账户所属的用户信息 * * @return */ @Select(\"select * from account\") @Results(id = \"accountMap\", value = &#123; @Result(id = true, column = \"id\", property = \"id\"), @Result(column = \"uid\", property = \"uid\"), @Result(column = \"money\", property = \"money\"), @Result(property = \"user\", column = \"uid\", one = @One(select = \"com.wgy.dao.IUserDao.findById\", fetchType = FetchType.EAGER)) &#125;) List&lt;Account&gt; findAll();&#125; 3.3.2.3 添加用户的持久层接口并使用注解配置123456789101112131415161718192021222324252627282930313233/** * 在mybatis中针对CRUD一共有四个注解 * * @author wgy * @Select @Insert @Update @Delete */public interface IUserDao &#123; /** * 查询所有用户 * * @return */ @Select(\"select * from user\") @Results(id = \"userMap\", value = &#123; @Result(id = true, column = \"id\", property = \"userId\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"address\", property = \"userAddress\"), @Result(column = \"sex\", property = \"userSex\"), @Result(column = \"birthday\", property = \"userBirthday\") &#125;) List&lt;User&gt; findAll(); /** * 根据id查询用户 * * @param userId * @return */ @Select(\"select * from user where id=#&#123;id&#125; \") @ResultMap(\"userMap\") User findById(Integer userId);&#125; 3.3.2.4 测试一对一关联及延迟加载1234@Testpublic void testFindAll() &#123; List&lt;Account&gt; accounts = accountDao.findAll();&#125; 3.3.3 使用注解实现一对多复杂关系映射查询用户信息时，也要查询他的账户列表。使用注解方式实现。 3.3.3.1 User 实体类加入List&lt;Account&gt;12345678910111213141516/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer userId; private String userName; private String userAddress; private String userSex; private Date userBirthday; //一对多关系映射：一个用户对应多个账户 private List&lt;Account&gt; accounts; ...&#125; 3.3.3.2 编写用户的持久层接口并使用注解配置123456789101112131415/** * 查询所有用户 * * @return */@Select(\"select * from user\")@Results(id = \"userMap\", value = &#123; @Result(id = true, column = \"id\", property = \"userId\"), @Result(column = \"username\", property = \"userName\"), @Result(column = \"address\", property = \"userAddress\"), @Result(column = \"sex\", property = \"userSex\"), @Result(column = \"birthday\", property = \"userBirthday\"), @Result(property = \"accounts\", column = \"id\", many = @Many(select = \"com.wgy.dao.IAccountDao.findAccountByUid\", fetchType = FetchType.LAZY))&#125;)List&lt;User&gt; findAll(); 3.3.3.3 编写账户的持久层接口并使用注解配置12345678/** * 根据用户id查询账户信息 * * @param userId * @return */@Select(\"select * from account where uid = #&#123;userId&#125;\")List&lt;Account&gt; findAccountByUid(Integer userId); 3.3.3.4 测试一对多关联及延迟加载1234@Testpublic void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll();&#125; 3.4 mybatis 基于注解的二级缓存3.4.1 在 SqlMapConfig 中开启二级缓存支持12345&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 3.4.2 在持久层接口中使用注解配置二级缓存1234567/** * * @author wgy */@CacheNamespace(blocking = true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125;","tags":[{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://wgy1993.gitee.io/tags/MyBatis/"}]},{"title":"MyBatis(三)","date":"2020-06-22T04:21:01.000Z","path":"archives/f1b11122.html","text":"1. Mybatis 连接池与事务深入1.1 Mybatis 的连接池技术在 Mybatis 的 SqlMapConfig.xml 配置文件中，通过&lt;dataSource type=&quot;pooled&quot;&gt;来实现 Mybatis 中连接池的配置。 1.1.1 Mybatis 连接池的分类在 Mybatis 中我们将它的数据源 dataSource 分为以下几类： UNPOOLED：不使用连接池的数据源 POOLED：使用连接池的数据源 JNDI：使用 JNDI 实现的数据源 在这三种数据源中，我们一般采用的是 POOLED 数据源（很多时候我们所说的数据源就是为了更好的管理数据库连接，也就是我们所说的连接池技术）。 1.1.2 Mybatis 中数据源的配置1234567&lt;!-- 配置数据源（连接池）信息 --&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; MyBatis 在初始化时，根据&lt;dataSource&gt;的 type 属性来创建相应类型的的数据源 DataSource。 1.1.3 Mybatis 中 DataSource 的存取MyBatis 是通过工厂模式来创建数据源 DataSource 对象的， MyBatis 定义了抽象的工厂接口:org.apache.ibatis.datasource.DataSourceFactory,通过其 getDataSource()方法返回数据源DataSource。 MyBatis 创建了 DataSource 实例后，会将其放到 Configuration 对象内的 Environment 对象中， 供以后使用。 1.1.4 Mybatis 中连接的获取过程分析当我们需要创建 SqlSession 对象并需要执行 SQL 语句时，这时候 MyBatis 才会去调用 dataSource 对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。当我们用完了就再立即将数据库连接归还到连接池中。 1.2 Mybatis 的事务控制1.2.1 JDBC 中事务的回顾在 JDBC 中我们可以将事务的提交改为自动方式，通过 setAutoCommit()方法就可以调整。 1.2.2 Mybatis 中事务提交方式Mybatis 中事务的提交方式，本质上就是调用 JDBC 的 setAutoCommit()来实现事务控制。 123456789101112131415161718192021222324252627282930@Testpublic void testSaveUser() throws Exception &#123; User user = new User(); user.setUsername(\"mybatis user09\"); //6.执行操作 int res = userDao.saveUser(user); System.out.println(res); System.out.println(user.getId());&#125;@Before//在测试方法执行之前执行public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class);&#125;@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; //7.提交事务 session.commit(); //8.释放资源 session.close(); in.close();&#125; 控制台输出的结果： Connection 的整个变化过程，通过分析我们能够发现之前的 CUD 操作过程中，我们都要手动进行事务的提交，原因是 setAutoCommit()方法，在执行时它的值被设置为 false 了，所以我们在 CUD 操作中，必须通过sqlSession.commit()方法来执行提交操作。 1.2.3 Mybatis 自动提交事务的设置12//4.创建 SqlSession 对象session = factory.openSession(true); 所对应的 DefaultSqlSessionFactory 类的源代码： 2. Mybatis 的动态 SQL 语句2.1 &lt;if&gt;标签123456789101112&lt;!-- 根据条件查询 --&gt;&lt;select id=\"findByUser\" resultType=\"user\" parameterType=\"user\"&gt; select * from user where 1=1 &lt;if test=\"username!=null and username != '' \"&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"address != null\"&gt; and address like #&#123;address&#125; &lt;/if&gt;&lt;/select&gt; 2.2 &lt;where&gt;标签为了简化上面 where 1=1 的条件拼装，我们可以采用&lt;where&gt;标签来简化开发。 123456789101112&lt;select id=\"findUserByCondition\" resultMap=\"userMap\" parameterType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"userName != null\"&gt; and username = #&#123;userName&#125; &lt;/if&gt; &lt;if test=\"userSex != null\"&gt; and sex = #&#123;userSex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 2.3 &lt;foreach&gt; 标签2.3.1 需求传入多个 id 查询用户信息，用下边两个 sql 实现： 12SELECT * FROM USERS WHERE username LIKE '%张%' AND (id =10 OR id =89 OR id=16)SELECT * FROM USERS WHERE username LIKE '%张%' AND id IN (10,89,16) 这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。 2.3.2 在 QueryVo 中加入一个 List 集合用于封装参数123456789/** * @author wgy */public class QueryVo &#123; private User user; private List&lt;Integer&gt; ids; ...&#125; 2.3.3 映射配置12345678910111213141516171819202122&lt;!-- 根据queryvo中的Id集合实现查询用户列表 --&gt;&lt;select id=\"findUserInIds\" resultMap=\"userMap\" parameterType=\"queryvo\"&gt; select * from user &lt;where&gt; &lt;if test=\"ids != null and ids.size()&gt;0\"&gt; &lt;foreach collection=\"ids\" open=\"and id in (\" close=\")\" separator=\",\" item=\"uid\"&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;SQL 语句：select 字段 from user where id in (?)&lt;foreach&gt;标签用于遍历集合，它的属性： collection:代表要遍历的集合元素，注意编写时不要写#&#123;&#125; open:代表语句的开始部分 close:代表结束部分 item:代表遍历集合的每个元素，生成的变量名 sperator:代表分隔符 2.4 简化编写的 SQL 片段Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。 2.4.1 定义代码片段12345&lt;!-- 了解的内容：抽取重复的sql语句--&gt;&lt;sql id=\"defaultUser\"&gt; select * from user&lt;/sql&gt; 2.4.2 引用代码片段1234&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userMap\"&gt; &lt;include refid=\"defaultUser\"&gt;&lt;/include&gt;&lt;/select&gt; 3. Mybatis 多表查询之一对多用户为User 表，账户为Account表。一个用户（User）可以有多个账户（Account）。 3.1 一对一查询( 多对一)查询所有账户信息，关联查询下单用户信息。 3.1.1 方式一3.1.1.1 定义账户信息的实体类1234567public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; ...&#125; 3.1.1.2 编写 Sql 语句1234select a.*, u.username, u.addressfrom account a, user uwhere u.id &#x3D; a.uid; 3.1.1.3 定义 AccountUser 类为了能够封装上面 SQL 语句的查询结果，定义 AccountUser 类中要包含账户信息同时还要包含用户信息，所以我们要在定义 AccountUser 类时可以继承 User 类。 123456789/** * @author wgy */public class AccountUser extends Account &#123; private String username; private String address; ...&#125; 3.1.1.4 映射配置1234567&lt;!--查询所有账户同时包含用户名和地址信息--&gt;&lt;select id=\"findAllAccount\" resultType=\"accountuser\"&gt; select a.*, u.username, u.address from account a, user u where u.id = a.uid;&lt;/select&gt; 定义专门的 po 类作为输出类型，其中定义了 sql 查询结果集所有的字段。此方法较为简单，企业中使用普遍。 3.1.2 方式二使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。 通过面向对象的(has a)关系可以得知，我们可以在 Account 类中加入一个 User 类的对象来代表这个账户是哪个用户的。 3.1.2.1 修改 Account 类在 Account 类中加入 User 类的对象作为 Account 类的一个属性。 123456789101112131415/** * 账户实体类 * * @author wgy */public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //从表实体应该包含一个主表实体的对象引用 private User user; ...&#125; 3.1.2.2 映射配置12345678910111213141516171819202122&lt;!-- 定义封装account和user的resultMap --&gt;&lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"aid\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射：配置封装user的内容--&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- 查询所有 --&gt;&lt;select id=\"findAll\" resultMap=\"accountUserMap\"&gt; select u.*, a.id as aid, a.uid, a.money from account a, user u where u.id = a.uid;&lt;/select&gt; 3.2 一对多查询查询所有用户信息及用户关联的账户信息。 3.2.1 编写 SQL 语句123456SELECT u.*, acc.id id, acc.uid, acc.moneyFROM user u LEFT JOIN account acc ON u.id &#x3D; acc.uid 3.2.2 User类加入 List&lt;Account&gt;12345678910111213141516/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //一对多关系映射：主表实体应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; ...&#125; 3.2.3 映射配置12345678910111213141516171819202122232425262728&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=\"userAccountMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"account\"&gt; &lt;id column=\"aid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; select * from user u left outer join account a on u.id = a.uid&lt;/select&gt;collection 部分定义了用户关联的账户信息。表示关联查询结果集property=\"accounts\" ： 关联查询的结果集存储在 User 对象的上哪个属性。ofType=\"account\" ： 指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。 4. Mybatis 多表查询之多对多多对多关系其实是双向的一对多关系。一个用户可以有多个角色，一个角色可以赋予多个用户。 4.1 实现 Role 到 User 多对多实现查询所有角色并且加载它所分配的用户信息。 4.1.1 编写 SQL 语句1234select u.*, r.id as rid, r.role_name, r.role_descfrom role r left outer join user_role ur on r.id &#x3D; ur.rid left outer join user u on u.id &#x3D; ur.uid 4.1.2 编写角色实体类1234567891011121314/** * 角色实体类 * * @author wgy */public class Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; //多对多的关系映射：一个角色可以赋予多个用户 private List&lt;User&gt; users; ...&#125; 4.1.3 映射配置123456789101112131415161718192021&lt;!--定义role表的ResultMap--&gt;&lt;resultMap id=\"roleMap\" type=\"role\"&gt; &lt;id property=\"roleId\" column=\"rid\"&gt;&lt;/id&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;result property=\"roleDesc\" column=\"role_desc\"&gt;&lt;/result&gt; &lt;collection property=\"users\" ofType=\"user\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"roleMap\"&gt; select u.*, r.id as rid, r.role_name, r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid&lt;/select&gt; 4.2 实现 User 到 Role 的多对多4.2.1 编写 SQL 语句1234select u.*, r.id as rid, r.role_name, r.role_descfrom user u left outer join user_role ur on u.id &#x3D; ur.uid left outer join role r on r.id &#x3D; ur.rid 4.2.2 编写用户实体类12345678910111213141516/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //多对多的关系映射：一个用户可以具备多个角色 private List&lt;Role&gt; roles; ...&#125; 4.2.3 映射配置12345678910111213141516171819202122&lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=\"userMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!-- 配置角色集合的映射 --&gt; &lt;collection property=\"roles\" ofType=\"role\"&gt; &lt;id property=\"roleId\" column=\"rid\"&gt;&lt;/id&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;result property=\"roleDesc\" column=\"role_desc\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select u.*, r.id as rid, r.role_name, r.role_desc from user u left outer join user_role ur on u.id = ur.uid left outer join role r on r.id = ur.rid&lt;/select&gt; 5. JNDI数据源JNDI：Java Naming and Directory Interface。是SUN公司推出的一套规范，属于JavaEE技术之一。目的是模仿windows系统中的注册表。在服务器中注册数据源 5.1 创建Maven的war工程并导入坐标123456789101112131415161718192021222324252627282930313233343536373839&lt;groupId&gt;com.wgy&lt;/groupId&gt;&lt;artifactId&gt;MyBatis10_JNDI&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 5.2 在webapp文件下创建META-INF目录 5.3 在META-INF目录中建立一个名为context.xml的配置文件1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Context&gt; &lt;!-- &lt;Resource name=\"jdbc/mybatis\" 数据源的名称 type=\"javax.sql.DataSource\" 数据源类型 auth=\"Container\" 数据源提供者 maxActive=\"20\" 最大活动数 maxWait=\"10000\" 最大等待时间 maxIdle=\"5\" 最大空闲数 username=\"root\" 用户名 password=\"root\" 密码 driverClassName=\"com.mysql.jdbc.Driver\" 驱动类 url=\"jdbc:mysql://localhost:3306/mybatis\" 连接url字符串 /&gt; --&gt; &lt;Resource name=\"jdbc/mybatis\" type=\"javax.sql.DataSource\" auth=\"Container\" maxActive=\"20\" maxWait=\"10000\" maxIdle=\"5\" username=\"root\" password=\"root\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/mybatis\" /&gt;&lt;/Context&gt; 5.4 修改SqlMapConfig.xml中的配置1234567891011121314&lt;!--配置环境--&gt;&lt;environments default=\"dev\"&gt; &lt;!-- 配置dev的环境--&gt; &lt;environment id=\"dev\"&gt; &lt;!-- 配置事务控制的方式 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 配置连接数据库的必备信息 type属性表示是否使用数据源（连接池）--&gt; &lt;dataSource type=\"JNDI\"&gt; &lt;property name=\"data_source\" value=\"java:comp/env/jdbc/mybatis\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;java:comp/env/为固定写法，后面为context.xml中设置的数据源的名称jdbc/mybatis","tags":[{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://wgy1993.gitee.io/tags/MyBatis/"}]},{"title":"MyBatis(二)","date":"2020-06-21T14:11:23.000Z","path":"archives/8f423109.html","text":"1. 基于代理 Dao 实现 CRUD 操作使用要求： 持久层接口和持久层接口的映射配置必须在相同的包下 持久层映射配置中 mapper 标签的 namespace 属性取值必须是持久层接口的全限定类名 SQL 语句的配置标签&lt;select&gt;,&lt;insert&gt;,&lt;delete&gt;,&lt;update&gt;的 id 属性必须和持久层接口的方法名相同。 1.1 根据 ID 查询1.1.1 在持久层接口中添加查询方法1234567/** * 根据id查询用户信息 * * @param userId * @return */User findById(Integer userId); 1.1.2 在用户的映射配置文件中配置123456&lt;!-- 根据id查询用户 --&gt;&lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.wgy.domain.User\"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt; 细节： resultType 属性： 用于指定结果集的类型。 parameterType 属性： 用于指定传入参数的类型。 sql 语句中使用#{} 字符 ： 它代表占位符，相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。 具体的数据是由#{}里面的内容决定的。 #{} 中内容的写法： 由于数据类型是基本类型，所以此处可以随意写。 1.1.3 在测试类添加测试12345678910111213141516171819202122232425262728293031323334353637383940/** * 测试mybatis的crud操作 * * @author wgy */public class MyBatisTest &#123; private InputStream in; private SqlSession sqlSession; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(); //4.获取dao的代理对象 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy() throws Exception &#123; //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询一个操作 */ @Test public void testFindOne() &#123; //5.执行查询一个方法 User user = userDao.findById(49); System.out.println(user); &#125;&#125; 1.2 保存操作1.2.1 在持久层接口中添加新增方法123456/** * 保存用户 * * @param user */void saveUser(User user); 1.2.2 在用户的映射配置文件中配置12345&lt;!-- 保存用户 --&gt;&lt;insert id=\"saveUser\" parameterType=\"com.wgy.domain.User\"&gt; insert into user(username, address, sex, birthday) values (#&#123;userName&#125;, #&#123;userAddress&#125;, #&#123;userSex&#125;, #&#123;userBirthday&#125;);&lt;/insert&gt; 细节： parameterType 属性： 代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。 sql 语句中使用#{}字符： 它代表占位符，相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。 具体的数据是由#{}里面的内容决定的。 #{}中内容的写法： 由于我们保存方法的参数是 一个 User 对象，此处要写 User 对象中的属性名称。 它用的是 ognl 表达式。 ognl 表达式： 它是 apache 提供的一种表达式语言，全称是：Object Graphic Navigation Language 对象图导航语言 它是按照一定的语法格式来获取数据的。 语法格式就是使用 #{对象.对象}的方式 #{user.username}它会先去找 user 对象，然后在 user 对象中找到 username 属性，并调用getUsername()方法把值取出来。但是我们在 parameterType 属性上指定了实体类名称，所以可以省略 user.而直接写 username。 1.2.3 在测试类添加测试12345678910111213141516/** * 测试保存操作 */@Testpublic void testSave() &#123; User user = new User(); user.setUserName(\"insert User property\"); user.setUserAddress(\"北京市顺义区\"); user.setUserSex(\"男\"); user.setUserBirthday(new Date()); System.out.println(\"保存操作之前：\" + user); //5.执行保存方法 userDao.saveUser(user); System.out.println(\"保存操作之后：\" + user);&#125; 打开 Mysql 数据库发现并没有添加任何记录，原因是什么？ 这一点和 jdbc 是一样的，我们在实现增删改时一定要去控制事务的提交，那么在 mybatis 中如何控制事务提交呢？ 可以使用:session.commit();来实现事务提交。加入事务提交后的代码如下： 12345678@After//用于在测试方法执行之后执行public void destroy() throws Exception &#123; //提交事务 sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close();&#125; 1.2.4 问题扩展：新增用户 id 的返回值新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。 123456789&lt;!-- 保存用户 --&gt;&lt;insert id=\"saveUser\" parameterType=\"com.wgy.domain.User\"&gt; &lt;!-- 配置插入操作后，获取插入数据的id --&gt; &lt;selectKey keyProperty=\"userId\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username, address, sex, birthday) values (#&#123;userName&#125;, #&#123;userAddress&#125;, #&#123;userSex&#125;, #&#123;userBirthday&#125;);&lt;/insert&gt; 1.3 用户更新1.3.1 在持久层接口中添加更新方法123456/** * 更新用户 * * @param user */void updateUser(User user); 1.3.2 在用户的映射配置文件中配置123456789&lt;!-- 更新用户 --&gt;&lt;update id=\"updateUser\" parameterType=\"com.wgy.domain.User\"&gt; update user set username=#&#123;userName&#125;, address=#&#123;userAddress&#125;, sex=#&#123;userSex&#125;, birthday=#&#123;userBirthday&#125; where id = #&#123;userId&#125;&lt;/update&gt; 1.3.3 在测试类添加测试123456789101112131415/** * 测试更新操作 */@Testpublic void testUpdate() &#123; User user = new User(); user.setUserId(49); user.setUserName(\"mybastis update user\"); user.setUserAddress(\"北京市顺义区\"); user.setUserSex(\"女\"); user.setUserBirthday(new Date()); //5.执行保存方法 userDao.updateUser(user);&#125; 1.4 用户删除1.4.1 在持久层接口中添加删除方法123456/** * 根据Id删除用户 * * @param userId */void deleteUser(Integer userId); 1.4.2 在用户的映射配置文件中配置123456&lt;!-- 删除用户--&gt;&lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id = #&#123;uid&#125;&lt;/delete&gt; 1.4.3 在测试类添加测试12345678/** * 测试删除操作 */@Testpublic void testDelete() &#123; //5.执行删除方法 userDao.deleteUser(48);&#125; 1.5 用户模糊查询1.5.1 在持久层接口中添加模糊查询方法1234567/** * 根据名称模糊查询用户信息 * * @param username * @return */List&lt;User&gt; findByName(String username); 1.5.2 在用户的映射配置文件中配置123456&lt;!-- 根据名称模糊查询 --&gt;&lt;select id=\"findByName\" parameterType=\"string\" resultType=\"com.wgy.domain.User\"&gt; select * from user where username like #&#123;name&#125;&lt;/select&gt; 1.5.3 在测试类添加测试1234567891011/** * 测试模糊查询操作 */@Testpublic void testFindByName() &#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName(\"%王%\"); for (User user : users) &#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 我们在配置文件中没有加入%来作为模糊查询的条件，所以在传入字符串实参时，就需要给定模糊查询的标识%。配置文件中的#{username}也只是一个占位符，所以 SQL 语句显示为“？”。 1.5.4 模糊查询的另一种配置方式第一步：修改 SQL 语句的配置，配置如下： 123456&lt;!-- 根据名称模糊查询 --&gt;&lt;select id=\"findByName\" parameterType=\"string\" resultType=\"com.wgy.domain.User\"&gt; select * from user where username like '%$&#123;value&#125;%'&lt;/select&gt; 我们在上面将原来的#{}占位符，改成了${value}。注意如果用模糊查询的这种写法，那么${value}的写法就是固定的，不能写成其它名字。 第二步：测试，如下： 1234567891011/** * 测试模糊查询操作 */@Testpublic void testFindByName() &#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName(\"王\"); for (User user : users) &#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 可以发现，我们在程序代码中就不需要加入模糊查询的匹配符%了，这两种方式的实现效果是一样的，但执行的语句是不一样的。 1.5.5 #{} 与${} 的区别 #{} 表示一个占位符号 通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。 ${} 表示拼接 sql 串 通过${}可以将 parameterType 传入的内容拼接在 sql中且不进行 jdbc 类型转换， ${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。 1.5.6 模糊查询的${value} 源码分析 这就说明了源码中指定了读取的 key 的名字就是”value”，所以我们在绑定参数时就只能叫 value 的名字了。 1.6 查询使用聚合函数1.6.1 在持久层接口中添加聚合函数查询方法123456/** * 查询总用户数 * * @return */int findTotal(); 1.6.2 在用户的映射配置文件中配置12345&lt;!-- 获取用户的总记录条数 --&gt;&lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(id) from user;&lt;/select&gt; 1.6.3 在测试类添加测试123456789/** * 测试查询总记录条数 */@Testpublic void testFindTotal() &#123; //5.执行查询一个方法 int count = userDao.findTotal(); System.out.println(count);&#125; 2. Mybatis 的参数深入2.1 parameterType 配置参数2.1.1 使用说明 SQL 语句传参，使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类 2.1.2 注意事项基本类 型和 String 我们可以直接写类型名称 ，也可以使用包名 . 类名的方式 ，例如 ：java.lang.String。实体类类型，目前我们只能使用全限定类名。 2.2 传递 pojo 包装对象开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。Pojo 类中包含 pojo。 需求：根据用户名查询用户信息，查询条件放到 QueryVo 的 user 属性中。 2.2.1 编写 QueryVo123456789101112131415/** * @author wgy */public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 2.2.2 在持久层接口中添加查询方法123456/** * 根据queryVo中的条件查询用户 * @param vo * @return */List&lt;User&gt; findUserByVo(QueryVo vo); 2.2.3 在用户的映射配置文件中配置123456&lt;!-- 根据queryVo的条件查询用户 --&gt;&lt;select id=\"findUserByVo\" parameterType=\"com.wgy.domain.QueryVo\" resultType=\"com.wgy.domain.User\"&gt; select * from user where username like #&#123;user.userName&#125;&lt;/select&gt; 2.2.4 在测试类添加测试123456789101112131415/** * 测试使用QueryVo作为查询条件 */@Testpublic void testFindByVo() &#123; QueryVo vo = new QueryVo(); User user = new User(); user.setUserName(\"%王%\"); vo.setUser(user); //5.执行查询一个方法 List&lt;User&gt; users = userDao.findUserByVo(vo); for (User u : users) &#123; System.out.println(u); &#125;&#125; 3. Mybatis 的输出结果封装3.1 resultType 配置结果类型resultType 属性可以指定结果集的类型，它支持基本类型和实体类类型。 它和 parameterType 一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。 3.1.1 基本类型示例案例1.6 3.1.2 实体类类型示例案例1.1 3.1.3 特殊情况示例3.1.3.1 修改实体类实体类属性和数据库表的列名已经不一致 3.1.3.2 修改映射配置使用别名查询 12345&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultType=\"com.wgy.domain.User\"&gt; select id as userId, username as userName, address as userAddress, sex as userSex, birthday as userBirthday from user;&lt;/select&gt; 3.2 resultMap 结果类型resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 3.2.1 定义 resultMap12345678910111213141516&lt;!-- 建立 User 实体和数据库表的对应关系 type 属性：指定实体类的全限定类名 id 属性：给定一个唯一标识，是给查询 select 标签引用用的。--&gt;&lt;resultMap type&#x3D;&quot;com.wgy.domain.User&quot; id&#x3D;&quot;userMap&quot;&gt; &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;userId&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;username&quot; property&#x3D;&quot;userName&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;sex&quot; property&#x3D;&quot;userSex&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;address&quot; property&#x3D;&quot;userAddress&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;birthday&quot; property&#x3D;&quot;userBirthday&quot;&#x2F;&gt;&lt;&#x2F;resultMap&gt;id 标签：用于指定主键字段result 标签：用于指定非主键字段column 属性：用于指定数据库列名property 属性：用于指定实体类属性名称 3.2.2 映射配置12345&lt;!--配置查询所有--&gt;&lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select * from user&lt;/select&gt; 4. Mybatis 传统 DAO 层开发使用 Mybatis 开发 Dao，通常有两个方法，即原始 Dao开发方式和 Mapper 接口代理开发方式。而现在主流的开发方式是接口代理开发方式，这种方式总体上更加简便。 4.1 Mybatis 实现 DAO 的传统开发方式4.1.1 持久层 Dao 接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ List&lt;User&gt; findAll(); /** * 保存用户 * * @param user */ void saveUser(User user); /** * 更新用户 * * @param user */ void updateUser(User user); /** * 根据Id删除用户 * * @param userId */ void deleteUser(Integer userId); /** * 根据id查询用户信息 * * @param userId * @return */ User findById(Integer userId); /** * 根据名称模糊查询用户信息 * * @param username * @return */ List&lt;User&gt; findByName(String username); /** * 查询总用户数 * * @return */ int findTotal();&#125; 4.1.2 持久层 Dao 实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 持久层实现类 * * @author wgy */public class UserDaoImpl implements IUserDao &#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; public List&lt;User&gt; findAll() &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用SqlSession中的方法，实现查询列表 //参数就是能获取配置信息的key List&lt;User&gt; users = session.selectList(\"com.wgy.dao.IUserDao.findAll\"); //3.释放资源 session.close(); return users; &#125; public void saveUser(User user) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用方法实现保存 session.insert(\"com.wgy.dao.IUserDao.saveUser\", user); //3.提交事务 session.commit(); //4.释放资源 session.close(); &#125; public void updateUser(User user) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用方法实现更新 session.update(\"com.wgy.dao.IUserDao.updateUser\", user); //3.提交事务 session.commit(); //4.释放资源 session.close(); &#125; public void deleteUser(Integer userId) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用方法实现更新 session.update(\"com.wgy.dao.IUserDao.deleteUser\", userId); //3.提交事务 session.commit(); //4.释放资源 session.close(); &#125; public User findById(Integer userId) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用SqlSession中的方法，实现查询一个 User user = session.selectOne(\"com.wgy.dao.IUserDao.findById\", userId); //3.释放资源 session.close(); return user; &#125; public List&lt;User&gt; findByName(String username) &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用SqlSession中的方法，实现查询列表 List&lt;User&gt; users = session.selectList(\"com.wgy.dao.IUserDao.findByName\", username); //3.释放资源 session.close(); return users; &#125; public int findTotal() &#123; //1.根据factory获取SqlSession对象 SqlSession session = factory.openSession(); //2.调用SqlSession中的方法，实现查询一个 Integer count = session.selectOne(\"com.wgy.dao.IUserDao.findTotal\"); //3.释放资源 session.close(); return count; &#125;&#125; 4.1.3 持久层映射配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultType=\"com.wgy.domain.User\"&gt; select * from user &lt;/select&gt; &lt;!-- 保存用户 --&gt; &lt;insert id=\"saveUser\" parameterType=\"com.wgy.domain.User\"&gt; &lt;!-- 配置插入操作后，获取插入数据的id --&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username, address, sex, birthday) values (#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;); &lt;/insert&gt; &lt;!-- 更新用户 --&gt; &lt;update id=\"updateUser\" parameterType=\"com.wgy.domain.User\"&gt; update user set username=#&#123;username&#125;, address=#&#123;address&#125;, sex=#&#123;sex&#125;, birthday=#&#123;birthday&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除用户--&gt; &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id = #&#123;uid&#125; &lt;/delete&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.wgy.domain.User\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt; &lt;!-- 根据名称模糊查询 --&gt; &lt;select id=\"findByName\" parameterType=\"string\" resultType=\"com.wgy.domain.User\"&gt; select * from user where username like #&#123;name&#125; &lt;/select&gt; &lt;!-- 获取用户的总记录条数 --&gt; &lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(id) from user; &lt;/select&gt;&lt;/mapper&gt; 4.1.4 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 测试mybatis的crud操作 * * @author wgy */public class MyBatisTest &#123; private InputStream in; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.使用工厂对象，创建dao对象 userDao = new UserDaoImpl(factory); &#125; @After//用于在测试方法执行之后执行 public void destroy() throws Exception &#123; //6.释放资源 in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll() &#123; //5.执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试保存操作 */ @Test public void testSave() &#123; User user = new User(); user.setUsername(\"dao impl user\"); user.setAddress(\"北京市顺义区\"); user.setSex(\"男\"); user.setBirthday(new Date()); System.out.println(\"保存操作之前：\" + user); //5.执行保存方法 userDao.saveUser(user); System.out.println(\"保存操作之后：\" + user); &#125; /** * 测试更新操作 */ @Test public void testUpdate() &#123; User user = new User(); user.setId(50); user.setUsername(\"userdaoimpl update user\"); user.setAddress(\"北京市顺义区\"); user.setSex(\"女\"); user.setBirthday(new Date()); //5.执行保存方法 userDao.updateUser(user); &#125; /** * 测试删除操作 */ @Test public void testDelete() &#123; //5.执行删除方法 userDao.deleteUser(54); &#125; /** * 测试删除操作 */ @Test public void testFindOne() &#123; //5.执行查询一个方法 User user = userDao.findById(50); System.out.println(user); &#125; /** * 测试模糊查询操作 */ @Test public void testFindByName() &#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName(\"%王%\"); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试查询总记录条数 */ @Test public void testFindTotal() &#123; //5.执行查询一个方法 int count = userDao.findTotal(); System.out.println(count); &#125;&#125; 5. SqlMapConfig.xml 配置文件5.1 配置内容5.1.1 SqlMapConfig.xml 中配置的内容和顺序1234567891011121314151617-properties （属性） --property-settings（全局配置参数） --setting-typeAliases （类型别名） --typeAliase --package-typeHandlers（类型处理器）-objectFactory（对象工厂）-plugins（插件）-environments（环境集合属性对象） --environment（环境子属性对象） ---transactionManager（事务管理） ---dataSource（数据源）-mappers （映射器） --mapper --package 5.2 properties（属性）在使用 properties 标签配置时，我们可以采用两种方式指定属性配置。 5.2.1 第一种123456&lt;properties&gt; &lt;property name=\"jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbc.url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"jdbc.username\" value=\"root\"/&gt; &lt;property name=\"jdbc.password\" value=\"root\"/&gt;&lt;/properties&gt; 5.2.2 第二种5.2.2.1 在 classpath 下定义 db.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root 5.2.2.2 properties 标签配置12345678910111213141516&lt;!-- 配置properties 可以在标签内部配置连接数据库的信息。也可以通过属性引用外部配置文件信息 resource属性： 常用的 用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于类路径下。 resource=\"db.properties\" url属性： 是要求按照Url的写法来写地址 URL：Uniform Resource Locator 统一资源定位符。它是可以唯一标识一个资源的位置。 它的写法： http://localhost:8080/mybatisserver/demo1Servlet 协议 主机 端口 URI URI:Uniform Resource Identifier 统一资源标识符。它是在应用中可以唯一定位一个资源的。--&gt;&lt;properties url=\"file:///E:\\MyIDEAWorkSpace\\MyBatis\\MyBatis05_CRUD\\src\\main\\resources\\db.properties\"&gt;&lt;/properties&gt; 5.2.3 dataSource 标签引用配置1234567&lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt;&lt;/dataSource&gt; 5.3 typeAliases（类型别名）除了前面 Mybatis 支持的默认别名，也可以采用自定义别名方式来开发。 5.3.1 自定义别名在 SqlMapConfig.xml 中配置： 123456&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=\"user\" type=\"com.wgy.domain.User\"/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &lt;package name=\"com.wgy.domain\"/&gt;&lt;/typeAliases&gt; 5.4 mappers（映射器）5.4.1 &lt;mapper resource=&quot; &quot; /&gt;12使用相对于类路径的资源如：&lt;mapper resource=\"com/wgy/dao/IUserDao.xml\" /&gt; 5.4.2 &lt;mapper class=&quot; &quot; /&gt;123使用 mapper 接口类路径如：&lt;mapper class=\"com.wgy.dao.UserDao\"/&gt;注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 5.4.3 &lt;package name=&quot;&quot;/&gt;123注册指定包下的所有 mapper 接口如：&lt;package name=\"com.wgy.dao\"/&gt;注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。","tags":[{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://wgy1993.gitee.io/tags/MyBatis/"}]},{"title":"MyBatis(一)","date":"2020-06-20T07:25:51.000Z","path":"archives/2073aa6b.html","text":"1. 单独使用jdbc编程问题总结1.1 jdbc编程步骤 加载数据库驱动 创建并获取数据库链接 创建jdbc statement对象 设置sql语句 设置sql语句中的参数(使用preparedStatement) 通过statement执行sql并获取结果 对sql执行结果进行解析处理 释放资源(resultSet、preparedstatement、connection) 1.2 jdbc程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; //加载数据库驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //通过驱动管理类获取数据库链接 connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\", \"root\", \"root\"); //定义sql语句 ?表示占位符 String sql = \"select * from user where username = ?\"; //获取预处理statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, \"王五\"); //向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next())&#123; System.out.println(resultSet.getString(\"id\")+\" \"+resultSet.getString(\"username\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //释放资源 if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(preparedStatement!=null)&#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上边使用jdbc的原始方法（未经封装）实现了查询数据库表记录的操作。 1.3 jdbc问题总结如下1、数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。 设想：使用数据库连接池管理数据库连接。 2、将sql语句硬编码到java代码中，如果sql 语句修改，需要重新编译java代码，不利于系统维护。 设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。 3、向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。 设想：将sql语句及占位符号和参数全部配置在xml中。 4、从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，，不利于系统维护。 设想：将查询的结果集，自动映射成java对象。 2. MyBatis框架2.1 MyBatis是什么？mybatis是一个持久层的框架，它对jdbc的操作数据库的过程进行封装，不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。是apache下的顶级项目。 mybatis托管到goolecode下，再后来托管到github下(https://github.com/mybatis/mybatis-3/releases)。 mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。 mybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射） 2.2 MyBatis框架 2.3 与hibernate不同Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 2.4 Mybatis与iBatis的主要差异对比他们都是优秀的持久层框架，MyBatis是现在最常用的持久层框架，可以动态地拼接sql语句，非常人性化，更适合编辑复杂的sql；iBatis就是MyBatis前身，他们有很多相似的地方 1、传入参数 iBatis是parameterClass，而MyBatis是可以不写的，也可以用parameterType,parameterClass iBatis的传出参数关键字是resultClass，而MyBatis是resultMap 2、判断语句 对于MyBatis的很简单，只要在where或者if标签里面添加test=“”就可以了，里面写判断条件。 但是iBatis的就麻烦了许多了，它将每个方法都进行了封装。例如isNull：判断字段是否为null 3、循环的使用 iBatis是使用Iterate，而MyBatis使用的是ForEach方法 4、MyBatis实现了DAO接口与xml映射文件的绑定，使用更加方便 3. MyBatis 框架快速入门3.1 Mybatis 框架开发的准备3.1.1 官网下载 Mybatis 框架从百度中“mybatis download”可以下载最新的 Mybatis 开发包。https://mybatis.org/mybatis-3/ 进入选择语言的界面，进入中文版本的开发文档。 下载相关的 jar 包或 maven 开发的坐标。 3.2 搭建 Mybatis 开发环境3.2.1 创建 maven 工程创建 MyBatis01 的工程，工程信息如下： 1234&lt;groupId&gt;com.wgy&lt;/groupId&gt;&lt;artifactId&gt;MyBatis01&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 3.2.2 添加 Mybatis3.4.5 的坐标在 pom.xml 文件中添加 Mybatis3.4.5 的坐标，如下： 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2.3 log4j.properties123456789log4j.rootLogger=DEBUG,consolelog4j.additivity.org.apache=true# 控制台(console)log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.ImmediateFlush=truelog4j.appender.console.Target=System.outlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n 3.2.4 编写 User 实体类1234567891011121314/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; ...&#125; 3.2.5 编写持久层口接口 IUserDao1234567891011121314/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ List&lt;User&gt; findAll();&#125; 3.2.6 编写持久层接口的件映射文件 IUserDao.xml创建位置：必须和持久层接口在相同的包中。名称：必须以持久层接口名称命名文件名，扩展名是.xml 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.wgy.dao.IUserDao&quot;&gt; &lt;!--配置查询所有--&gt; &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;com.wgy.domain.User&quot;&gt; select * from user &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; 3.2.7 编写 SqlMapConfig.xml12345678910111213141516171819202122232425262728&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default&#x3D;&quot;dev&quot;&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id&#x3D;&quot;dev&quot;&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;com&#x2F;wgy&#x2F;dao&#x2F;IUserDao.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; 3.2.8 编写测试类1234567891011121314151617181920212223242526272829303132/** * mybatis的入门案例 * * @author wgy */public class MyBatisTest &#123; /** * 入门案例 * * @param args */ public static void main(String[] args) throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 3.3 基于注解的 mybatis 使用3.3.1 在持久层接口中添加注解123456789101112131415/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 3.3.2 修改 SqlMapConfig.xml123456&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名--&gt;&lt;mappers&gt; &lt;mapper class&#x3D;&quot;com.wgy.dao.IUserDao&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt; 注意事项：在使用基于注解的 Mybatis 配置时，请移除 xml 的映射配置（IUserDao.xml） 。 4. 自定义 Mybatis 框架4.1 自定义 Mybatis 框架的分析4.1.1 涉及知识点介绍构建一个属于自己的持久层框架，将会涉及到的一些知识点：工厂模式（Factory 工厂模式） 、构造者模式（Builder 模式）、代理模式，反射，自定义注解，注解的反射，xml 解析，数据库元数据，元数据的反射等。 4.1.2 分析流程 4.2 前期准备4.2.1 创建 Maven 工程创建 MyBatis04_Design 的工程，工程信息如下： 1234&lt;groupId&gt;com.wgy&lt;/groupId&gt;&lt;artifactId&gt;MyBatis04_Design&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 4.2.2 引入相关坐标12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- mysql 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 解析 xml 的 dom4j --&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dom4j 的依赖包 jaxen --&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.2.3 引入 工具类到项目中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/** * 用于解析配置文件 * * @author wgy */public class XMLConfigBuilder &#123; /** * 解析主配置文件，把里面的内容填充到DefaultSqlSession所需要的地方 * 使用的技术： * dom4j+xpath */ public static Configuration loadConfiguration(InputStream config) &#123; try &#123; //定义封装连接信息的配置对象（mybatis的配置对象） Configuration cfg = new Configuration(); //1.获取SAXReader对象 SAXReader reader = new SAXReader(); //2.根据字节输入流获取Document对象 Document document = reader.read(config); //3.获取根节点 Element root = document.getRootElement(); //4.使用xpath中选择指定节点的方式，获取所有property节点 List&lt;Element&gt; propertyElements = root.selectNodes(\"//property\"); //5.遍历节点 for (Element propertyElement : propertyElements) &#123; //判断节点是连接数据库的哪部分信息 //取出name属性的值 String name = propertyElement.attributeValue(\"name\"); if (\"driver\".equals(name)) &#123; //表示驱动 //获取property标签value属性的值 String driver = propertyElement.attributeValue(\"value\"); cfg.setDriver(driver); &#125; if (\"url\".equals(name)) &#123; //表示连接字符串 //获取property标签value属性的值 String url = propertyElement.attributeValue(\"value\"); cfg.setUrl(url); &#125; if (\"username\".equals(name)) &#123; //表示用户名 //获取property标签value属性的值 String username = propertyElement.attributeValue(\"value\"); cfg.setUsername(username); &#125; if (\"password\".equals(name)) &#123; //表示密码 //获取property标签value属性的值 String password = propertyElement.attributeValue(\"value\"); cfg.setPassword(password); &#125; &#125; //取出mappers中的所有mapper标签，判断他们使用了resource还是class属性 List&lt;Element&gt; mapperElements = root.selectNodes(\"//mappers/mapper\"); //遍历集合 for (Element mapperElement : mapperElements) &#123; //判断mapperElement使用的是哪个属性 Attribute attribute = mapperElement.attribute(\"resource\"); if (attribute != null) &#123; System.out.println(\"使用的是XML\"); //表示有resource属性，用的是XML //取出属性的值 //获取属性的值\"com/wgy/dao/IUserDao.xml\" String mapperPath = attribute.getValue(); //把映射配置文件的内容获取出来，封装成一个map Map&lt;String, Mapper&gt; mappers = loadMapperConfiguration(mapperPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125; else &#123; System.out.println(\"使用的是注解\"); //表示没有resource属性，用的是注解 //获取class属性的值 String daoClassPath = mapperElement.attributeValue(\"class\"); //根据daoClassPath获取封装的必要信息 Map&lt;String, Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125; &#125; //返回Configuration return cfg; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; config.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据传入的参数，解析XML，并且封装到Map中 * * @param mapperPath 映射配置文件的位置 * @return map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成） * 以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名） */ private static Map&lt;String, Mapper&gt; loadMapperConfiguration(String mapperPath) throws IOException &#123; InputStream in = null; try &#123; //定义返回值对象 Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); //2.根据字节输入流获取Document对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); //3.获取根节点 Element root = document.getRootElement(); //4.获取根节点的namespace属性取值 //是组成map中key的部分 String namespace = root.attributeValue(\"namespace\"); //5.获取所有的select节点 List&lt;Element&gt; selectElements = root.selectNodes(\"//select\"); //6.遍历select节点集合 for (Element selectElement : selectElements) &#123; //取出id属性的值 组成map中key的部分 String id = selectElement.attributeValue(\"id\"); //取出resultType属性的值 组成map中value的部分 String resultType = selectElement.attributeValue(\"resultType\"); //取出文本内容 组成map中value的部分 String queryString = selectElement.getText(); //创建Key String key = namespace + \".\" + id; //创建Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); //把key和value存入mappers中 mappers.put(key, mapper); &#125; return mappers; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; in.close(); &#125; &#125; /** * 根据传入的参数，得到dao中所有被select注解标注的方法。 * 根据方法名称和类名，以及方法上注解value属性的值，组成Mapper的必要信息 * * @param daoClassPath * @return */ private static Map&lt;String, Mapper&gt; loadMapperAnnotation(String daoClassPath) throws Exception &#123; //定义返回值对象 Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到dao接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到dao接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历Method数组 for (Method method : methods) &#123; //取出每一个方法，判断是否有select注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if (isAnnotated) &#123; //创建Mapper对象 Mapper mapper = new Mapper(); //取出注解的value属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 //List&lt;User&gt; Type type = method.getGenericReturnType(); //判断type是不是参数化的类型 if (type instanceof ParameterizedType) &#123; //强转 ParameterizedType ptype = (ParameterizedType) type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class) types[0]; //获取domainClass的类名 String resultType = domainClass.getName(); //给Mapper赋值 mapper.setResultType(resultType); &#125; //组装key的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className + \".\" + methodName; //给map赋值 mappers.put(key, mapper); &#125; &#125; return mappers; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 责执行SQL语句，并且封装结果集 * * @author wgy */public class Executor &#123; public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) &#123; PreparedStatement pstm = null; ResultSet rs = null; try &#123; //1.取出mapper中的数据 //select * from user String queryString = mapper.getQueryString(); //com.wgy.domain.User String resultType = mapper.getResultType(); Class domainClass = Class.forName(resultType); //2.获取PreparedStatement对象 pstm = conn.prepareStatement(queryString); //3.执行SQL语句，获取结果集 rs = pstm.executeQuery(); //4.封装结果集 //定义返回值 List&lt;E&gt; list = new ArrayList&lt;E&gt;(); while (rs.next()) &#123; //实例化要封装的实体类对象 E obj = (E) domainClass.newInstance(); //取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); //取出总列数 int columnCount = rsmd.getColumnCount(); //遍历总列数 for (int i = 1; i &lt;= columnCount; i++) &#123; //获取每列的名称，列名的序号是从1开始的 String columnName = rsmd.getColumnName(i); //根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); //给obj赋值：使用Java内省机制（借助PropertyDescriptor实现属性的封装） //要求：实体类的属性和数据库表的列名保持一种 PropertyDescriptor pd = new PropertyDescriptor(columnName, domainClass); //获取它的写入方法 Method writeMethod = pd.getWriteMethod(); //把获取的列的值，给对象赋值 writeMethod.invoke(obj, columnValue); &#125; //把赋好值的对象加入到集合中 list.add(obj); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; release(pstm, rs); &#125; &#125; private void release(PreparedStatement pstm, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (pstm != null) &#123; try &#123; pstm.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122/** * 用于创建数据源的工具类 * * @author wgy */public class DataSourceUtil &#123; /** * 用于获取一个连接 * * @param cfg * @return */ public static Connection getConnection(Configuration cfg) &#123; try &#123; Class.forName(cfg.getDriver()); return DriverManager.getConnection(cfg.getUrl(), cfg.getUsername(), cfg.getPassword()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 4.2.4 编写 SqlMapConfig.xml12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/wgy/dao/IUserDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意：此处我们直接使用的是 mybatis 的配置文件，但是由于我们没有使用 mybatis 的 jar 包，所以要把配置文件的约束删掉否则会报错（如果电脑能接入互联网，不删也行） 4.2.5 编写读取配置文件类1234567891011121314151617/** * 使用类加载器读取配置文件的类 * * @author wgy */public class Resources &#123; /** * 根据传入的参数，获取一个字节输入流 * * @param filePath * @return */ public static InputStream getResourceAsStream(String filePath) &#123; return Resources.class.getClassLoader().getResourceAsStream(filePath); &#125;&#125; 4.2.6 编写 Mapper 类12345678910111213141516171819202122232425262728/** * 用于封装执行的SQL语句和结果类型的全限定类名 * * @author wgy */public class Mapper &#123; //SQL private String queryString; //实体类的全限定类名 private String resultType; public String getQueryString() &#123; return queryString; &#125; public void setQueryString(String queryString) &#123; this.queryString = queryString; &#125; public String getResultType() &#123; return resultType; &#125; public void setResultType(String resultType) &#123; this.resultType = resultType; &#125;&#125; 4.2.7 编写 Configuration 配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 自定义mybatis的配置类 * * @author wgy */public class Configuration &#123; private String driver; private String url; private String username; private String password; private Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); public String getDriver() &#123; return driver; &#125; public void setDriver(String driver) &#123; this.driver = driver; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Map&lt;String, Mapper&gt; getMappers() &#123; return mappers; &#125; public void setMappers(Map&lt;String, Mapper&gt; mappers) &#123; //此处需要使用追加的方式 this.mappers.putAll(mappers); &#125;&#125; 4.2.8 编写 User 实体类1234567891011121314/** * 用户实体类 * * @author wgy */public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; ...&#125; 4.3 基于 XML 的自定义 mybatis 框架4.3.1 编写持久层接口和 IUserDao.xml1234567891011121314/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ List&lt;User&gt; findAll();&#125; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;mapper namespace=\"com.wgy.dao.IUserDao\"&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultType=\"com.wgy.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 注意：此处我们使用的也是 mybatis 的配置文件，所以也要把约束删除了 4.3.2 编写构建者类123456789101112131415161718/** * 用于创建一个SqlSessionFactory对象 * * @author wgy */public class SqlSessionFactoryBuilder &#123; /** * 根据参数的字节输入流来构建一个SqlSessionFactory工厂 * * @param config * @return */ public SqlSessionFactory build(InputStream config) &#123; Configuration cfg = XMLConfigBuilder.loadConfiguration(config); return new DefaultSqlSessionFactory(cfg); &#125;&#125; 4.3.3 编写 SqlSessionFactory 接口和实现类123456789101112/** * @author wgy */public interface SqlSessionFactory &#123; /** * 用于打开一个新的SqlSession对象 * * @return */ SqlSession openSession();&#125; 12345678910111213141516171819202122/** * SqlSessionFactory接口的实现类 * * @author wgy */public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; private Configuration cfg; public DefaultSqlSessionFactory(Configuration cfg) &#123; this.cfg = cfg; &#125; /** * 用于创建一个新的操作数据库对象 * * @return */ public SqlSession openSession() &#123; return new DefaultSqlSession(cfg); &#125;&#125; 4.3.4 编写 SqlSession 接口和实现类12345678910111213141516171819202122/** * 自定义Mybatis中和数据库交互的核心类 * 它里面可以创建dao接口的代理对象 * * @author wgy */public interface SqlSession &#123; /** * 根据参数创建一个代理对象 * * @param daoInterfaceClass dao的接口字节码 * @param &lt;T&gt; * @return */ &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterfaceClass); /** * 释放资源 */ void close();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * SqlSession接口的实现类 * * @author wgy */public class DefaultSqlSession implements SqlSession &#123; private Configuration cfg; private Connection connection; public DefaultSqlSession(Configuration cfg) &#123; this.cfg = cfg; connection = DataSourceUtil.getConnection(cfg); &#125; /** * 用于创建代理对象 * * @param daoInterfaceClass dao的接口字节码 * @param &lt;T&gt; * @return */ public &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterfaceClass) &#123; return (T) Proxy.newProxyInstance(daoInterfaceClass.getClassLoader(), new Class[]&#123;daoInterfaceClass&#125;, new MapperProxy(cfg.getMappers(), connection)); &#125; /** * 用于释放资源 */ public void close() &#123; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4.3.5 编写用于创建 Dao 接口代理对象的类123456789101112131415161718192021222324252627282930313233343536373839404142/** * 代理实现类 * * @author wgy */public class MapperProxy implements InvocationHandler &#123; //map的key是全限定类名+方法名 private Map&lt;String, Mapper&gt; mappers; private Connection conn; public MapperProxy(Map&lt;String, Mapper&gt; mappers, Connection conn) &#123; this.mappers = mappers; this.conn = conn; &#125; /** * 用于对方法进行增强的，我们的增强其实就是调用selectList方法 * * @param proxy * @param method * @param args * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //1.获取方法名 String methodName = method.getName(); //2.获取方法所在类的名称 String className = method.getDeclaringClass().getName(); //3.组合key String key = className + \".\" + methodName; //4.获取mappers中的Mapper对象 Mapper mapper = mappers.get(key); //5.判断是否有mapper if (mapper == null) &#123; throw new IllegalArgumentException(\"传入的参数有误\"); &#125; //6.调用工具类执行查询所有 return new Executor().selectList(mapper, conn); &#125;&#125; 4.3.6 运行测试类1234567891011121314151617181920212223242526272829303132/** * mybatis的入门案例 * * @author wgy */public class MyBatisTest &#123; /** * 入门案例 * * @param args */ public static void main(String[] args) throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 4.4 基于注解方式定义 Mybatis 框架4.4.1 自定义@Select 注解12345678910111213141516/** * 查询的注解 * * @author wgy */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Select &#123; /** * 配置SQL语句的 * * @return */ String value();&#125; 4.4.2 修改持久层接口123456789101112131415/** * 用户持久层接口 * * @author wgy */public interface IUserDao &#123; /** * 查询所有操作 * * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 4.4.3 修改 SqlMapConfig.xml1234&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;&lt;mappers&gt; &lt;mapper class=\"com.wgy.dao.IUserDao\"/&gt;&lt;/mappers&gt;","tags":[{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://wgy1993.gitee.io/tags/MyBatis/"}]},{"title":"Maven(三)","date":"2020-06-18T16:03:44.000Z","path":"archives/898b4292.html","text":"1. maven 私服1.1 需求正式开发，不同的项目组开发不同的工程。 ssm_dao 工程开发完毕，发布到私服。 ssm_service 从私服下载 dao 1.2 分析公司在自己的局域网内搭建自己的远程仓库服务器，称为私服，私服服务器即是公司内部的 maven 远程仓库，每个员工的电脑上安装 maven 软件并且连接私服服务器，员工将自己开发的项目打成 jar 并发布到私服服务器，其它项目组从私服服务器下载所依赖的构件（jar）。 私服还充当一个代理服务器，当私服上没有 jar 包会从互联网中央仓库自动下载，如下图： 1.3 搭建私服环境1.3.1 下载 nexusNexus 是 Maven 仓库管理器，通过 nexus 可以搭建 maven 仓库，同时 nexus 还提供强 大的仓库管理功能，构件搜索功能等。 下载 Nexus， 下载地址：https://www.sonatype.com/download-oss-sonatype 1.3.2 安装 nexus解压 nexus-2.12.0-01-bundle.zip，本教程将它解压在 F 盘，进入 bin 目录： cmd进入 bin目录，执行 nexus.bat install 安装成功在服务中查看有 nexus 服务： 1.3.3 卸载 nexuscmd 进入 nexus 的 bin 目录，执行：nexus.bat uninstall 查看 window 服务列表 nexus 已被删除。 1.3.4 启动 nexus方法 1：cmd 进入 bin 目录，执行 nexus.bat start 方法 2：直接启动 nexus 服务 1.3.4.1 查看 nexus 的配置文件conf/nexus.properties 12345678# Jetty sectionapplication-port=8081 # nexus 的访问端口配置 application-host=0.0.0.0 # nexus 主机监听配置(不用修改) nexus-webapp=$&#123;bundleBasedir&#125;/nexus # nexus 工程目录 nexus-webapp-context-path=/nexus # nexus 的 web 访问路径# Nexus sectionnexus-work=$&#123;bundleBasedir&#125;/../sonatype-work/nexus # nexus 仓库目录runtime=$&#123;bundleBasedir&#125;/nexus/WEB-INF # nexus 运行程序目录 1.3.4.2 访问http://localhost:8081/nexus/ 1.3.4.3 使用 Nexus 内置账户登陆点击右上角的 Log in，输入账号和密码登陆 admin/admin123 登陆成功： 1.3.5 仓库类型1.3.5.1 查看 nexus 的仓库 1.3.5.2 nexus 的仓库有 4 种类型 1、hosted，宿主仓库，部署自己的 jar 到这个类型的仓库，包括 releases 和 snapshot 两部 分，Releases 公司内部发布版本仓库、 Snapshots 公司内部测试版本仓库 2、proxy，代理仓库，用于代理远程的公共仓库，如 maven 中央仓库，用户连接私服，私服自动去中央仓库下载 jar 包或者插件。 3、group，仓库组，用来合并多个 hosted/proxy 仓库，通常我们配置自己的 maven 连接仓库组。 4、virtual(虚拟)：兼容 Maven1 版本的 jar 或者插件 1.3.5.3 nexus 仓库目录默认在 sonatype-work 目录中： central：代理仓库，代理中央仓库 apache-snapshots：代理仓库，存储 snapshots 构件，代理地址 https://repository.apache.org/snapshots/ central-m1：virtual 类型仓库，兼容 Maven1 版本的 jar 或者插件 releases：本地仓库，存储 releases 构件。 snapshots：本地仓库，存储snapshots 构件。 thirdparty：第三方仓库 public：仓库组 1.4 将项目发布到私服1.4.1 需求企业中多个团队协作开发通常会将一些公用的组件、开发模块等发布到私服供其它团队 或模块开发人员使用。 本例子假设多团队分别开发 ssm_dao、ssm_service、ssm_web，某个团队开发完在 ssm_dao 会将 ssm_dao 发布到私服供 ssm_service 团队使用，本例子会将 ssm_dao 工程打成 jar 包发布到私服。 1.4.2 配置1.4.2.1 修改 settings.xml文件需要在客户端即部署 ssm_dao 工程的电脑上配置 maven 环境，并修改 settings.xml文件，配置连接私服的用户和密码 。 此用户名和密码用于私服校验，因为私服需要知道上传的账号和密码是否和私服中的账号和 密码一致。 12345678910111213141516&lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;!-- releases 连接发布版本项目仓库 snapshots 连接测试版本项目仓库--&gt; 1.4.2.2 配置项目 pom.xml配置私服仓库的地址，本公司的自己的 jar 包会上传到私服的宿主仓库，根据工程的版本号决定上传到哪个宿主仓库，如果版本为 release 则上传到私服的 release 仓库，如果版本为 snapshot 则上传到私服的 snapshot 仓库 12345678910&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 注意：pom.xml 这里&lt;id&gt; 和 settings.xml 配置 &lt;id&gt; 对应！ 1.4.3 测试将项目 dao 工程打成 jar 包发布到私服： 1、首先启动 nexus 2、对 ssm_dao 工程执行 deploy 命令 根据本项目pom.xml中version定义决定发布到哪个仓库，如果 version定义为 snapshot， 执行 deploy 后查看 nexus 的 snapshot 仓库，如果 version 定义为 release 则项目将发布到 nexus 的 release 仓库。 1.5 从私服下载 jar 包1.5.1 需求没有配置 nexus 之前，如果本地仓库没有，去中央仓库下载，通常在企业中会在局域网 内部署一台私服服务器，有了私服本地项目首先去本地仓库找 jar，如果没有找到则连接私 服从私服下载 jar 包，如果私服没有 jar 包私服同时作为代理服务器从中央仓库下载 jar 包， 这样做的好处是一方面由私服对公司项目的依赖 jar 包统一管理，一方面提高下载速度，项 目连接私服下载 jar 包的速度要比项目连接中央仓库的速度快的多。 本例子测试从私服下载 ssm_dao 工程 jar 包。 1.5.2 管理仓库组nexus中包括很多仓库，hosted 中存放的是企业自己发布的jar包及第三方公司的 jar包， proxy 中存放的是中央仓库的 jar，为了方便从私服下载 jar 包可以将多个仓库组成一个仓库 组，每个工程需要连接私服的仓库组下载 jar 包。 打开 nexus 配置仓库组，如下图： 上图中仓库组包括了本地仓库、代理仓库等。 1.5.3 在 settings.xml 中配置仓库在客户端的 settings.xml 中配置私服的仓库，由于 settings.xml 中没有 repositories 的配置标签需要使用 profile 定义仓库。 1234567891011121314151617181920212223242526272829&lt;profile&gt; &lt;!--profile 的 id--&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库 id，repositories 可以配置多个仓库，保证 id 不重复--&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址，即 nexus 仓库组的地址--&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;!--是否下载 releases 构件--&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!--是否下载 snapshots 构件--&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven 的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;!-- 插件仓库的 id 不允许重复，如果重复后边配置会覆盖前边 --&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/profile&gt; 使用 profile 定义仓库需要激活才可生效。 123&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 2. 把第三方 jar 包放入本地仓库或私服2.1 导入本地库随便找一个 jar 包测试，可以先 CMD 进入到 jar 包所在位置，运行 1mvn install:install-file -DgroupId&#x3D;com.alibaba -DartifactId&#x3D;fastjson -Dversion&#x3D;1.1.37 -Dfile&#x3D;fastjson-1.1.37.jar -Dpackaging&#x3D;jar 2.2 导入私服需要在 maven 软件的核心配置文件 settings.xml 中配置第三方仓库的 server 信息 12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; CMD执行命令 1mvn deploy:deploy-file -DgroupId&#x3D;com.alibaba -DartifactId&#x3D;fastjson -Dversion&#x3D;1.1.37 -Dpackaging&#x3D;jar -Dfile&#x3D;fastjson-1.1.37.jar -Durl&#x3D;http:&#x2F;&#x2F;localhost:8081&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;thirdparty&#x2F; -DrepositoryId&#x3D;thirdparty 2.3 参数说明 DgroupId 和 DartifactId 构成了该 jar 包在 pom.xml 的坐标，项目就是依靠这两个属性定位。 自己起名字也行。 Dfile 表示需要上传的 jar 包的绝对路径。 Durl 私服上仓库的位置，打开 nexus——&gt;repositories 菜单，可以看到该路径。 DrepositoryId 服务器的表示 id，在 nexus 的 configuration 可以看到。 Dversion 表示版本信息。 关于 jar 包准确的版本： 包的名字上一般会带版本号，如果没有那可以解压该包，会发现一个叫 MANIFEST.MF 的文件，这个文件就有描述该包的版本信息。","tags":[{"name":"Maven","slug":"Maven","permalink":"https://wgy1993.gitee.io/tags/Maven/"},{"name":"项目管理","slug":"项目管理","permalink":"https://wgy1993.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"Maven(二)","date":"2020-06-18T14:07:00.000Z","path":"archives/f77862b9.html","text":"1. maven 构建 SSM 工程1.1 需求实现 SSM 工程构建，规范依赖管理。场景：根据 id 展示商品信息 1.2 准备数据库1234567891011121314151617181920212223SET FOREIGN_KEY_CHECKS&#x3D;0;-- ------------------------------ Table structure for &#96;items&#96;-- ----------------------------DROP TABLE IF EXISTS &#96;items&#96;;CREATE TABLE &#96;items&#96; ( &#96;id&#96; int(10) NOT NULL auto_increment, &#96;name&#96; varchar(20) default NULL, &#96;price&#96; float(10,0) default NULL, &#96;pic&#96; varchar(40) default NULL, &#96;createtime&#96; datetime default NULL, &#96;detail&#96; varchar(200) default NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;9 DEFAULT CHARSET&#x3D;utf8;-- ------------------------------ Records of items-- ----------------------------INSERT INTO &#96;items&#96; VALUES (&#39;1&#39;, &#39;插入测试1&#39;, &#39;1000&#39;, null, &#39;2018-03-13 09:29:30&#39;, &#39;插入测试&#39;);INSERT INTO &#96;items&#96; VALUES (&#39;2&#39;, &#39;插入测试2&#39;, null, null, &#39;2018-03-28 10:05:52&#39;, &#39;插入测试&#39;);INSERT INTO &#96;items&#96; VALUES (&#39;3&#39;, &#39;插入测试3&#39;, &#39;199&#39;, null, &#39;2018-03-07 10:08:04&#39;, &#39;插入测试&#39;);INSERT INTO &#96;items&#96; VALUES (&#39;4&#39;, &#39;插入测试4&#39;, null, null, null, null);INSERT INTO &#96;items&#96; VALUES (&#39;5&#39;, &#39;插入测试5&#39;, null, null, null, null); 1.3 创建一个 maven 工程1.3.1 新建 ssm_maven 项目,使用下图选中的骨架 1.3.2 填写坐标 1.3.3 查看是否使用的自己的私服 1.3.4 在 main 目录下新建 java 和 resources 文件夹把 java 和 resources 文件夹转成 Sources Root和Resources Root 1.3.5 修改编译版本，在 pom.xml 文件中添加123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;!-- 设置编译版本为1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1.4 知识点准备1.4.1 什么是依赖传递先添加 springmvc 的核心依赖的坐标 12345678&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 会发现出现除了 spring-webmvc 以外的其他 jar。因为我们的项目依赖 spring-webmv.jar，而 spring-webmv.jar 会依赖 spring-beans.jar 等等，所以 spring-beans.jar 这些 jar 包也出现在了我 们的 maven 工程中，这种现象我们称为依赖传递。从下图中可看到他们的关系：（请注意 spring-beans 的版本） 1.4.2 依赖冲突的解决接着添加一个依赖 1234567891011121314&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 我们会发现这两个 jar 包同时都依赖了 spring-beans spring-webmvc 依赖 spirng-beans-4.2.4，spring-context 依赖 spring-beans-5.0.2，但是发现 spirng-beans-4.2.4 加入到工程中。而我们希望 spring-beans-5.0.2 加入工程。这就造成了依赖冲突。 1.4.2.1 依赖调解原则maven 自动按照下边的原则调解： 第一声明者优先原则： 在 pom 文件定义依赖，先声明的依赖为准。 测试： 如果将上边 spring-webmvc 和 spring-context 顺序颠倒，系统将导入 spring-beans-5.0.2。 分析：由于 spring-webmvc 在前边以 spring-webmvc 依赖的 spring-beans-5.0.2 为准，所以最终spring-beans-5.0.2 添加到了工程中。 路径近者优先原则： 例如：还是上述情况，spring-contex 和 spring-webmvc 都会传递过来 spirng-beans，那 如果直接把 spring-beans 的依赖直接写到 pom 文件中，那么项目就不会再使用其他依赖传 递来的 spring-beans，因为自己直接在 pom 中定义 spring-beans 要比其他依赖传递过来的路径要近。在本工程中的 pom 中加入 spirng-beans-5.0.2 的依赖，根据路径近者优先原则，系统将导入spirng-beans-5.0.2： 12345678910111213141516171819&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1.4.2.2 排除依赖上边的问题也可以通过排除依赖方法辅助依赖调解，如下： 比如在依赖 spring-webmvc 的设置中添加排除依赖，排除 spring-beans， 下边的配置表示：依赖 spring-webmvc，但排除 spring-webmvc 所依赖的 spring-beans。 1234567891011121314151617181920&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1.4.2.3 锁定版本面对众多的依赖，有一种方法不用考虑依赖路径、声明优化等因素可以采用直接锁定版 本的方法确定依赖构件的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本的为准添加到工程中，此方法在企业开发中常用。 如下的配置是锁定了 spring-beans 和 spring-context 的版本： 123456789101112131415&lt;!-- 锁定jar包版本 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 还可以把版本号提取出来，使用&lt;properties&gt;标签设置成变量。 1234567891011121314151617181920&lt;!-- 统一管理jar包版本 --&gt;&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;!-- 锁定jar包版本 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 注意：在工程中锁定依赖的版本并不代表在工程中添加了依赖，如果工程需要添加锁定版本的依赖则需要单独添加&lt;dependencies&gt;&lt;/dependencies&gt;标签，如下： 123456789101112&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 上边添加的依赖并没有指定版本，原因是已在&lt;dependencyManagement&gt;中锁定了版本， 所以在&lt;dependency&gt;下不需要再指定版本。 1.5 定义 pom.xmlmaven 工程首先要识别依赖，web 工程实现 SSM 整合，需要依赖 spring-webmvc5.0.2、 spring5.0.2、mybatis3.4.5 等，在 pom.xml 添加工程如下依赖： （在实际企业开发中会有架构师专门来编写 pom.xml） 分两步： 锁定依赖版本 添加依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222&lt;!-- 统一管理jar包版本 --&gt;&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;!-- 锁定jar包版本 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;!-- 添加tomcat7插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 设置编译版本为1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1.6 Dao 层在 src/main/java 中定义 dao 接口，实现根据 id 查询商品信息： 1.6.1 pojo 模型类在 src/main/java 创建模型类 123456789101112131415/** * 实体类 * * @author wgy */public class Items implements Serializable &#123; private Integer id; private String name; private Double price; private String pic; private Date createtime; private String detail; ...&#125; 1.6.2 dao 层代码123456789101112131415/** * 持久接口 * * @author wgy */public interface ItemsDao &#123; /** * 根据id查询 * * @param id * @return */ public Items findById(Integer id);&#125; 1.6.3 配置文件1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wgy.dao.ItemsDao\"&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"items\"&gt; select * from items where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 注意配置文件位置（resources下创建目录/com/wgy/dao）： 在 src/main/resources 配置 log4j.properties 12345678### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5 p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change 'info' to 'debug' ####在开发阶段日志级别使用 debuglog4j.rootLogger=debug, stdout 在 src/main/resources 创建 applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--dao层配置文件开始--&gt; &lt;!--配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///maven\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--配置生产SqlSession对象的工厂--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--扫描pojo包，给包下所有pojo对象起别名--&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.wgy.domain\"/&gt; &lt;/bean&gt; &lt;!--扫描接口包路径，生成包下所有接口的代理对象，并且放入spring容器中--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.wgy.dao\"/&gt; &lt;/bean&gt; &lt;!--dao层配置文件结束--&gt;&lt;/beans&gt; 1.6.4 单元测试在 src/test/java 创建单元测试类 12345678910111213141516171819/** * 测试 * * @author wgy */public class ItemsTest &#123; @Test public void findById() &#123; //获取spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //dao测试 //从容器中拿到所需的dao的代理对象 ItemsDao itemsDao = ac.getBean(ItemsDao.class); //调用方法 Items items = itemsDao.findById(1); System.out.println(items.getName()); &#125;&#125; 1.7 Service 层1.7.1 代码123456789101112131415/** * 业务层接口 * * @author wgy */public interface ItemsService &#123; /** * 根据id查询 * * @param id * @return */ public Items findById(Integer id);&#125; 123456789101112131415/** * 持久层实现类 * * @author wgy */@Servicepublic class ItemsServiceImpl implements ItemsService &#123; @Autowired private ItemsDao itemsDao; public Items findById(Integer id) &#123; return itemsDao.findById(id); &#125;&#125; 1.7.2 配置文件在 applicationContext.xml 中配置 service 123456789101112131415161718192021222324252627&lt;!--service层配置文件开始--&gt;&lt;!--组件扫描配置--&gt;&lt;context:component-scan base-package=\"com.wgy.service\"/&gt;&lt;!--aop面向切面编程，切面就是切入点和通知的组合--&gt;&lt;!--配置事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--配置事务的通知--&gt;&lt;tx:advice id=\"advice\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt; &lt;tx:method name=\"*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置切面--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"advice\" pointcut-ref=\"pointcut\"/&gt;&lt;/aop:config&gt;&lt;!--service层配置文件结束--&gt; 1.7.3 单元测试123456789101112131415161718/** * 测试 * * @author wgy */public class ItemsTest &#123; @Test public void findById() &#123; //获取spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //service测试 ItemsService itemsService = ac.getBean(ItemsService.class); //调用方法 Items items = itemsService.findById(1); System.out.println(items.getName()); &#125;&#125; 1.8 Web 层1.8.1 代码12345678910111213141516171819/** * 控制器 * * @author wgy */@Controller@RequestMapping(\"/items\")public class ItemsController &#123; @Autowired private ItemsService itemsService; @RequestMapping(\"/findDetail\") public String findDetail(Model model) &#123; Items items = itemsService.findById(1); model.addAttribute(\"item\", items); return \"itemDetail\"; &#125;&#125; 1.8.2 配置文件在 src/main/resources 创建 springmvc.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=\"com.wgy.controller\"/&gt; &lt;!--处理器映射器，处理器适配器--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--释放静态资源--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; 配置web.xml，加载 spring 容器，配置 springmvc 前端控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;!--编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置spring核心监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--重新指定spring配置文件的路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--springmvc的核心servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 1.9 Jsp/WEB-INF/pages/itemDetail.jsp 12345678910111213141516171819202122232425262728293031323334&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;table width=\"100%\" border=1&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt; $&#123;item.name &#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt; $&#123;item.price &#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;生成日期&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=\"$&#123;item.createtime&#125;\" pattern=\"yyyy-MM-dd HH:mm:ss\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品简介&lt;/td&gt; &lt;td&gt;$&#123;item.detail&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1.10 运行与调试添加 tomcat7 插件，双击右侧 tomcat7 运行 运行结果如下： 2. 分模块构建工程基于上边的三个工程分析 继承：创建一个 parent 工程将所需的依赖都配置在 pom 中 聚合：聚合多个模块运行。 2.1 需求2.1.1 需求描述将 SSM 工程拆分为多个模块开发： ssm_dao、ssm_service、ssm_web 2.1.2 理解继承和聚合通常继承和聚合同时使用 何为继承？ 继承是为了消除重复，如果将 dao、service、web 分开创建独立的工程则每个工程的 pom.xml 文件中的内容存在重复，比如：设置编译版本、锁定 spring 的版本的等，可以将这些重复的配置提取出来在父工程的 pom.xml 中定义。 何为聚合？ 项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在 一起运行，比如：dao、service、web 三个工程最终会打一个独立的 war 运行。 2.2 案例实现2.2.1 maven-parent 父模块2.2.1.1 创建父工程工程只有pom.xml文件 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;artifactId&gt;maven05_parent&lt;/artifactId&gt; &lt;!-- 设置项目的打包方式 --&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 2.2.1.2 定义 pom.xml在父工程的 pom.xml 中抽取一些重复的配置的， 比如： 锁定 jar 包的版本、 设置编译版本等。 具体配置同上1.5 2.2.2 ssm_dao 子模块2.2.2.1 创建 dao 子模块在父工程上右击创建 maven 模块 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;maven05_parent&lt;/artifactId&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven05_dao&lt;/artifactId&gt;&lt;/project&gt; 2.2.2.2 dao 代码将 ssm_maven 工程中的 dao接口、映射文件及 pojo 类拷贝到 src/main/java 中： 2.2.2.3 配置文件将 applicationContext.xml拆分出一个applicationContext-dao.xml，此文件中只配置 dao 相关内容 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--dao层配置文件开始--&gt; &lt;!--配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///maven\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--配置生产SqlSession对象的工厂--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--扫描pojo包，给包下所有pojo对象起别名--&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.wgy.domain\"/&gt; &lt;/bean&gt; &lt;!--扫描接口包路径，生成包下所有接口的代理对象，并且放入spring容器中--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.wgy.dao\"/&gt; &lt;/bean&gt; &lt;!--dao层配置文件结束--&gt;&lt;/beans&gt; 2.2.3 ssm_service 子模块2.2.3.1 创建 service 子模块方法同 ssm_dao 模块创建方法。ssm_service 依赖 ssm_dao 模块 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;maven05_parent&lt;/artifactId&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven05_service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;artifactId&gt;maven05_dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.2.3.2 service 代码将 ssm_maven 工程中的service接口、实现类拷贝到 src/main/java中： 2.2.3.3 配置文件将 applicationContext.xml拆分出一个applicationContext-service.xml，此文件中只配置 service相关内容 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--service层配置文件开始--&gt; &lt;!--组件扫描配置--&gt; &lt;context:component-scan base-package=\"com.wgy.service\"/&gt; &lt;!--aop面向切面编程，切面就是切入点和通知的组合--&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!--配置事务的通知--&gt; &lt;tx:advice id=\"advice\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt; &lt;tx:method name=\"*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"advice\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; &lt;!--service层配置文件结束--&gt;&lt;/beans&gt; 2.2.4 ssm_web 子模块2.2.4.1 创建 web 子模块 ssm_web 依赖 ssm_service 模块 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;maven05_parent&lt;/artifactId&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven05_web&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wgy&lt;/groupId&gt; &lt;artifactId&gt;maven05_service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.2.4.2 controller 代码将 ssm_web 工程中的controller 代码拷贝到src/main/java 中： 2.2.4.3 配置文件拷贝 ssm_web 工程中配置文件 将 applicationContext.xml引入server、dao配置： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"classpath:spring/applicationContext-dao.xml\"/&gt; &lt;import resource=\"classpath:spring/applicationContext-service.xml\"/&gt;&lt;/beans&gt; 2.2.5 运行调试 方法 1：在 ssm_web 工程的 pom.xml 中配置 tomcat 插件运行 运行 ssm_web 工程它会从本地仓库下载依赖的 jar 包，所以当 ssm_web 依赖的 jar 包内容修改了必须及时发布到本地仓库，比如：ssm_web 依赖的 ssm_service 修改了，需要及时将ssm_service 发布到本地仓库。 方法 2：在父工程的 pom.xml 中配置 tomcat 插件运行，自动聚合并执行 推荐方法 2，如果子工程都在本地，采用方法 2 则不需要子工程修改就立即发布到本地仓库， 父工程会自动聚合并使用最新代码执行。 注意：如果子工程和父工程中都配置了 tomcat 插件，运行的端口和路径以子工程为准。","tags":[{"name":"Maven","slug":"Maven","permalink":"https://wgy1993.gitee.io/tags/Maven/"},{"name":"项目管理","slug":"项目管理","permalink":"https://wgy1993.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"Maven(一)","date":"2020-06-17T08:21:58.000Z","path":"archives/5849f9db.html","text":"1. Maven 介绍1.1 什么是 Maven1.1.1 什么是 MavenMaven 是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)， 和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 1.1.2 Maven能解决什么问题用更通俗的方式来说明，项目开发不仅仅是写写代码而已，期间会伴随着各种必不可少的事情要做，下面列举几个感受一下： 我们需要引用各种 jar包，尤其是比较大的工程，引用的 jar 包往往有几十个乃至上百个， 每用到一种 jar包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的jar 包冲突，版本冲突。 我们辛辛苦苦写好了 Java文件，可是只懂 0 和 1 的白痴电脑却完全读不懂，需要将它编译成二进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA 等都可以将代码即时编译。当然，如果你嫌生命漫长，何不铺张，也可以用记事本来敲代码，然后用 javac 命令一个个地去编译，逗电脑玩。 世界上没有不存在 bug的代码，为了减少 bug，因此写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。 再优雅的代码也是要出来卖的。我们后面还需要把代码与各种配置文件、资源整合到一起，定型打包，如果是 web项目，还需要将之发布到服务器，供人蹂躏。 试想，如果现在有一种工具，可以把你从上面的繁琐工作中解放出来，能帮你构建工程，管理 jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站点，你会心动吗？Maven 就可以解决上面所提到的这些问题。 1.1.3 Maven 的优势举例我们通过 Web 阶段项目，要能够将项目运行起来，就必须将该项目所依赖的一些 jar 包添加到工程中，否则项目就不能运行。试想如果具有相同架构的项目有十个，那么我们就需要将这一份 jar包复制到十个不同的工程中。我们一起来看一个CRM项目的工程大小。 使用传统 Web 项目构建的 CRM 项目如下： 原因主要是因为上面的 WEB 程序要运行，我们必须将项目运行所需的 Jar 包复制到工程目录中，从而导致了工程很大。 同样的项目，如果我们使用Maven 工程来构建，会发现总体上工程的大小会少很多。如下图: 小结：可以初步推断它里面一定没有 jar 包，继续思考，没有 jar 包的项目怎么可能运行呢？ 1.2 Maven的两个精典作用1.2.1 Maven的依赖管理Maven的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成一项困难的任务。Maven展示出了它对处理这种情形的高度控制。 传统的WEB项目中，我们必须将工程所依赖的jar包复制到工程中，导致了工程的变得很大。那么maven工程是如何使得工程变得很少呢？ 分析如下： 通过分析发现：maven工程中不直接将jar包导入到工程中，而是通过在pom.xml文件中添加所需jar包的坐标，这样就很好的避免了jar直接引入进来，在需要用到jar包的时候，只要查找pom.xml文件，再通过pom.xml文件中的坐标，到一个专门用于”存放jar包的仓库”(maven仓库)中根据坐标从而找到这些jar包，再把这些jar包拿去运行。 那么问题来了第一：”存放jar包的仓库”长什么样？第二：通过读取pom.xml 文件中的坐标，再到仓库中找到jar包，会不会很慢？从而导致这种方式不可行！ 第一个问题：存放jar包的仓库长什么样，这一点我们后期会分析仓库的分类，也会带大家去看我们的本地的仓库长什么样。第二个问题：通过pom.xml文件配置要引入的jar包的坐标，再读取坐标并到仓库中加载jar包，这样我们就可以直接使用jar包了，为了解决这个过程中速度慢的问题，maven中也有索引的概念，通过建立索引，可以大大提高加载jar包的速度，使得我们认为jar包基本跟放在本地的工程文件中再读取出来的速度是一样的。这个过程就好比我们查阅字典时，为了能够加快查找到内容，书前面的目录就好比是索引，有了这个目录我们就可以方便找到内容了，一样的在maven仓库中有了索引我们就可以认为可以快速找到jar包。 1.2.2 项目的一键构建我们的项目，往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。 什么是构建：指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给maven进行管理，这个过程称为构建。 一键构建：指的是整个构建过程，使用maven一个命令可以轻松完成整个工作。 Maven规范化构建流程如下： 2. Maven 的使用2.1 Maven的安装2.1.1 Maven软件的下载为了使用Maven管理工具，我们首先要到官网去下载它的安装软件。通过百度搜索“Maven“如下： 点击 Download 链接，就可以直接进入到 Maven 软件的下载页面： 2.1.2 Maven软件的安装Maven下载后，将Maven解压到一个没有中文没有空格的路径下，比如D:\\software\\maven下面。解压后目录结构如下： bin:存放了maven的命令，比如我们前面用到的mvn tomcat:runboot:存放了一些maven本身的引导程序，如类加载器等conf:存放了maven的一些配置文件，如setting.xml文件lib:存放了maven本身运行所需的一些jar包 至此我们的maven软件就可以使用了，前提是你的电脑上之前已经安装并配置好了JDK。 2.1.3 JDK的准备JDK 使用 JDK8版本 2.1.4 Maven及JDK配置配置 MAVEN_HOME （bin目录之前一级目录）： 配置JAVA_HOME： 添加%MAVEN_HOME%/bin;%JAVA_HOME%/bin;到patch中。 2.1.5 Maven软件版本测试通过 mvn -v命令检查 maven是否安装成功，看到maven的版本为3.5.2及java版本为1. 8 即为安装成功。 找开cmd命令，输入mvn –v命令，如下图： 2.2 Maven仓库2.2.1 Maven仓库的分类maven的工作需要从仓库下载一些jar包，如下图所示，本地的项目A、项目B等都会通过maven软件从远程仓库（可以理解为互联网上的仓库）下载jar包并存在本地仓库，本地仓库就是本地文件夹，当第二次需要此jar包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。 下图描述了maven中仓库的类型： 本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找。默认本地仓库位置在 ${user.dir}/.m2/repository，${user.dir}表示windows 用户目录 远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。 中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件。 2.2.2 Maven本地仓库的配置在MAVE_HOME/conf/settings.xml文件中配置本地仓库位置（maven的安装目录下）： 打开settings.xml文件，配置如下： 2.2.3 全局setting与用户settingmaven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。 在maven安装目录下的有 conf/setting.xml文件，此setting.xml文件用于maven的所有project项目，它作为maven的全局配置。 如需要个性配置则需要在用户配置中设置，用户配置的setting.xml文件默认的位置在：${user.dir}/.m2/settings.xml目录中,${user.dir} 指windows 中的用户目录。 maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。 2.3 Maven工程的认识2.3.1 Maven工程的目录结构 作为一个maven工程，它的src目录和pom.xml是必备的。 进入src目录后，我们发现它里面的目录结构如下： src/main/java —— 存放项目的.java文件src/main/resources —— 存放项目资源文件，如spring, hibernate配置文件src/test/java —— 存放所有单元测试.java文件，如JUnit测试类src/test/resources —— 测试资源文件target —— 项目输出位置，编译后的class文件会输出到此目录pom.xml——maven项目核心配置文件 注意：如果是普通的java项目，那么就没有webapp目录。 2.3.2 Maven工程的运行进入maven工程目录（当前目录有pom.xml文件），运行tomcat:run命令。 根据上边的提示信息，通过浏览器访问：http://localhost:8080/maven-helloworld/ 3. Maven常用命令我们可以在cmd中通过一系列的maven命令来对我们的maven-helloworld工程进行编译、测试、运行、打包、安装、部署。 3.1 compilecompile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。 cmd进入命令状态，执行mvn compile，如下图提示成功： 查看 target目录，class文件已生成，编译完成。 3.2 testtest是maven工程的测试命令 mvn test，会执行src/test/java下的单元测试类。 cmd执行mvn test执行src/test/java下单元测试类，下图为测试结果，运行 1 个测试用例，全部成功。 3.3 cleanclean是maven工程的清理命令，执行 clean会删除target目录及内容。 3.4 packagepackage是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。 3.5 installinstall是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。 3.6 Maven指令的生命周期maven对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是： Clean Lifecycle ：在进行真正的构建之前进行一些清理工作。Default Lifecycle ：构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle ：生成项目报告，站点，发布站点。 3.7 maven的概念模型Maven包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 项目对象模型 (Project Object Model) 一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。 12345678910&lt;project&gt; ：文件的根节点 .&lt;modelversion&gt; ： pom.xml 使用的对象模型版本&lt;groupId&gt; ：项目名称，一般写项目的域名&lt;artifactId&gt; ：模块名称，子项目名或模块名称&lt;version&gt; ：产品的版本号 .&lt;packaging&gt; ：打包类型，一般有 jar、war、pom 等&lt;name&gt; ：项目的显示名，常用于 Maven 生成的文档。&lt;description&gt; ：项目描述，常用于 Maven 生成的文档&lt;dependencies&gt; ：项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt; ：项目构建配置，配置编译、运行插件等。 依赖管理系统(Dependency Management System) 通过maven的依赖管理对项目所依赖的jar 包进行统一管理。 比如：项目依赖junit4.9，通过在pom.xml中定义junit4.9的依赖即使用junit4.9，如下所示是junit4.9的依赖定义： 1234567891011121314&lt;!-- 依赖关系 --&gt;&lt;dependencies&gt; &lt;!-- 此项目运行使用 junit，所以此项目依赖 junit --&gt; &lt;dependency&gt; &lt;!-- junit 的项目名称 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!-- junit 的模块名称 --&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!-- junit 版本 --&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;!-- 依赖范围：单元测试时使用 junit --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 一个项目生命周期(Project Lifecycle) 使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven将这些过程规范为一个生命周期，如下所示是生命周期的各各阶段： maven通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行mvn compile执行编译、执行mvn clean执行清理。 一组标准集合 maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。 插件(plugin)目标(goal) maven 管理项目生命周期过程都是基于插件完成的。 4. idea开发maven项目在实战的环境中，我们都会使用流行的工具来开发项目。 4.1 idea的maven配置依据图片指示，选择本地maven安装目录，指定maven安装目录下conf文件夹中settings配置文件。 4.2 idea中创建maven的web工程打开idea，选择创建一个新工程 选择idea提供好的maven的web工程模板 点击Next填写项目信息 点击Next，此处不做改动。 点击Next选择项目所在目录 点击Finish后开始创建工程，耐心等待，直到出现如下界面。 手动添加src/main/java目录，如下图右键main文件夹&gt;New&gt;Directory 创建一个新的文件夹命名为java 点击OK后，在新的文件夹java上右键&gt;Make Directory as&gt;Sources Root 4.2.1 创建一个Servletsrc/java/main创建了一个Servlet，但报错 要解决问题，就是要将servlet-api-xxx.jar包放进来，作为maven工程应当添加servlet的坐标，从而导入它的jar 4.2.2 在pom.xml文件添加坐标直接打开hello_maven工程的pom.xml文件，再添加坐标 添加jar包的坐标时，还可以指定这个jar包将来的作用范围。 每个maven工程都需要定义本工程的坐标，坐标是maven对jar包的身份定义，比如：入门程序的坐标定义如下： 12345678910&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&lt;groupId&gt;com.wgy&lt;&#x2F;groupId&gt;&lt;!-- 模块名称 --&gt;&lt;artifactId&gt;hello_maven&lt;&#x2F;artifactId&gt;&lt;!-- 当前项目版本号，snapshot 为快照版本即非正式版本，release为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;&lt;packaging&gt; ：打包类型 jar：执行 package 会打成 jar 包 war：执行 package 会打成 war 包 pom ：用于 maven 工程的继承，通常父工程设置为 pom 4.2.3 坐标的来源方式添加依赖需要指定依赖jar包的坐标，但是很多情况我们是不知道jar包的的坐标，可以通过如下方式查询： http://search.maven.org/http://mvnrepository.com/ 4.3 依赖范围A依赖B，需要在A的pom.xml文件中添加B的坐标，添加坐标时需要指定依赖范围，依赖范围包括： compile：编译范围，指A在编译时依赖B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。 provided：provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用， provided依赖在编译和测试时需要，在运行时不需要，比如：servlet api被tomcat容器提供。 runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以runtime范围的依赖会被打包。 test：test范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以test范围依赖不会被打包。 system：system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径，需要指定systemPath磁盘路径，system依赖不推荐使用。 在maven-web工程中测试各各scop。 测试总结： 默认引入 的jar包 ——- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ） servlet-api 、jsp-api ——- provided （编译、测试 有效， 运行时无效，防止和tomcat下jar冲突） jdbc驱动jar包 —- runtime （测试、运行 有效 ） junit —– test （测试有效） 依赖范围由强到弱的顺序是：compile&gt;provided&gt;runtime&gt;test 4.4 项目中添加的坐标1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.5 设置jdk编译版本本教程使用jdk1. 8 ，需要设置编译版本为1. 8 ，这里需要使用maven的插件来设置，在pom.xml中加入： 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 4.6 编写servlet在src/main/java中创建ServletTest 123456789101112public class MyServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher(\"/hello.jsp\").forward(request, response); &#125;&#125; 4.7 编写jsp123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; hello maven&lt;/body&gt;&lt;/html&gt; 4.8 在web.xml中配置servlet访问路径12345678&lt;servlet&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wgy.servlet.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4.9 添加tomcat7插件在pom文件中添加如下内容 12345678&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;/configuration&gt;&lt;/plugin&gt; 此时点击idea最右侧Maven Projects，就可以看到我们新添加的tomcat7插件双击tomcat7插件下tomcat7:run命令直接运行项目 也可以直接点击如图按钮，手动输入tomc7:run命令运行项目 5. maven工程运行调试5.1 端口占用处理重新执行tomcat:run命令重启工程，重启之前需手动停止 tomcat，否则报下边的错误： 5.2 断点调试点击如图所示选项 在弹出框中点击如图加号按钮找到maven选项 在弹出窗口中填写如下信息 完成后先Apply再OK结束配置后，可以在主界面找到我们刚才配置的操作名称。 如上图红框选中的两个按钮，左侧是正常启动，右侧是debug启动。","tags":[{"name":"Maven","slug":"Maven","permalink":"https://wgy1993.gitee.io/tags/Maven/"},{"name":"项目管理","slug":"项目管理","permalink":"https://wgy1993.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"SSH","date":"2020-06-16T05:58:26.000Z","path":"archives/782a8ece.html","text":"1. SSH三大框架整合1.1 整合说明 独立式整合指的是三个框架都使用自己的配置文件。 引入式整合指的是hibernate主配置文件中的内容都配置到spring配置文件中 在整合过程中，确保每步都运行成功，然后在继续往下做。 整合中使用的案例是客户的保存和列表查询操作。 后面的三种整合方式都基于1.2中的环境准备。 1.2 环境准备1.2.1 创建java web工程1.2.2 创建数据库和表结构1234567891011121314create database ssh;use ssh;&#x2F;*创建客户表*&#x2F;CREATE TABLE &#96;cst_customer&#96; ( &#96;cust_id&#96; bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#39;客户编号(主键)&#39;, &#96;cust_name&#96; varchar(32) NOT NULL COMMENT &#39;客户名称(公司名称)&#39;, &#96;cust_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户信息来源&#39;, &#96;cust_industry&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户所属行业&#39;, &#96;cust_level&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户级别&#39;, &#96;cust_address&#96; varchar(128) DEFAULT NULL COMMENT &#39;客户联系地址&#39;, &#96;cust_phone&#96; varchar(64) DEFAULT NULL COMMENT &#39;客户联系电话&#39;, PRIMARY KEY (&#96;cust_id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8; 1.2.3 编写实体类1234567891011121314/** * 客户的实体类（数据模型） */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; ...&#125; 1.2.4 编写业务层接口和实现类12345678910111213141516/** * 客户的业务层接口 */public interface ICustomerService &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer(); /** * @param customer */ void saveCustomer(Customer customer);&#125; 123456789101112131415161718192021/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao; public void setCustomerDao(ICustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125; @Override public void saveCustomer(Customer customer) &#123; customerDao.saveCustomer(customer); &#125;&#125; 1.2.5 编写持久层接口和实现类1234567891011121314151617/** * 客户的持久层接口 */public interface ICustomerDao &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer(); /** * 保存客户 * @param customer */ void saveCustomer(Customer customer);&#125; 12345678910111213141516/** * 客户的持久层实现类 */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; System.out.println(\"查询了所有用户\"); return null; &#125; @Override public void saveCustomer(Customer customer) &#123; System.out.println(\"保存了用户\"); &#125;&#125; 2. 基于XML的独立式整合2.1 保证spring框架在web工程中独立运行2.1.1 拷贝spring的ioc,aop和事务控制三组jar包ioc: aop: 事务控制: 2.1.2 编写spring配置文件并导入约束123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 2.1.3 把业务层和持久层配置到文件中123456789&lt;!-- 把资源交给spring来管理 --&gt;&lt;!-- 配置dao --&gt;&lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt;&lt;/bean&gt; &lt;!-- 配置service --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;!-- 注入dao --&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.1.4 测试spring能否独立运行12345678910111213/** * 测试类，测试spring框架可以独立运行 */public class SpringTest &#123; public static void main(String[] args) &#123; //1.获取spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.跟Id获取bean对象 ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); cs.findAllCustomer(); &#125;&#125; 2.2 保证hibernate框架能够在web工程中独立运行2.2.1 拷贝hibernate必备jar包hibernate基本jar包: c3p0: 2.2.2 编写实体类的映射文件1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping package=\"com.wgy.domain\"&gt; &lt;class name=\"Customer\" table=\"cst_customer\"&gt; &lt;id name=\"custId\" column=\"cust_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"custName\" column=\"cust_name\"/&gt; &lt;property name=\"custSource\" column=\"cust_source\"/&gt; &lt;property name=\"custIndustry\" column=\"cust_industry\"/&gt; &lt;property name=\"custLevel\" column=\"cust_level\"/&gt; &lt;property name=\"custAddress\" column=\"cust_address\"/&gt; &lt;property name=\"custPhone\" column=\"cust_phone\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 2.2.3 编写hibernate主配置文件12345678910111213141516171819202122232425262728293031&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory--&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/ssh&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name=\"hibernate.format_sql\"&gt;false&lt;/property&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name=\"hibernate.connection.provider_class\"&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;/property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping resource=\"com/wgy/domain/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 2.2.4 编写测试类-测试保存客户123456789101112131415161718192021222324252627/** * 保证hibernate框架能够独立在web工程中运行 * * @author wgy */public class HibernateTest &#123; public static void main(String[] args) &#123; Customer c = new Customer(); c.setCustName(\"ssh整合Customer\"); //1.加载配置文件 Configuration cfg = new Configuration(); cfg.configure(); //2.根据配置文件创建SessionFactory SessionFactory factory = cfg.buildSessionFactory(); //3.获取session Session session = factory.getCurrentSession(); //4.开启事务 Transaction tx = session.beginTransaction(); //5.执行操作 session.save(c); //6.提交/回滚事务 tx.commit(); //7.释放资源 factory.close(); &#125;&#125; 2.3 整合spring和hibernate框架2.3.1 明确 Spring和Hibernate的整合就是spring接管SessionFactory的创建 Spring针对Hiberante的操作有一个封装的对象HibernateTemplate 和JdbcTemplate一样，HibernateTemplate也有一个HibernateDaoSupport HibernateTemplate和HibernateDaoSupport都在spring-orm-4.2.4.RELEASE.jar中 我们Dao采用继承HiberanteDaoSupport的方式编写，它一样不能用于注解配置。 2.3.2 整合步骤2.3.2.1 在spring配置文件中配置SessionFactory12345678&lt;!-- 配置sessionFactory：让spring接管sessionFactory的创建 用spring提供的一个SessionFactory：LocalSessionFactoryBean 创建SessionFactory有三部分必不可少的信息。三部分信息在hibernate主配置文件中都有 把hibernate主配置文件的位置注入进来--&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\"/&gt;&lt;/bean&gt; 2.3.2.2 改造Dao继承HibernateDaoSupport123456789101112131415/** * 客户的持久层实现类 */public class CustomerDaoImpl extends HibernateDaoSupport implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return (List&lt;Customer&gt;) getHibernateTemplate().find(\"from Customer\"); &#125; @Override public void saveCustomer(Customer customer) &#123; getHibernateTemplate().save(customer); &#125;&#125; 2.3.2.3 在spring配置文件中给Dao注入SessionFactory1234&lt;!-- 配置dao --&gt;&lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.3.2.4 测试12345678910111213141516171819202122232425262728293031/** * 整合spring和hibernate的测试类 * spring整合Junit * 第一步：拷贝jar包 * spring-junit-4.2.4.jar * 第二步：使用注解替换运行器（原来junit的main方法） * @RunWith(支持spring的main方法) * @ContextConfiguration(指定spring的配置文件位置) */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:bean.xml\"&#125;)public class SpringHibernateTest &#123; @Autowired private ICustomerService cs; @Test public void testSave() &#123; Customer c = new Customer(); c.setCustName(\"spring hibernate customer123\"); cs.saveCustomer(c); &#125; @Test public void testFindAll() &#123; List list = cs.findAllCustomer(); for (Object o : list) &#123; System.out.println(o); &#125; &#125;&#125; 12345测试结果： 无论保存还是查询都运行失败！ 按常理来说，我们没有配置事务，保存失败是可以理解的。为什么查询也会失败呢？分析原因： 是由于spring的HibernateTemplate对象在使用Session时，spring创建了Session的代理对象，在这个过程中，spring对hibernate绑定Session到当前线程的配置不认识了，所以运行失败。 2.3.2.5 修改把Session绑定到当前线程上123456789&lt;!-- 是hibernate把session绑定到当前线程上的配置 &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt;--&gt;&lt;!-- 是spring把sesion绑定到当前线程上的配置 --&gt;&lt;property name=\"hibernate.current_session_context_class\"&gt; org.springframework.orm.hibernate5.SpringSessionContext&lt;/property&gt;此时再运行刚才的测试： 查询可以使用了。保存不能使用，原因是没有事务。 2.3.3 配置Spring的事务2.3.3.1 配置事务管理器并注入SessionFactory1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 2.3.3.2 配置事务的通知及通知的属性1234567&lt;!-- 配置事务的通知 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 2.3.3.3 配置AOP建立切入点表达式和事务通知的关系12345678910&lt;!-- 配置aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;!-- 建立切入点表达式和事务通知的关联 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt;&lt;/aop:config&gt;再次测试： 此时保存和查询都可以正常使用了。 2.4 保证struts2框架能够在web工程中独立运行2.4.1 拷贝struts2的必备jar包 2.4.2 编写struts.xml文件并导入约束123456789&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;struts&gt; 2.4.3 在web.xml中配置struts2的核心过滤器123456789&lt;!-- 配置struts2和核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.4.4 导入jsp页面 2.4.5 修改menu.jsp123&lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/addUICustomer.action\" target=main&gt;－ 新增客户&lt;/A&gt;&lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/findAllCustomer.action\" target=main&gt;－ 客户列表&lt;/A&gt; 2.4.6 在struts.xml中配置action12345678910&lt;!-- 配置动作 --&gt;&lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;action name&#x3D;&quot;addUICustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;addUICustomer&quot;&gt; &lt;result name&#x3D;&quot;addUICustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 2.4.7 编写动作类和方法12345678910111213141516171819202122232425262728/** * 客户的动作类*/public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); @Override public Customer getModel() &#123; return customer; &#125; /** * 获取添加客户页面 * @return */ public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 查询所有客户 * @return */ public String findAllCustomer() &#123; //调用业务层查询客户列表 &#125;&#125; 2.4.8 测试1运行结果：通过点击【新增客户】可以跳转到客户添加页面 2.5 整合spring和struts22.5.1 明确 spring整合struts2就是让spring接管action的创建 action是多例的，配置到spring中需要设置scope属性为多例 2.5.2 整合步骤2.5.2.1 拷贝spring整合struts的jar包 2.5.2.2 在action中使用构造函数获取Service对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 客户的动作类 */public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); private List&lt;Customer&gt; customers; private ICustomerService customerService; @Override public Customer getModel() &#123; return customer; &#125; public void setCustomerService(ICustomerService customerService) &#123; this.customerService = customerService; &#125;//此种方式根本不能用，因为由于动作类是多例的，每次都会创建新的容器，导致容器中的bean也会创建新的。// public CustomerAction()&#123;// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");// System.out.println(ac);// ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\");// this.setCustomerService(cs);// &#125;//此种方式解决了容器多例的问题，保证了容器一个应用只有一个，但是我们的代码边臃肿了，每个action都需要这么写一下。 public CustomerAction()&#123; ServletContext application = ServletActionContext.getServletContext(); ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(application); System.out.println(ac); ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); this.setCustomerService(cs); &#125; /** * 获取添加客户页面 * * @return */ public String addUICustomer() &#123; return \"addUICustomer\"; &#125; /** * 查询所有客户 * @return */ public String findAllCustomer() &#123; //调用业务层查询客户列表 customers = customerService.findAllCustomer(); return \"findAllCustomer\"; &#125; public List&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers; &#125;&#125; 2.5.2.3 测试1运行结果：查询客户列表测试通过。 2.6 优化配置2.6.1 配置spring的监听器12345678910111213141516171819在上面2.5.2.2小节中有这么一句： 由于动作类是多例的，每次都会创建容器，导致资源的浪费。一个应用应该只有一个容器问题： 如何解决呢？答案： 只要让容器在应用加载时创建，应用卸载时销毁就可以。问题： 我们怎么知道应用何时加载了呢？答案： ServletContext对象创建了，就表示当前应用已经被服务器加载了。问题： 我们怎么知道ServletContext对象创建了呢？答案： ServletContextListener监听器可以监听到ServletContext对象的创建和销毁。Spring框架为我们提供了一个监听器：ContextLoaderListener。它是ServletContextListener接口的实现类，负责监听ServletContext对象的创建，为我们创建容器，监听ServletContext对象的销毁，销毁容器。我们只需要配置上即可。ContextLoaderListener在spring-web-4.2.4.RELEASE.jar中 在web.xml中配置监听器： 123456789&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;当配置了此监听器后，就不需要使用Action的构造函数了，可以把构造函数那段删除了。此监听器只能读取WEB-INF目录中的名称为applicationContext.xml的配置文件。这显然限制了我们的配置。我们可以通过配置全局初始化参数的方式，指定spring配置文件的位置. 2.6.2 配置指定spring配置文件的位置12345&lt;!-- 手动指定spring的配置文件位置，需要使用ServletContext的初始化参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 2.6.3 分文件编写spring配置我们写到这里，其实搭建环境已经基本结束了，但是发现spring的配置文件杂乱无章，使我们在找配置的时候，很难一下找到。所以我们采用分配置文件编写的方式。 2.6.3.1 编写主配置文件引入其他配置文件1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 引入其他spring配置文件 --&gt; &lt;import resource=\"applicationContext-customer.xml\"/&gt; &lt;import resource=\"applicationContext-jdbc.xml\"/&gt; &lt;import resource=\"applicationContext-tx.xml\"/&gt;&lt;/beans&gt; 2.6.3.2 编写针对需求的配置文件applicationContext-customer.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"/&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.6.3.3 编写数据库连接的配置文件applicationContext-jdbc.xml123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置SessionFactory --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 使用的是hibernate主配置文件中的内容，我们只需要指定hibernate配置文件的位置 --&gt; &lt;property name=\"configLocation\" value=\"classpath:config/hibernate/hibernate.cfg.xml\"&gt;/&gt; &lt;/bean&gt;&lt;/beans&gt; 2.6.3.4 编写事务控制的配置文件applicationContext-tx.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 和事务相关的配置 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务的通知 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 配置事务的属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置aop --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.wgy.service.impl.*.*(..))\"/&gt; &lt;!-- 建立切入点表达式和事务通知的关联 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.6.4 配置指定struts2配置文件位置我们的spring和hibernate配置文件都存到了src/config/的对应包中了，只有struts2配置文件还在类的根路径下，它也可以通过配置的方式指定struts.xml的位置。配置的是过滤器的初始化参数。初始化参数的name和value都是固定写法。 1234567891011121314&lt;!-- 配置struts2和核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;!-- 手动指定struts2配置文件的位置：此处的配置绝大多数都是固定的--&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;struts-default.xml,struts-plugin.xml,config/struts/struts.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.6.5 分文件编写struts2配置文件当我们后面做的模块越来越多，struts2一个配置文件写起来也会杂乱无章，所以我们也可以把struts2的配置文件分开编写。 2.6.5.1 编写struts2的主配置文件struts.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name=\"struts.devMode\" value=\"true\"/&gt; &lt;!-- 配置公共包，有公共的配置就写在此处--&gt; &lt;package name=\"myDefault\" extends=\"struts-default\" abstract=\"true\"&gt; &lt;/package&gt; &lt;!-- 引入其他struts2配置文件 --&gt; &lt;include file=\"config/struts/struts-customer.xml\"&gt;&lt;/include&gt;&lt;/struts&gt; 2.6.5.2 针对不同模块编写不同的配置文件struts-customer.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 配置和客户管理相关的动作 --&gt; &lt;package name=\"customer\" extends=\"myDefault\" namespace=\"/customer\"&gt; &lt;action name=\"addUICustomer\" class=\"com.wgy.web.action.CustomerAction\" method=\"addUICustomer\"&gt; &lt;result name=\"addUICustomer\"&gt;/jsp/customer/add.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"findAllCustomer\" class=\"com.wgy.web.action.CustomerAction\" method=\"findAllCustomer\"&gt; &lt;result name=\"findAllCustomer\"&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 2.6.6 管理Action的两种方式2.6.6.1 让struts2自己来管理此种方式就是在action标签的class属性中提供动作类的全限定类名。 123&lt;action name=\"addUICustomer\" class=\"com.wgy.web.action.CustomerAction\" method=\"addUICustomer\"&gt; &lt;result name=\"addUICustomer\"&gt;/jsp/customer/add.jsp&lt;/result&gt;&lt;/action&gt; 2.6.6.2 让spring来管理（实际开发中采用的方式）此种方式就是在spring配置文件中配置Action，在struts2配置文件action标签的class属性里写bean的id。 spring配置文件： 1234&lt;!-- 配置action --&gt;&lt;bean id=\"customerAction\" class=\"com.wgy.web.action.CustomerAction\" scope=\"prototype\"&gt; &lt;property name=\"customerService\" ref=\"customerService\"&gt;&lt;/property&gt;&lt;/bean&gt; struts2配置文件： 123&lt;action name&#x3D;&quot;addUICustomer&quot; class&#x3D;&quot;customerAction&quot; method&#x3D;&quot;addUICustomer&quot;&gt; &lt;result name&#x3D;&quot;addUICustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3. 基于XML的引入式整合3.1 明确引入式整合就是把hibernate.cfg.xml中的配置都挪到spring的配置文件中 3.2 配置方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 和jdbc配置相关的 --&gt;&lt;!-- 配置sessionFactory --&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 第一部分：连接数据库的 用连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;!-- 数据库的方言 --&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;prop key=\"hibernate.format_sql\"&gt;false&lt;/prop&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;prop key=\"hibernate.current_session_context_class\"&gt; org.springframework.orm.hibernate5.SpringSessionContext &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 第三部分：映射文件的位置 mappingResources：它是一个注入string数组类型的数据。提供的是映射文件的位置。有几个映射文件，就需要写几个。 mappingDirectoryLocations：它是注入一个Resource类型的数组。提供的是映射文件所在的目录。此属性一般多用于一个项目有多个地方存放映射配置。 //服务端 server_domain //移动端 mobile_domain mappingLocations：它是注入一个Resource类型的数组。提供的映射文件的位置。它可以使用通配符。 --&gt; &lt;property name=\"mappingLocations\"&gt; &lt;array&gt; &lt;value&gt;classpath:com/wgy/domain/*.hbm.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/ssh\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt;&lt;/bean&gt; 4. 基于注解的整合4.1 明确 注解整合仍然使用上面的环境，就是把xml的配置全部换成注解 spring的注解整合有两种方式，一种是用xml文件，一种是纯注解。 hibernate注解整合是把实体类映射改为JPA注解映射 4.2 整合步骤-spring使用xml文件4.2.1 spring配置使用注解实现4.2.1.1 在spring配置文件中配置要扫描的包12&lt;!-- 配置spring运行要扫描的包 --&gt;&lt;context:component-scan base-package=\"com.wgy\"/&gt; 4.2.1.2 把action,service和dao都用注解配置12345678910/** * 客户的动作类 */@Controller(\"customerAction\")@Scope(\"prototype\")public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; @Autowired private ICustomerService customerService; //action中的方法不变&#125; 123456789/** * 客户的业务层实现类 */@Service(\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Autowired private ICustomerDao customerDao; //service中的方法不变&#125; 12345678910/** * 客户的持久层实现类 */@Repository(\"customerDao\")public class CustomerDaoImpl implements ICustomerDao &#123; //dao中必须自己定义HibernateTemplate，不能继承HibernateDaoSupport了 @Autowired private HibernateTemplate hibernateTemplate; //dao中的方法不变&#125; 4.2.1.3 在spring配置文件中配置HiernateTemplate1234&lt;!-- 配置hibernateTemplate --&gt;&lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate5.HibernateTemplate\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 4.2.1.4 在spring配置文件中配置事务管理器1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 4.2.1.5 在spring配置文件中开启spring对注解事务的支持12&lt;!-- 开启spring对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 4.2.1.6 在客户的业务层实现类上使用@Transactional注解123456789101112131415161718192021222324/** * 客户的业务层实现类 * * @author wgy */@Service(\"customerService\")@Transactional(readOnly = false, propagation = Propagation.REQUIRED)public class CustomerServiceImpl implements ICustomerService &#123; @Resource(name = \"customerDao\") private ICustomerDao customerDao; @Override @Transactional(readOnly = true, propagation = Propagation.SUPPORTS) public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125; @Override public void saveCustomer(Customer customer) &#123; customerDao.saveCustomer(customer); &#125;&#125; 4.2.2 hibernate映射使用注解配置实现4.2.2.1 实体类映射注解配置1234567891011121314151617181920212223242526272829/** * 客户的实体类 * JPA规范：java 持久化规范 * 注解全都是JPA规范的。 * 导包都需要导入javax.persistence包下的 * */@Entity@Table(name=\"cst_customer\")public class Customer implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"cust_id\") private Long custId; @Column(name=\"cust_name\") private String custName; @Column(name=\"cust_source\") private String custSource; @Column(name=\"cust_industry\") private String custIndustry; @Column(name=\"cust_level\") private String custLevel; @Column(name=\"cust_address\") private String custAddress; @Column(name=\"cust_phone\") private String custPhone; ...&#125; 4.2.2.2 spring中SessionFactory配置修改123456789101112131415161718192021222324252627282930&lt;!-- 配置sessionFactory --&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 第一部分：连接数据库的 用连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;!-- 数据库的方言 --&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;prop key=\"hibernate.format_sql\"&gt;false&lt;/prop&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;prop key=\"hibernate.current_session_context_class\"&gt; org.springframework.orm.hibernate5.SpringSessionContext &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 第三部分：指定实体类所在的包，当创建SessionFactory,会去该包中扫描实体类上的注解，从而生成映射配置--&gt; &lt;property name=\"packagesToScan\"&gt; &lt;array&gt; &lt;value&gt;com.wgy.domain&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 4.2.3 struts2配置使用注解实现4.2.3.1 导入struts2注解的jar包 4.2.3.2 使用注解配置Action1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 客户的动作类 */@Controller(\"customerAction\")@Scope(\"prototype\")//-------以下都是struts2的注解-----------@ParentPackage(\"struts-default\")//指定当前包的父包@Namespace(\"/customer\")//指定名称空间，访问当前action的所有方法都需要有名称空间@Results(&#123; @Result(name = \"addUICustomer\", type = \"dispatcher\", location = \"/jsp/customer/add.jsp\"), @Result(name = \"findAllCustomer\", type = \"dispatcher\", location = \"/jsp/customer/list.jsp\"), @Result(name = \"listCustomer\", type = \"redirectAction\", location = \"findAllCustomer\")&#125;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); private List&lt;Customer&gt; customers; @Resource(name = \"customerService\") private ICustomerService customerService; @Override public Customer getModel() &#123; return customer; &#125; /** * 查询所有客户 * @return */ @Action(\"findAllCustomer\") public String findAllCustomer()&#123; //调用业务层查询客户列表 customers = customerService.findAllCustomer(); return \"findAllCustomer\"; &#125; /** * 获取添加客户页面 * @return */ @Action(\"addUICustomer\") public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 添加客户 * @return */ @Action(\"addCustomer\") public String addCustomer()&#123; customerService.saveCustomer(customer); return \"listCustomer\"; &#125; public List&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers; &#125;&#125; 4.2.3.3 指定struts2开发模式12345678910111213&lt;!-- 配置struts2和核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.devMode&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Spring(四)","date":"2020-06-14T09:18:35.000Z","path":"archives/924a9eab.html","text":"1. Spring中的JdbcTemplate1.1 JdbcTemplate概述它是spring框架中提供的一个对象，是对原始Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类，入下图所示： 我们今天的主角在spring-jdbc-4.24.RELEASE.jar中，我们在导包的时候，除了要导入这个jar包外，还需要导入一个spring-tx-4.2.4.RELEASE.jar（它是和事务相关的）。 1.2 JdbcTemplate对象的创建我们可以参考它的源码，来一探究竟： 12345678910111213public JdbcTemplate() &#123;&#125;public JdbcTemplate(DataSource dataSource) &#123; setDataSource(dataSource); afterPropertiesSet();&#125;public JdbcTemplate(DataSource dataSource, boolean lazyInit) &#123; setDataSource(dataSource); setLazyInit(lazyInit); afterPropertiesSet();&#125; 除了默认构造函数之外，都需要提供一个数据源。既然有set方法，依据我们之前学过的依赖注入，我们可不可以在配置文件中配置呢？ 答案是肯定的。 1.3 Spring中配置数据源1.3.1 环境搭建 1.3.2 编写Spring的配置文件1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; 1.3.3 配置数据源我们之前已经接触过了两个数据源，一个是C3P0，一个是DBCP。要想使用这两数据源都需要导入对应的jar包。 1.3.3.1 配置C3P0数据源导包: 在Spring的配置文件中配置： 123456&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.3.3.2 配置DBCP数据源导包: 在Spring的配置文件中配置： 123456&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.3.3.3 配置spring内置数据源spring框架也提供了一个内置数据源，我们也可以使用spring的内置数据源，它就在spring-jdbc-4.2.4.REEASE.jar包中： 123456&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.3.4 将数据库连接的信息配置到属性文件中:定义属性文件 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc.username=rootjdbc.password=root 引入外部的属性文件 12345678一种方式:&lt;!-- 引入外部属性文件： --&gt;&lt;bean class&#x3D;&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name&#x3D;&quot;location&quot; value&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;二种方式:&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt; 1.4 JdbcTemplate的增删改查操作1.4.1 前期准备12345678910创建数据库：create database spring;use spring;创建表：create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci; 1.4.2 在spring配置文件中配置JdbcTemplate12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.4.3 最基本使用1234567891011public class JdbcTemplateDemo2 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 jt.execute(\"insert into account(name,money)values('eee',500)\"); &#125;&#125; 1.4.4 保存操作123456789101112public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //保存 jt.update(\"insert into account(name,money)values(?,?)\",\"fff\",5000); &#125;&#125; 1.4.5 更新操作123456789101112public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //修改 jt.update(\"update account set money = money-? where id = ?\",300,6); &#125;&#125; 1.4.6 删除操作123456789101112public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //删除 jt.update(\"delete from account where id = ?\",6); &#125;&#125; 1.4.7 查询所有操作1234567891011121314151617181920212223242526public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询所有 List&lt;Account&gt; accounts = jt.query(\"select * from account where money &gt; ? \",new AccountRowMapper(), 500); for(Account o : accounts)&#123; System.out.println(o); &#125; &#125;&#125;public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(\"id\")); account.setName(rs.getString(\"name\")); account.setMoney(rs.getFloat(\"money\")); return account; &#125;&#125; 123456789101112131415public class JdbcTemplateDemo3 &#123; public static void main(String[] args)&#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.跟id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询所有 List&lt;Account&gt; accounts = jt.query(\"select * from account where money &gt; ?\",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),1000); for(Account account : accounts)&#123; System.out.println(account); &#125; &#125;&#125; 1.4.8 查询一个操作1234567891011121314151617181920212223242526272829//使用RowMapper的方式：常用的方式public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询一个 List&lt;Account&gt; as = jt.query(\"select * from account where id = ? \", new AccountRowMapper(), 55); System.out.println(as.isEmpty()?\"没有结果\":as.get(0)); &#125;&#125;//使用ResultSetExtractor的方式:不常用的方式public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询一个 Account account = jt.query(\"select * from account where id = ?\",new AccountResultSetExtractor(),3); System.out.println(account); &#125;&#125; 1.4.9 查询返回一行一列操作1234567891011121314public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取bean对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean(\"jdbcTemplate\"); //3.执行操作 //查询返回一行一列：使用聚合函数，在不使用group by字句时，都是返回一行一列。最长用的就是分页中获取总记录条数 //queryForObject是spring 3.x之后的新方法，在spring2.x的时候，它的方法是多个：queryForInt queryForLong queryForShort Integer total = jt.queryForObject(\"select count(*) from account where money &gt; ? \",Integer.class,500); System.out.println(total); &#125;&#125; 1.5 在dao中使用JdbcTemplate1.5.1 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 1.5.2 第一种方式：在dao中定义JdbcTemplate123456789101112131415161718192021222324252627282930313233343536/** * 账户的持久层实现类 * 此版本的dao，需要给dao注入JdbcTemplate */public class AccountDaoImpl implements IAccountDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ? \",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where name = ? \",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一，不是只有一个账户对象\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set money = ? where id = ? \",account.getMoney(),account.getId()); &#125;&#125; 配置文件： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置一个dao --&gt; &lt;bean id=\"accountDao\" class=\"com.wgy.dao.impl.AccountDaoImpl\"&gt; &lt;!-- 注入jdbcTemplate --&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.5.3 第二种方式：让dao继承JdbcDaoSupportJdbcDaoSupport是spring框架为我们提供的一个类，该类中定义了一个JdbcTemplate对象，我们可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源：具体源码如下： 12345678910111213141516171819202122232425public abstract class JdbcDaoSupport extends DaoSupport &#123; //定义对象 private JdbcTemplate jdbcTemplate; //set方法注入数据源，判断是否注入了，注入了就创建JdbcTemplate public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; //如果提供了数据源就创建JdbcTemplate this.jdbcTemplate = createJdbcTemplate(dataSource); initTemplateConfig(); &#125; &#125; //使用数据源创建JdcbTemplate protected JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; //当然，我们也可以通过注入JdbcTemplate对象 public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; initTemplateConfig(); &#125; //使用getJdbcTmeplate方法获取操作模板对象 public final JdbcTemplate getJdbcTemplate() &#123; return this.jdbcTemplate; &#125;&#125; 1234567891011121314151617181920212223242526272829303132/** * 账户的持久层实现类 * 此版本dao，只需要给它的父类注入一个数据源 */public class AccountDaoImpl2 extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where id = ? \",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where name = ? \",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一，不是只有一个账户对象\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 getJdbcTemplate().update(\"update account set money = ? where id = ? \",account.getMoney(),account.getId()); &#125;&#125; 配置文件： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置dao2 --&gt; &lt;bean id=\"accountDao2\" class=\"com.wgy.dao.impl.AccountDaoImpl2\"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.5.4 两种方式有什么区别呢？ 第一种在Dao类中定义JdbcTemplate的方式，适用于所有配置方式（xml和注解都可以）。 第二种让Dao继承JdbcDaoSupport的方式，只能用于基于XML的方式，注解用不了。 2. Spring中的事务控制2.1 Spring中事务控制的API介绍2.1.1 PlatformTransactionManager此接口是spring的事务管理器，它里面提供了我们常用的操作事务的方法，如下图： 我们在开发中都是使用它的实现类，如下图： 123真正管理事务的对象 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用Spring JDBC或iBatis 进行持久化数据时使用 org.springframework.orm.hibernate3.HibernateTransactionManager 使用Hibernate版本进行持久化数据时使用 2.1.2 TransactionDefinition它是事务的定义信息对象，里面有如下方法： 2.1.2.1 事务的隔离级别 2.1.2.2 事务的传播行为1234567REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起NEVER:以非事务方式运行，如果当前存在事务，抛出异常NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类似的操作。 2.1.2.3 超时时间默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 2.1.2.4 是否是只读事务建议查询时设置为只读 2.1.3 TransactionStatus此接口提供的是事务具体的运行状态，方法介绍如下图： 2.2 基于XML的声明式事务控制（配置方式）2.2.1 环境搭建2.2.1.1 拷贝必要的jar 2.2.1.2 创建spring的配置文件并导入约束123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;/beans&gt; 2.2.1.3 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 2.2.1.4 编写业务层接口和实现类1234567891011121314151617181920/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 根据id查询账户信息 * @param id * @return */ Account findAccountById(Integer id);//查 /** * 转账 * @param sourceName 转出账户名称 * @param targeName 转入账户名称 * @param money 转账金额 */ void transfer(String sourceName,String targeName,Float money);//增删改&#125; 123456789101112131415161718192021222324252627282930/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 2.2.1.5 编写Dao接口和实现类123456789101112131415161718192021222324/** * 账户的持久层接口 */public interface IAccountDao &#123; /** * 根据id查询账户信息 * @param id * @return */ Account findAccountById(Integer id); /** * 根据名称查询账户信息 * @return */ Account findAccountByName(String name); /** * 更新账户信息 * @param account */ void updateAccount(Account account);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 账户的持久层实现类 * 此版本dao，只需要给它的父类注入一个数据源 */public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where id = ? \",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = getJdbcTemplate().query(\"select * from account where name = ? \",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一，不是只有一个账户对象\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; getJdbcTemplate().update(\"update account set money = ? where id = ? \",account.getMoney(),account.getId()); &#125;&#125;/** * 账户的封装类RowMapper的实现类 */public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(\"id\")); account.setName(rs.getString(\"name\")); account.setMoney(rs.getFloat(\"money\")); return account; &#125;&#125; 2.2.1.6 在配置文件中配置业务层和持久层123456789101112131415161718&lt;!-- 配置service --&gt;&lt;bean id=\"accountService\" class=\"com.wgy.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 配置dao --&gt;&lt;bean id=\"accountDao\" class=\"com.wgy.dao.impl.AccountDaoImpl\"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 配置数据源 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.2 配置步骤2.2.2.1 配置事务管理器12345&lt;!-- 配置一个事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入DataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.2.2 配置事务的通知引用事务管理器123&lt;!-- 事务的配置 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt;&lt;/tx:advice&gt; 2.2.2.3 配置事务的属性12345678910111213&lt;!--在tx:advice标签内部 配置事务的属性 --&gt;&lt;tx:attributes&gt; &lt;!-- 指定方法名称：是业务核心方法 read-only：是否是只读事务。默认false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。 --&gt; &lt;tx:method name=\"*\" read-only=\"false\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"SUPPORTS\"/&gt;&lt;/tx:attributes&gt; 2.2.2.4 配置AOP-切入点表达式12345&lt;!-- 配置aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt;&lt;/aop:config&gt; 2.2.2.5 配置切入点表达式和事务通知的对应关系12&lt;!-- 在aop:config标签内部：建立事务的通知和切入点表达式的关系 --&gt;&lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; 2.2.2.6 完整配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"accountService\" class=\"com.wgy.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id=\"accountDao\" class=\"com.wgy.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SPRING内置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring基于XML的声明式事务控制 --&gt; &lt;!-- 第一步：配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第二步：配置事务的通知 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 第四步：配置事务的属性 isolation：配置事务的隔离级别。默认值：DEFAULT，使用数据库的默认隔离级别。mysql是REPEATABLE_READ propagation：配置事务的传播行为。默认值是：REQUIRED。 一般的选择。（增删改方法）。当是查询方法时，选择SUPPORTS timeout：指定事务的超时时间。默认值是：-1，永不超时。当指定其他值时，以秒为单位 read-only：配置是否只读事务。默认值是：false，读写型事务。 当指定为true时，表示只读，只能用于查询方法。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常时，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当执行产生该异常时，事务不回滚。产生其他异常时，事务回滚。没有默认值，任何异常都回滚。 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 第三步：配置aop 要配的是：切入点表达式 通知和切入点表达式的关联 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt; &lt;!-- 配置事务通知和切入点表达式的关联 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.3 基于XML和注解组合使用的整合方式2.3.1 环境搭建2.3.1.1 拷贝必备的jar 2.3.1.2 spring的配置文件导入约束并配置扫描的包1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置spring要扫描的包 --&gt; &lt;context:component-scan base-package=\"com.wgy\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 2.3.1.3 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 2.3.1.4 业务层实现类使用注解让spring管理123456789101112131415161718192021222324252627/** * 账户的业务层实现类 */@Service(\"accountService\")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 2.3.1.5 Dao实现类使用注解让spring管理1234567891011121314151617181920212223242526272829303132@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountId); return list.isEmpty() ? null : list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where name = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (list.isEmpty()) &#123; //没有这个名称的账户 return null; &#125; if (list.size() &gt; 1) &#123; //结果集不唯一，不符合我们的约定 throw new RuntimeException(\"结果集不唯一，请检查数据\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set name=?,money=? where id=?\", account.getName(), account.getMoney(), account.getId()); &#125;&#125; 2.3.2 配置步骤2.3.2.1 配置数据源和JdbcTemplate123456789101112&lt;!-- 配置jdbcTemplate --&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置SPRING内置数据源 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.3.2.2 配置事务管理器并注入数据源1234&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.3.2.3 在业务层使用@Transactional注解1234567&lt;!-- 在需要事务的地方使用@Transactional注解 该注解可以写在接口上，类上和方法上。 写在接口上，表示该接口的所有实现类都有事务。 写在类上，表示该类中所有方法都有事务。 写在方法，表示该方法有事务。 优先级：就近原则。方法&gt;类&gt;接口--&gt; 12345678910111213141516171819202122232425262728@Service(\"accountService\")@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)//只读型public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; @Override @Transactional(propagation=Propagation.REQUIRED,readOnly=false)//读写型 public void transfer(String sourceName, String targetName, Float money) &#123; //1.根据名称查询账户信息 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); //2.转出账户减钱，转入账户加钱 source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); //3.更新账户信息 accountDao.updateAccount(source); int i = 1 / 0; accountDao.updateAccount(target); &#125;&#125; 2.3.2.4 在配置文件中开启spring对注解事务的支持12&lt;!-- 开启spring对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 2.4 基于纯注解的声明式事务控制（配置方式）2.4.1 环境搭建2.4.1.1 拷贝必备的jar包 2.4.1.2 创建一个类用于加载spring的配置并指定要扫描的包12345678/** * 用于初始化spring容器的配置类 */@Configuration@ComponentScan(basePackages=\"com.wgy\")public class SpringConfiguration &#123;&#125; 2.4.1.3 准备实体类12345678910/** * 账户的实体 */public class Account implements Serializable &#123; private Integer id; private String name; private Float money; ...&#125; 2.4.1.4 业务层实现类使用注解让spring管理123456789101112131415161718192021222324252627/** * 账户的业务层实现类 */@Service(\"accountService\")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 2.4.1.5 Dao实现类使用注解让spring管理1234567891011121314151617181920212223242526272829303132@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where id = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountId); return list.isEmpty() ? null : list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account where name = ? \", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (list.isEmpty()) &#123; //没有这个名称的账户 return null; &#125; if (list.size() &gt; 1) &#123; //结果集不唯一，不符合我们的约定 throw new RuntimeException(\"结果集不唯一，请检查数据\"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set name=?,money=? where id=?\", account.getName(), account.getMoney(), account.getId()); &#125;&#125; 2.4.2 配置步骤2.4.2.1 使用@Bean注解配置数据源和JdbcTemplate12345678910111213141516171819202122/** * 连接数据库的配置类 * * @author wgy */public class JdbcConfig &#123; @Bean(name = \"jdbcTemplate\") public JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = \"dataSource\") public DataSource createDataSource() &#123; DriverManagerDataSource ds = new DriverManagerDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; &#125;&#125; 2.4.2.2 使用@Bean注解配置配置事务管理器123456789101112/** * 事务控制的配置类 * * @author wgy */public class TransactionManager &#123; @Bean(name = \"transactionManager\") public PlatformTransactionManager createTransactionManager(DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 2.4.2.3 在业务层使用@Transactional注解1234567&lt;!-- 在需要事务的地方使用@Transactional注解 该注解可以写在接口上，类上和方法上。 写在接口上，表示该接口的所有实现类都有事务。 写在类上，表示该类中所有方法都有事务。 写在方法，表示该方法有事务。 优先级：就近原则。方法&gt;类&gt;接口--&gt; 12345678910111213141516171819202122232425262728@Service(\"accountService\")@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)//只读型public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; @Override @Transactional(propagation=Propagation.REQUIRED,readOnly=false)//读写型 public void transfer(String sourceName, String targetName, Float money) &#123; //1.根据名称查询账户信息 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); //2.转出账户减钱，转入账户加钱 source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); //3.更新账户信息 accountDao.updateAccount(source); int i = 1 / 0; accountDao.updateAccount(target); &#125;&#125; 2.4.2.4 使用@EnableTransactionManagement开启spring对注解事务的的支持123456789101112/** * spring的配置类，作用就是当bean.xml用 * * @author wgy */@Configuration@ComponentScan(\"com.wgy\")@Import(&#123;JdbcConfig.class, TransactionManager.class&#125;)@EnableTransactionManagementpublic class SpringConfiguration &#123;&#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Spring(三)","date":"2020-06-13T10:27:26.000Z","path":"archives/680971a4.html","text":"1. AOP的相关概念1.1 AOP概述1.1.1 什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.1.2 AOP的作用及优势作用： 在程序运行期间，不修改源码对已有方法进行增强。 优势： 减少重复代码 提高开发效率 维护方便 1.1.3 AOP的实现方式使用动态代理技术 1.2 AOP的具体应用1.2.1 案例中问题这是我们之前在struts2课程中做的一个完整的增删改查例子。下面是客户的业务层接口和实现类。 通过下面的代码，我们能看出什么问题吗? 123456789101112131415161718/** * 客户的业务层接口 */public interface ICustomerService &#123; /** * 保存客户 * @param customer */ void saveCustomer(Customer customer); /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 客户的业务层实现类 * 事务必须在此控制 * 业务层都是调用持久层的方法 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public void saveCustomer(Customer customer) &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); customerDao.saveCustomer(customer); tx.commit(); &#125;catch(Exception e)&#123; tx.rollback(); throw new RuntimeException(e); &#125; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); List&lt;Customer&gt; customers = customerDao.findAllCustomer(); tx.commit(); return customers; &#125;catch(Exception e)&#123; tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 上面代码的问题就是：我们的事务控制是重复性的代码。这还只是一个业务类，如果有多个业务了，每个业务类中都会有这些重复性的代码。 1.2.2 动态代理回顾1.2.2.1 动态代理的特点123字节码随用随创建，随用随加载。它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。装饰者模式就是静态代理的一种体现。 1.2.2.2 动态代理常用的有两种方式123456基于接口的动态代理 提供者：JDK官方的Proxy类。 要求：被代理类最少实现一个接口。基于子类的动态代理 提供者：第三方的CGLib，如果报asmxxxx异常，需要导入asm.jar。 要求：被代理类不能用final修饰的类（最终类）。 1.2.2.3 使用JDK官方的Proxy类创建代理对象 此处我们使用的是一个演员的例子： 在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。 而随着时间的推移，产生了一个新兴职业：经纪人（中间人），这个时候剧组再想找演员就需要通过经纪人来找了。下面我们就用代码演示出来。 1234567891011121314151617/** * 一个经纪公司的要求: * 能做基本的表演和危险的表演 */public interface IActor &#123; /** * 基本演出 * @param money */ public void basicAct(float money); /** * 危险演出 * @param money */ public void dangerAct(float money);&#125; 1234567891011121314/** * 一个演员 * 实现了接口，就表示具有接口中的方法实现。即：符合经纪公司的要求 */public class Actor implements IActor&#123; public void basicAct(float money)&#123; System.out.println(\"拿到钱，开始基本的表演：\"+money); &#125; public void dangerAct(float money)&#123; System.out.println(\"拿到钱，开始危险的表演：\"+money); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 模拟一个剧组 * * @author wgy */public class Client &#123; public static void main(String[] args) &#123; //一个剧组找演员 final Actor actor = new Actor(); /** * 动态代理： * 作用：不改变源码的基础上，对已有方法增强。（它是AOP思想的实现技术） * 分类： * 基于接口的动态代理： * 要求：被代理类最少实现一个接口 * 提供者：JDK官方 * 涉及的类：Proxy * 创建代理对象的方法：newProxyInstance(ClassLoader,Class[],InvocationHandler) * 参数的含义： * ClassLoader：类加载器。和被代理对象使用相同的类加载器。一般都是固定写法。 * Class[]：字节码数组。被代理类实现的接口。（要求代理对象和被代理对象具有相同的行为）。一般都是固定写法。 * InvocationHandler：它是一个接口，就是用于我们提供增强代码的。我们一般都是些一个该接口的实现类。实现类可以是匿名内部类。 * 它的含义就是：如何代理。此处的代码只能是谁用谁提供。 * 策略模式： * 使用要求：数据已经有了 * 目的明确 * 达成目标的过程就是策略。 * 在dbutils中的ResultSetHandler就是策略模式的具体应用。 * * 基于子类的动态代理 * */ IActor proxyActor = (IActor) Proxy.newProxyInstance(actor.getClass().getClassLoader(), actor.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 执行被代理对象的任何方法都会经过该方法，该方法有拦截的功能 * 方法的参数 * Object proxy：代理对象的引用。不一定每次都会有。 * Method method：当前执行的方法 * Object[] args：当前执行方法所需的参数 * 返回值： * 当前执行方法的返回值 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object rtValue = null; //1.取出执行方法中的参数：给的多少钱 Float money = (Float)args[0]; //2.判断当前执行的是什么方法：每个经纪公司对不同演出收费不一样，此处开始判断 if(\"basicAct\".equals(method.getName()))&#123; //基本演出，没有10000不演 if(money &gt; 10000)&#123; //执行方法（开始表演） //看上去剧组是给了20000，实际到演员手里只有10000 //这就是我们没有修改原来basicAct方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; if(\"dangerAct\".equals(method.getName()))&#123; //危险演出，没有50000不演 if(money &gt; 50000)&#123; //执行方法 //看上去剧组是给了60000，实际到演员手里只有30000 //这就是我们没有修改原来dangerAct方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;);// 没有经纪公司的时候，直接找演员。// actor.basicAct(1000f);// actor.dangerAct(5000f);// 剧组无法直接联系演员，而是由经纪公司找的演员 proxyActor.basicAct(20000); proxyActor.dangerAct(60000); &#125;&#125; 1.2.2.4 使用CGLib的Enhancer类创建代理对象还是那个演员的例子，只不过不让他实现接口。 12345678910111213141516171819202122232425/** * 一个演员 * * @author wgy */public class Actor &#123; /** * 基本的演出 * * @param money */ public void basicAct(float money) &#123; System.out.println(\"CGLIB拿到钱，开始基本的表演：\" + money); &#125; /** * 危险的表演 * * @param money */ public void dangerAct(float money) &#123; System.out.println(\"CGLIB拿到钱，开始危险的表演：\" + money); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 模拟一个剧组 * * @author wgy */public class Client &#123; public static void main(String[] args) &#123; final Actor actor = new Actor(); /** * 动态代理： * 作用：不改变源码的基础上，对已有方法增强。（它是AOP思想的实现技术） * 分类： * 基于接口的动态代理： * * 基于子类的动态代理： * 要求：被代理类不能是最终类。不能被final修饰 * 提供者：第三方CGLib * 涉及的类：Enhancer * 创建代理对象的方法：create(Class,Callback); * 参数的含义： * Class：被代理对象的字节码 * Callback：如何代理。它和InvocationHandler的作用是一样的。它也是一个接口，我们一般使用该接口的子接口MethodInterceptor * 在使用时我们也是创建该接口的匿名内部类。 * */ Actor cglibActor = (Actor) Enhancer.create(actor.getClass(), new MethodInterceptor() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。它和基于接口动态代理的invoke方法的作用是一模一样的。 * 方法的参数; * 前面三个和invoke方法的参数含义和作用都一样。 * MethodProxy methodProxy：当前执行方法的代理对象。一般不用 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object rtValue = null; //1.取出执行方法中的参数：给的多少钱 Float money = (Float)args[0]; //2.判断当前执行的是什么方法 if(\"basicAct\".equals(method.getName()))&#123; //基本演出 if(money &gt; 10000)&#123; //执行方法（开始表演） rtValue = method.invoke(actor, money/2); &#125; &#125; if(\"dangerAct\".equals(method.getName()))&#123; //危险演出 if(money &gt; 50000)&#123; //执行方法 rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;); cglibActor.basicAct(50000); cglibActor.dangerAct(100000); &#125;&#125; 1.2.3 解决案例中的问题思路只有一个：使用动态代理技术创建客户业务层的代理对象，在执行CustomerServiceImpl时，对里面的方法进行增强，加入事务的支持。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 用于创建客户业务层对象工厂（当然也可以创建其他业务层对象，只不过我们此处不做那么繁琐）*/public class BeanFactory &#123; /** * 获取客户业务层对象的代理对象 * @return */ public static ICustomerService getCustomerService() &#123; //定义客户业务层对象 final ICustomerService customerService = new CustomerServiceImpl(); //生成它的代理对象 ICustomerService proxyCustomerService = (ICustomerService) Proxy.newProxyInstance(customerService.getClass().getClassLoader() ,customerService.getClass().getInterfaces(), new InvocationHandler() &#123; //执行客户业务层任何方法，都会在此处被拦截，我们对那些方法增强，加入事务。 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String name = method.getName(); Object rtValue = null; try&#123; //开启事务 HibernateUtil.beginTransaction(); //执行操作 rtValue = method.invoke(customerService, args); //提交事务 HibernateUtil.commit(); &#125;catch(Exception e)&#123; //回滚事务 HibernateUtil.rollback(); e.printStackTrace(); &#125;finally&#123; //释放资源.hibernate在我们事务操作（提交/回滚）之后，已经帮我们关了。 //如果他没关，我们在此处关 &#125; return rtValue; &#125; &#125;); return proxyCustomerService; &#125;&#125; 1.3 Spring中的AOP1.3.1 关于代理的选择在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.3.2 AOP相关术语123456789101112131415161718Joinpoint(连接点): 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。Pointcut(切入点): 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。Advice(通知&#x2F;增强): 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。Introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。Target(目标对象): 代理的目标对象。Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。Proxy（代理）: 一个类被AOP织入增强后，就产生一个结果代理类。Aspect(切面): 是切入点和通知（引介）的结合。 1.3.3 学习spring中的AOP要明确的事123456a、开发阶段（我们做的） 编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。 把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP编程人员来做。 在配置文件中，声明切入点与通知间的关系，即切面。：AOP编程人员来做。b、运行阶段（Spring框架完成的） Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 2. 基于XML的AOP配置2.1 环境搭建2.1.1 准备客户的业务层和接口（需要增强的类）12345678910111213141516/** * 客户的业务层接口*/public interface ICustomerService &#123; /** * 保存客户 */ void saveCustomer(); /** * 修改客户 * @param i */ void updateCustomer(int i);&#125; 123456789101112131415/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"调用持久层，执行保存客户\"); &#125; @Override public void updateCustomer(int i) &#123; System.out.println(\"调用持久层，执行修改客户\"); &#125;&#125; 2.1.2 拷贝必备的jar包 2.1.3 创建spring的配置文件并导入约束12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 2.1.4 把客户的业务层配置到spring容器中12&lt;!-- 把资源交给spring来管理 --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"/&gt; 2.1.5 制作通知（增强的类）123456789101112131415/** * 一个用于记录日志的类 * * @author wgy */public class Logger &#123; /** * 记录日志的操作 * 计划让其在业务核心方法（切入点方法）执行之前执行 */ public void beforePrintLog() &#123; System.out.println(\"Logger中的printLog方法开始记录日志了。。。。\"); &#125;&#125; 2.2 配置步骤2.2.1 把通知类用bean标签配置起来12&lt;!-- 把通知类也交给spring来管理 --&gt;&lt;bean id=\"logger\" class=\"com.wgy.util.Logger\"&gt;&lt;/bean&gt; 2.2.2 使用aop:config声明aop配置1234&lt;!-- aop的配置 --&gt;&lt;aop:config&gt; &lt;!-- 配置的代码都写在此处 --&gt; &lt;/aop:config&gt; 2.2.3 使用aop:aspect配置切面1234567&lt;!-- 配置切面 ：此标签要出现在aop:config内部 id：给切面提供一个唯一标识 ref：引用的是通知类的bean的id--&gt;&lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!--配置通知的类型要写在此处--&gt;&lt;/aop:aspect&gt; 2.2.4 使用aop:before配置前置通知12345&lt;!-- 用于配置前置通知：指定增强的方法在切入点方法之前执行 method:用于指定通知类中的增强方法名称 ponitcut-ref：用于指定切入点的表达式的引用 --&gt;&lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"/&gt; 2.2.5 使用aop:pointcut配置切入点表达式1&lt;aop:pointcut expression=\"execution(public void com.wgy.service.impl.CustomerServiceImpl.saveCustomer())\" id=\"pt1\"/&gt; 2.3 切入点表达式说明123456789101112131415161718192021222324252627execution: 匹配方法的执行(常用) execution(表达式)表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))写法说明： 全匹配方式： public void com.wgy.service.impl.CustomerServiceImpl.saveCustomer() 访问修饰符可以省略 void com.wgy.service.impl.CustomerServiceImpl.saveCustomer() 返回值可以使用*号，表示任意返回值 * com.wgy.service.impl.CustomerServiceImpl.saveCustomer() 包名可以使用*号，表示任意包，但是有几级包，需要写几个* * *.*.*.*.CustomerServiceImpl.saveCustomer() 使用..来表示当前包，及其子包 * com..CustomerServiceImpl.saveCustomer() 类名可以使用*号，表示任意类 * com..*.saveCustomer() 方法名可以使用*号，表示任意方法 * com..*.*() 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数 * com..*.*(*) 参数列表可以使用..表示有无参数均可，有参数可以是任意类型 * com..*.*(..) 全通配方式： * *..*.*(..) 实际开发中，我们一般情况下，我们都是对业务层方法进行增强： 所以写法：* com.wgy.service.impl.*.*(..) 2.4 完整配置123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt;&lt;/bean&gt; &lt;!-- 基于xml的aop配置步骤 ：要想使用spring的aop，必须导入aop的jar包--&gt; &lt;!-- 第一步：把通知类交给spring来管理 --&gt; &lt;bean id=\"logger\" class=\"com.wgy.utils.Logger\"&gt;&lt;/bean&gt; &lt;!-- 第二步：导入aop名称空间，并且使用aop:config开始aop的配置 --&gt; &lt;aop:config&gt; &lt;!-- 定义通用的切入点表达式，如果写在aop:aspct标签外部，则表示所有切面可用 --&gt; &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt; &lt;!-- 第三步：使用aop:aspect配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 第四步：配置通知的类型，指定增强的方法何时执行。--&gt; &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:before&gt; &lt;!-- 定义通用的切入点表达式：如果是写在了aop:aspect标签内部，则表示只有当前切面可用 &lt;aop:pointcut expression=\"execution(* com.wgy.service.impl.*.*(..))\" id=\"pt1\"/&gt;--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.5 通知的类型2.5.1 类型说明1234567891011121314151617&lt;!-- 配置通知的类型 aop:before： 用于配置前置通知。前置通知的执行时间点：切入点方法执行之前执行 aop:after-returning： 用于配置后置通知。后置通知的执行时间点：切入点方法正常执行之后。它和异常通知只能有一个执行 aop:after-throwing 用于配置异常通知。异常通知的执行时间点：切入点方法执行产生异常后执行。它和后置通知只能执行一个。 aop:after 用于配置最终通知。最终通知的执行时间点：无论切入点方法执行时是否有异常，它都会在其后面执行。 aop:around 用于配置环绕通知。他和前面四个不一样，他不是用于指定通知方法何时执行的。--&gt; &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pt1\"/&gt;&lt;aop:around method=\"aroundPringLog\" pointcut-ref=\"pt1\"/&gt; 2.5.2 环绕通知的特殊说明1234567891011121314151617181920212223242526272829/** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而环绕通知里的代码执行了。 * 分析： * 由动态代理可知，环绕通知指的是invoke方法，并且里面有明确的切入点方法调用。而我们现在的环绕通知没有明确切入点方法调用。 * 解决： * spring为我们提供了一个接口：ProceedingJoinPoint。该接口可以作为环绕通知的方法参数来使用。 * 在程序运行时，spring框架会为我们提供该接口的实现类，供我们使用。 * 该接口中有一个方法，proceed()，它的作用就等同于method.invoke方法，就是明确调用业务层核心方法（切入点方法） * * 环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制通知方法什么时候执行的方式。 */public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。前置\"); rtValue = pjp.proceed(); System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。后置\"); &#125; catch (Throwable e) &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。异常\"); e.printStackTrace(); &#125;finally&#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。最终\"); &#125; return rtValue;&#125; 3. 基于注解的AOP配置3.1 环境搭建3.1.1 准备客户的业务层和接口（需要增强的类）12345678910111213141516/** * 客户的业务层接口*/public interface ICustomerService &#123; /** * 保存客户 */ void saveCustomer(); /** * 修改客户 * @param i */ void updateCustomer(int i);&#125; 123456789101112131415/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"调用持久层，执行保存客户\"); &#125; @Override public void updateCustomer(int i) &#123; System.out.println(\"调用持久层，执行修改客户\"); &#125;&#125; 3.1.2 拷贝必备的jar包 3.1.3 创建spring的配置文件并导入约束12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;/beans&gt; 3.1.4 把资源使用注解让spring来管理123456789101112131415/** * 客户的业务层实现类 */@Service(\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"调用持久层，执行保存客户\"); &#125; @Override public void updateCustomer(int i) &#123; System.out.println(\"调用持久层，执行修改客户\"); &#125;&#125; 3.1.5 在配置文件中指定spring要扫描的包12&lt;!-- 告知spring，在创建容器时要扫描的包 --&gt;&lt;context:component-scan base-package=\"com.wgy\"&gt;&lt;/context:component-scan&gt; 3.2 配置步骤3.2.1 把通知类也使用注解配置1234567/** * 一个记录日志的工具类 */@Component(\"logger\")public class Logger &#123;&#125; 3.2.2 在通知类上使用@Aspect注解声明为切面12345678/** * 一个记录日志的工具类 */@Component(\"logger\")@Aspect//表明当前类是一个切面类public class Logger &#123; &#125; 3.2.3 在增强的方法上使用注解配置通知1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 一个用于记录日志的类 * * @author wgy */@Component(\"logger\")@Aspect//配置了切面public class Logger &#123; /** * 指定切入点表达式 */ @Pointcut(\"execution(* com.wgy.service.impl.*.*(..))\") private void pt1()&#123;&#125; /** * 前置通知 */// @Before(\"execution(* com.wgy.service.impl.*.*(..))\") public void beforePrintLog() &#123; System.out.println(\"前置：Logger中的beforePrintLog方法开始记录日志了。。。。\"); &#125; /** * 后置通知 */// @AfterReturning(\"pt1()\") public void afterReturningPrintLog() &#123; System.out.println(\"后置：Logger中的afterReturningPrintLog方法开始记录日志了。。。。\"); &#125; /** * 异常通知 */// @AfterThrowing(\"pt1()\") public void afterThrowingPrintLog() &#123; System.out.println(\"异常：Logger中的afterThrowingPrintLog方法开始记录日志了。。。。\"); &#125; /** * 最终通知 */// @After(\"pt1()\") public void afterPrintLog() &#123; System.out.println(\"最终：Logger中的afterPrintLog方法开始记录日志了。。。。\"); &#125; /** * 环绕通知 */ @Around(\"pt1()\") public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。前置\"); rtValue = pjp.proceed(); System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。后置\"); &#125; catch (Throwable e) &#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。异常\"); e.printStackTrace(); &#125;finally&#123; System.out.println(\"Logger中的aroundPrintLog方法开始记录日志了。。。。最终\"); &#125; return rtValue; &#125;&#125; 3.2.4 在spring配置文件中开启spring对注解AOP的支持12&lt;!-- 开启spring对注解AOP的支持 --&gt;&lt;aop:aspectj-autoproxy/&gt; 3.3 不使用XML的配置方式123456@Configuration@ComponentScan(basePackages=\"com.wgy\")@EnableAspectJAutoProxypublic class SpringConfiguration &#123; &#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Spring(二)","date":"2020-06-11T06:53:10.000Z","path":"archives/16fa518f.html","text":"1. 基于注解的IOC配置1.1 写在最前学习基于注解的IoC配置，大家脑海里首先得有一个认知，即注解配置和xml配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 关于实际的开发中到底使用xml还是注解，每家公司有着不同的使用习惯。所以这两种配置方式我们都需要掌握。 1.2 环境搭建1.2.1 拷贝必备jar包注意：在基于xml的配置中，多拷贝一个aop的jar包。如下图： 1.2.2 在类的根路径下创建任意名称的xml文件12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 1.2.3 使用@Component注解配置管理的资源12345678910111213/** * 客户的业务层实现类 * * @author wgy */@Component(value=\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Override public void saveCustomer() &#123; System.out.println(\"执行了保存客户\"); &#125;&#125; 1.2.4 在Spring的配置文件中开启Spring对注解ioc的支持12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 告知spring在创建容器时要扫描的包。当配置了此标签之后，spring创建容器就会去指定的包及其子包下找对应的注解 标签是在一个context的名称空间里，所以必须先导入context名称空间 --&gt; &lt;context:component-scan base-package=\"com.wgy\"/&gt;&lt;/beans&gt; 1.3 常用注解1.3.1 用于创建bean对象1234567891011121314相当于：&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot;&gt;@Component 作用：就相当于配置了一个bean标签。 它能出现的位置：类上面 属性： value：含义是指定bean的id。当不写时，它有默认值，默认值是：当前类的短名首字母改小写。 由此注解衍生的三个注解： @Controller 一般用于表现的注解 @Service 一般用于业务层 @Repository 一般用于持久层 他们和@Component的作用及属性都是一模一样 细节：如果注解中有且只有一个属性要赋值时，且名称是value，value在赋值是可以不写。 1.3.2 用于注入数据的1234567891011121314151617181920212223242526相当于：&lt;property name&#x3D;&quot;&quot; ref&#x3D;&quot;&quot;&gt; &lt;property name&#x3D;&quot;&quot; value&#x3D;&quot;&quot;&gt;@Autowired 作用：自动按照类型注入。只要有唯一的类型匹配就能注入成功。 如果注入的bean在容器中类型不唯一时，它会把变量名称作为bean的id，在容器中查找，找到后也能注入成功。 如果没有找到一致的bean的id，则报错。 当我们使用注解注入时，set方法就不是必须的了。 @Qualifier 作用：在自动按照类型注入的基础之上，再按照bean的id注入。 它在给类成员注入数据时，不能独立使用。但是再给方法的形参注入数据时，可以独立使用。 属性： value：用于指定bean的id。 @Resource 作用：直接按照bean的id注入。 属性： name：用于指定bean的id。 以上三个注解都是用于注入其他bean类型的。用于注入基本类型和String类型需要使用Value@Value: 作用：用于注入基本类型和String类型数据。它可以借助Spring的el表达式读取properties文件中的配置。 属性： value：用于指定要注入的数据 1.3.3 用于改变作用范围的1234567相当于：&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot; scope&#x3D;&quot;&quot;&gt;@Scope 作用：用于改变bean的作用范围 属性： value：用于指定范围的取值。 取值和xml中scope属性的取值是一样的。singleton prototype request session globalsession 1.3.4 和生命周期相关的123456789相当于：&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot; init-method&#x3D;&quot;&quot; destroy-method&#x3D;&quot;&quot; &#x2F;&gt;@PostConstruct 作用： 用于指定初始化方法。@PreDestroy 作用： 用于指定销毁方法。 1.3.5 代码示例持久层 123456789101112131415161718192021222324/** * 客户的业务层实现类 * * @author wgy */@Service(\"customerService\")@Scope(\"singleton\")public class CustomerServiceImpl implements ICustomerService &#123; @Value(\"泰斯特\") private String name;// @Autowired// @Qualifier(\"customerDao1\") @Resource(name=\"customerDao\") private ICustomerDao customerDao = null; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层......\"+name); customerDao.saveCustomer(); &#125;&#125; 持久层 1234567891011121314/** * 模拟客户的持久层实现类 * * @author wgy */@Repository(\"customerDao\")public class CustomerDaoImpl implements ICustomerDao &#123; @Override public void saveCustomer() &#123; System.out.println(\"持久层保存了客户\"); &#125;&#125; 1.3.6 关于Spring注解和XML的选择问题1234注解的优势： 配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。XML的优势： 修改时，不用改源码。不涉及重新编译和部署。 Spring管理Bean方式的比较： 1.4 Spring的纯注解配置1.4.1 待改造的问题我们发现，之所以我们现在离不开xml配置文件，是因为我们有一句很关键的配置： 1234&lt;!-- 告知spring在创建容器时要扫描的包。当配置了此标签之后，spring创建容器就会去指定的包及其子包下找对应的注解 标签是在一个context的名称空间里，所以必须先导入context名称空间--&gt;&lt;context:component-scan base-package&#x3D;&quot;com.wgy&quot;&#x2F;&gt; 如果他要也能用注解配置，那么我们就可以脱离xml文件了。 1.4.2 使用注解配置要扫描的包创建配置类： 1234567891011/** * 一个spring的配置类 * 它的作用就相当于bean.xml * * @author wgy */@Configuration//它就是把当前类看成是spring的配置类@ComponentScan(&#123;\"com.wgy\"&#125;)//配置要扫描的包public class SpringConfiguration &#123; &#125; 测试类获取容器: 123456789public static void main(String[] args) &#123; //1.获取容器：由于我们已经没有了xml文件，所以再用读取xml方式就不能用了。 //这时需要指定加载哪个类上的注解 ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); //2.根据id获取对象 ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); cs.saveCustomer();&#125; 1.4.3 新注解说明1.4.3.1 @Configuration12345@Configuration 作用： 用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class)。 属性： value:用于指定配置类的字节码 1.4.3.2 @ComponentScan123456@ComponentScan 作用： 用于指定spring在初始化容器时要扫描的包。作用和在spring的xml配置文件中的： &lt;context:component-scan base-package&#x3D;&quot;com.wgy&quot;&#x2F;&gt;是一样的。 属性： basePackages：用于指定要扫描的包。和该注解中的value属性作用一样。 1.4.3.3 @PropertySource12345@PropertySource 作用： 用于加载.properties文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties配置文件中，就可以使用此注解指定properties配置文件的位置。 属性： value[]：用于指定properties文件位置。如果是在类路径下，需要写上classpath: 1.4.3.4 @Import12345@Import 作用： 用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration注解。当然，写上也没问题。 属性： value[]：用于指定其他配置类的字节码。 1.4.3.5 @Bean12345@Bean 作用： 该注解只能写在方法上，表明使用此方法创建一个对象，并且放入spring容器。它就相当于我们之前在xml配置中介绍的factory-bean和factory-method。 属性： name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id）。 1.4.3.6 代码示例jdbcConfig.properties: 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc.username=rootjdbc.password=root Jdbc的配置类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Jdbc的配置类 * * @author wgy */public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean(name = \"runner\")//它是把方法的返回值存入Spring容器中。该注解有一个属性，name：用于指定bean的id。当不指定时它有默认值，默认值是方法的名称。 public QueryRunner createQueryRunner(@Qualifier(\"ds1\") DataSource dataSource) &#123; return new QueryRunner(dataSource); &#125; @Bean(name = \"ds\") public DataSource createDataSource() &#123; try &#123; System.out.println(driver);//com.mysql.jdbc.Driver ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; @Bean(name = \"ds1\") public DataSource createDataSource1() &#123; try &#123; System.out.println(url); ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 配置类: 123456789101112131415161718192021222324252627/** * 一个spring的配置类 * 它的作用就相当于bean.xml * * @author wgy */@Configuration//它就是把当前类看成是spring的配置类@ComponentScan(&#123;\"com.wgy\"&#125;)@Import(&#123;JdbcConfig.class&#125;)//导入其他配置类@PropertySource(&#123;\"classpath:config/jdbcConfig.properties\"&#125;)public class SpringConfiguration &#123; /** * Spring EL表达式失效问题： * 目前使用的版本是4.2.4,在spring4.3以前都需要提供一个占位符配置器： * PropertySourcesPlaceholderConfigurer * 而在spring4.3以后，则不需要提供。 * 提供的方式如下：（在SpringConfiguration或JdbcConfig中配置均可） * * @return */ @Bean public static PropertySourcesPlaceholderConfigurer createPropertySourcesPlaceholderConfigurer()&#123; return new PropertySourcesPlaceholderConfigurer(); &#125;&#125; 2. Spring整合Junit2.1 准备测试环境2.1.1 创建业务层接口实现类123456789101112/** * 客户的业务层接口 */public interface ICustomerService &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao; public void setCustomerDao(ICustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125;&#125; 2.1.2 创建持久层接口实现类123456789101112/** * 客户的持久层接口 */public interface ICustomerDao &#123; /** * 查询所有客户 * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 123456789101112/** * 客户的持久层实现类 */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; System.out.println(\"查询了所有客户\"); return null; &#125;&#125; 2.1.3 导入junit的jar包 2.1.4 编写测试类123456789101112/** * 测试客户的业务层和持久层 */public class CustomerServiceTest &#123; private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125;&#125; 2.2 使用xml配置步骤2.2.1 xml文件中的配置123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 把资源交给spring来管理 --&gt; &lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.2.2 拷贝整合junit的必备jar包 2.2.3 使用@RunWith注解替换原有运行器1234567891011@RunWith(SpringJUnit4ClassRunner.class)public class CustomerServiceTest &#123; private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125; &#125; 2.2.4 使用@ContextConfiguration指定spring配置文件的位置123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:bean.xml\"&#125;)public class CustomerServiceTest &#123; private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125; &#125; 2.2.5 使用@Autowired给测试类中的变量注入数据12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:bean.xml\"&#125;)public class CustomerServiceTest &#123; @Autowired private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125;&#125; 2.3 使用纯注解配置步骤2.3.1 拷贝整合junit的必备jar 2.3.2 把资源都用注解管理123456789101112131415/** * 客户的业务层实现类 */@Service(\"customerService\")public class CustomerServiceImpl implements ICustomerService &#123; @Autowired private ICustomerDao customerDao; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return customerDao.findAllCustomer(); &#125;&#125; 12345678910111213/** * 客户的持久层实现类 */@Repository(\"customerDao\")public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; System.out.println(\"查询了所有客户\"); return null; &#125;&#125; 2.3.3 使用注解配置方式创建Spring容器12345678910111213@Configuration@ComponentScan(basePackages=&#123;\"com.wgy\"&#125;)public class CustomerServiceTest &#123; @Autowired private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125;&#125; 2.3.4 使用RunWith注解和ContextConfiguration注解配置123456789101112131415@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=&#123;CustomerServiceTest.class&#125;)@Configuration@ComponentScan(basePackages=&#123;\"com.wgy\"&#125;)public class CustomerServiceTest &#123; @Autowired private ICustomerService customerService; @Test public void testFindAll()&#123; customerService.findAllCustomer(); &#125; &#125; 2.4 为什么不把测试类配到xml中 当我们在xml中配置了一个bean，Spring加载配置文件创建容器时，就会创建对象。 测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Spring(一)","date":"2020-06-10T15:26:00.000Z","path":"archives/b9cbcaed.html","text":"1. Spring概述1.1 Spring概述1.1.1 Spring介绍Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 1.1.2 Spring的发展历程1997年IBM提出了EJB的思想 1998年，SUN制定开发标准规范EJB1.0 1999年，EJB1.1发布 2001年，EJB2.0发布 2003年，EJB2.1发布 2006年，EJB3.0发布 Rod Johnson（spring之父） ​ Expert One-to-One J2EE Design and Development(2002) ​ 阐述了J2EE使用EJB开发设计的优点及解决方案 ​ Expert One-to-One J2EE Development without EJB(2004) ​ 阐述了J2EE开发不使用EJB的解决方式（Spring雏形） 1.1.3 Spring的优势方便解耦，简化开发 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀框架 Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。 降低JavaEE API的使用难度 Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 Java源码是经典学习范例 Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。 1.1.4 Spring的体系结构 1.2 程序的耦合和解耦1.2.1 什么是程序的耦合我们在开发中，会写很多的类，而有些类之间不可避免的产生依赖关系，这种依赖关系称之为耦合。 有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。请看下面的示例代码： 1234567/** * 客户的业务层实现类 */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); &#125; 上面的代码表示：业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。这种依赖关系就是我们可以通过优化代码解决的。 再比如： 下面的代码中，我们的类依赖了MySQL的具体驱动类，如果这时候更换了数据库品牌，我们需要改源码来修改数据库驱动。这显然不是我们想要的。 12345678910111213141516171819202122232425public class JdbcDemo1 &#123; /** * JDBC操作数据库的基本入门中存在什么问题？ * 导致驱动注册两次是个问题，但不是严重的。 * 严重的问题：是当前类和mysql的驱动类有很强的依赖关系。 * 当我们没有驱动类的时候，连编译都不让。 * 那这种依赖关系，就叫做程序的耦合 * * 我们在开发中，理想的状态应该是： * 我们应该尽力达到的：编译时不依赖，运行时才依赖。 * * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接 //3.获取预处理sql语句对象 //4.获取结果集 //5.遍历结果集 &#125;&#125; 1.2.2 解决程序耦合的思路当是我们讲解jdbc时，是通过反射来注册驱动的，代码如下： 1Class.forName(\"com.mysql.jdbc.Driver\"); 这时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除mysql的驱动jar包，依然可以编译。但是因为没有驱动类，所以不能运行。 不过，此处也有个问题，就是我们反射类对象的全限定类名字符串是在java类中写死的，一旦要改还是要修改源码。 解决这个问题也很简单，使用配置文件配置。 1.2.3 工厂模式解耦在实际开发中我们可以把所有的dao和service和action对象使用配置文件配置起来，当启动服务器应用加载的时候，通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 1.2.4 控制反转-Inversion Of Control上面解耦的思路有2个问题： 1、存哪去？ 分析：由于我们是很多对象，肯定要找个集合来存。这时候有Map和List供选择。 ​ 到底选Map还是List就看我们有没有查找需求。有查找需求，选Map。 所以我们的答案就是： ​ 在应用加载时，创建一个Map，用于存放action，Service和dao对象。 ​ 我们把这个map称之为容器。 2、还是没解释什么是工厂？ 工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 原来： ​ 我们在获取对象时，都是采用new的方式。是主动的。 现在： ​ 我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。 这种被动接收的方式获取对象的思想就是控制反转，它是Spring框架的核心之一。 它的作用只有一个：削减计算机程序的耦合。 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 2. 使用Spring的IOC解决程序耦合2.1 案例的前期准备本章我们使用的案例是，客户的业务层和持久层的依赖关系解决。在开始Spring的配置之前，我们要先准备一下环境。由于我们是使用Spring解决依赖关系，并不是真正的要做增伤改查操作，所以此时我们没必要写实体类。并且我们在此处使用的是java工程，不是java web工程。 2.1.1 准备Spring的开发包1234567官网：http:&#x2F;&#x2F;spring.io&#x2F; 下载地址：http:&#x2F;&#x2F;repo.springsource.org&#x2F;libs-release-local&#x2F;org&#x2F;springframework&#x2F;spring解压:(Spring目录结构:) * docs :API和开发规范. * libs :jar包和源码. * schema :约束. 2.1.2 创建业务层接口和实现类123456789101112/** * 模拟：客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 保存客户 */ void saveCustomer();&#125; 12345678910111213141516/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl();//此处有依赖关系 @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\"); customerDao.saveCustomer(); &#125;&#125; 2.1.3 创建持久层接口和实现类12345678910111213/** * 模拟一个客户dao * * @author wgy */public interface ICustomerDao &#123; /** * 保存客户 */ void saveCustomer();&#125; 12345678910111213/** * 模拟客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public void saveCustomer() &#123; System.out.println(\"持久层保存了客户\"); &#125;&#125; 2.2 基于XML的配置（入门案例）2.2.1 拷贝必备的jar包 2.2.2 在类根路径下创建任意名称的xml文件12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 导入schema约束约束的位置在: ..\\spring-framework-4.2.4.RELEASE\\docs\\spring-framework-reference\\html\\xsd-configuration.html文件中。--&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 2.2.3 把资源交给spring来管理12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置资源：把对象的创建交给spring来管理 --&gt; &lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"/&gt; &lt;bean id=\"customerDao\" class=\"com.wgy.dao.impl.CustomerDaoImpl\"/&gt;&lt;/beans&gt; 2.2.4 测试配置是否成功123456789101112131415161718192021/** * spring的入门案例 * * @author wgy */public class Client &#123; /** * ClassPahtXmlApplicationContext：它是只能加载类路径下的配置文件 我们用这个 * FileSystemXmlApplicationContext：它是可以加载磁盘任意位置的配置文件 * * @param args */ public static void main(String[] args) &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据bean的id获取对象 ICustomerService cs = (ICustomerService) ac.getBean(\"customerService\"); cs.saveCustomer(); &#125;&#125; 2.3 Spring基于XML的IOC细节2.3.1 Spring中工厂的类结构图 2.3.1.1 Bean创建的两种规则1234BeanFactory: 提供的是一种延迟加载思想来创建bean对象。bean对象什么时候用什么时候创建ApplicationContext 提供的是一种立即加载思想来创建bean对象。只要一解析完配置文件，就立马创建bean对象。 123456789public static void main(String[] args) &#123; //1.获取容器 Resource resource = new ClassPathResource(\"bean.xml\"); BeanFactory factory = new XmlBeanFactory(resource); //2.根据bean的id获取对象 ICustomerService cs = (ICustomerService) factory.getBean(\"customerService\"); cs.saveCustomer();&#125; 2.3.2 IOC中bean标签和管理对象细节2.3.2.1 bean标签12345678910111213作用： 用于配置对象让Spring来创建的。 默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。属性： id：给对象在容器中提供一个唯一标识。用于获取对象。 class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。 scope：指定对象的作用范围。 init-method：指定类中的初始化方法名称。 destroy-method：指定类中销毁方法名称。 &lt;bean id&#x3D;&quot;customerService&quot; class&#x3D;&quot;com.wgy.service.impl.CustomerServiceImpl&quot; scope&#x3D;&quot;singleton&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destroy&quot;&gt;&lt;&#x2F;bean&gt; 12345678910111213141516171819202122232425/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; public CustomerServiceImpl() &#123; System.out.println(\"bean对象创建了\"); &#125; public void init()&#123; System.out.println(\"对象初始化了\"); &#125; public void destroy()&#123; System.out.println(\"对象销毁了\"); &#125; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\"); &#125;&#125; 2.3.2.2 Bean的作用范围123456789Bean的作用范围： 它是可以通过配置的方式来调整作用范围。 配置的属性：bean标签的scope属性。 属性的取值： singleton：单例的（默认值） prototype：多例的（当我们让spring接管struts2的action创建时，action必须配置此值） request：作用范围是一次请求，和当前请求的转发。 session：作用范围是一次会话。 globalsession ：作用范围是一次全局会话。 2.3.2.3 Bean的生命周期123456789101112Bean的生命周期： 涉及bean标签的两个属性： init-method destroy-method 单例： 出生：容器创建，对象就出生了。 活着：只要容器在，对象就一直存在。 死亡：容器销毁，对象消亡。 多例： 出生：每次使用时，创建对象 活着：只要对象在使用中，就一直活着 死亡：当对象长时间不使用，并且也没有别的对象引用时，由java的垃圾回收器回收。 2.3.2.4 Bean的三种创建方式第一种方式：调用默认无参构造函数创建 此种方式用的最多 1234&lt;!--在默认情况下： 它会根据默认无参构造函数来创建类对象。如果bean中没有默认无参构造函数，则创建失败，会报异常 --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"/&gt; 第二种方式：使用静态工厂中的方法创建对象 1234567891011/** * 模拟一个静态工厂 * * @author wgy */public class StaticFactory &#123; public static ICustomerService getCustomerService() &#123; return new CustomerServiceImpl(); &#125;&#125; 123456789&lt;!-- 此种方式是: 使用StaticFactory类中的静态方法getCustomerService创建对象，并存入Spring容器 id属性：指定bean的id，用于从容器中获取 class属性：指定静态工厂的全限定类名 factory-method属性：指定生产对象的静态方法 --&gt;&lt;bean id=\"staticCustomerService\" class=\"com.wgy.factory.StaticFactory\" factory-method=\"getCustomerService\"&gt;&lt;/bean&gt; 第三种方式：使用实例工厂中的方法创建 1234567891011/** * 模拟一个实例工厂 * * @author wgy */public class InstanceFactory &#123; public ICustomerService getCustomerService() &#123; return new CustomerServiceImpl(); &#125;&#125; 12345678910&lt;!-- 此种方式是： 先把工厂的创建交给Spring来管理。 然后在使用工厂的bean来调用里面的方法 factory-bean属性：用于指定实例工厂bean的id。 factory-method属性：用于指定实例工厂中创建对象的方法。--&gt;&lt;bean id=\"instancFactory\" class=\"com.wgy.factory.InstanceFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"instanceCustomerService\" factory-bean=\"instancFactory\" factory-method=\"getCustomerService\"&gt;&lt;/bean&gt; 2.3.3 Spring的依赖注入它是spring框架核心ioc的具体实现方式。简单的说，就是坐等框架把对象传入，而不用我们自己去获取。 123456789Spring的依赖注入： 注入的方式有3三种： 第一种：使用构造函数注入 第二种：使用set方法注入 第三种：使用注解注入 注入的数据类型有3类： 第一类：基本类型和String类型 第二类：其他bean类型（必须是在spring的配置文件中出现过的bean） 第三类：复杂类型（集合类型） 2.3.3.1 构造函数注入就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置的方式，让Spring框架来为我们注入。具体代码如下： 123456789101112131415161718192021222324/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private String driver; private Integer port; private Date today; //以上三个类成员，没有具体的实际意义，只是用于演示注入。 public CustomerServiceImpl(String driver, Integer port, Date today) &#123; this.driver = driver; this.port = port; this.today = today; &#125; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\"+driver+\",\"+port+\",\"+today); &#125;&#125; 12345678910111213141516171819&lt;!-- 构造函数注入： 涉及的标签：constructor-arg 标签的属性： type:指定参数的类型。 index:指定参数的索引位置，从0开始。 name:指定参数的名称。 一般用它 ========上面三个属性是指定给哪个参数赋值的，下面两个属性是指定赋什么值的============== value:指定基本数据类型或String类型的数据 ref:指定其他bean类型数据 标签出现的位置： 写在bean标签内部 --&gt;&lt;bean id=\"customerService\" class=\"com.wgy.service.impl.CustomerServiceImpl\"&gt; &lt;constructor-arg name=\"driver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"port\" value=\"3306\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"today\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 2.3.3.2 set方法注入就是在类中提供需要注入成员的set方法。具体代码如下： 12345678910111213141516171819202122232425262728293031/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl2 implements ICustomerService &#123; private String driver; private Integer port; private Date today; //以上三个类成员，没有具体的实际意义，只是用于演示注入。 public void setDriver(String driver) &#123; this.driver = driver; &#125; public void setPort(Integer port) &#123; this.port = port; &#125; public void setToday(Date today) &#123; this.today = today; &#125; @Override public void saveCustomer() &#123; System.out.println(\"业务层调用持久层\" + driver + \",\" + port + \",\" + today); &#125;&#125; 1234567891011121314151617&lt;!-- set方法注入 涉及的标签：property 标签的属性： name:指定参数的set方法名称。 =========上面三个属性是指定给哪个参数赋值的，下面两个属性是指定赋什么值的============ value:指定基本数据类型或String类型的数据 ref:指定其他bean类型数据 标签出现的位置： 写在bean标签内部 --&gt;&lt;bean id=\"customerService2\" class=\"com.wgy.service.impl.CustomerServiceImpl2\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"port\" value=\"3307\"&gt;&lt;/property&gt; &lt;property name=\"today\" ref=\"now\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 2.3.3.3 复杂类型的注入就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List,Set,Map,Properties。具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 客户的业务层实现类 * * @author wgy */public class CustomerServiceImpl3 implements ICustomerService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String, String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveCustomer() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 复杂类型的注入 结构相同，标签可以互换 List结构的： array,list,set Map结构的 map,entry,props,prop --&gt;&lt;bean id=\"customerService3\" class=\"com.wgy.service.impl.CustomerServiceImpl3\"&gt; &lt;property name=\"myStrs\"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;props&gt; &lt;prop key=\"testF\"&gt;FFF&lt;/prop&gt; &lt;prop key=\"testG\"&gt;GGG&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;map&gt; &lt;entry key=\"testD\" value=\"DDD\"&gt;&lt;/entry&gt; &lt;entry key=\"testE\"&gt; &lt;value&gt;EEE&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://wgy1993.gitee.io/tags/Spring/"}]},{"title":"Struts2(四)","date":"2020-06-08T07:27:44.000Z","path":"archives/bb3a06c4.html","text":"1. Struts2中的拦截器1.1 Struts2的拦截器基本概念1.1.1 拦截器概述在Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者在定义的action执行的前后加入执行的代码，也可以在一个action执行前阻止其执行。也就是说它提供了一种可以提取action中可重用代码，统一管理和执行的方式。 拦截器链 （Interceptor Chain，在Struts 2中称为拦截器栈Interceptor Stack）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 拦截器和过滤器是有几分相似，但是也有区别： 过滤器是servlet规范中的一部分，任何java web工程都可以使用。 拦截器是struts2框架自己的，只有使用了struts2框架的工程才能用。 过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只有进入struts2核心内部之后，才会起作用，如果访问的是jsp，html,css,image或者js是不会进行拦截的。 同时，拦截器还是AOP编程思想的具体体现形式。AOP（Aspect-Oriented Programming）简单的说就是： 在不修改源码的基础上，已有的方法进行动态增强。 在struts2中，拦截器它就是对我们的动作方法进行增强。（其实就是把重复性的代码提取出来，然后放到拦截器中，统一管理，统一调用） 1.1.2 拦截器的执行时机在访问struts2核心内部时，在动作方法执行之前先正序执行，然后执行动作方法，执行完动作方法和结果视图之后，再倒序执行。所以它是先进后出，是个栈的结构。具体可参考下图： 1.2 自定义拦截器直接或间接的实现Interceptor接口 12345public interface Interceptor extends Serializable &#123; void init(); void destroy(); String intercept(ActionInvocation invocation) throws Exception;&#125; 该接口提供了三个方法，其具体介绍如下。 void init()：该方法在拦截器被创建后会立即被调用, 它在拦截器的生命周期内只被调用一次. 可以在该方法中对相关资源进行必要的初始化。 void destroy()：该方法与init方法相对应，在拦截器实例被销毁之前，将调用该方法来释放和拦截器相关的资源。它在拦截器的生命周期内，也只被调用一次。 String intercept(ActionInvocation invocation) throws Exception：该方法是拦截器的核心方法，用来添加真正执行拦截工作的代码，实现具体的拦截操作。它返回一个字符串作为逻辑视图，系统根据返回的字符串跳转到对应的视图资源。每拦截一个动作请求, 该方法就会被调用一次。该方法的ActionInvocation参数包含了被拦截的Action的引用，可以通过该参数的invoke()方法，将控制权转给下一个拦截器或者转给Action的execute()方法。 继承抽象拦截器类AbstractIntercepter 12345public abstract class AbstractInterceptor implements Interceptor &#123; public void init() &#123;&#125; public void destroy() &#123;&#125; public abstract String intercept(ActionInvocation invocation) throws Exception;&#125; AbstractInterceptor有一个子类MethodFilterInterceptor，该类中提供了两个属性，可以告知拦截器对哪些方法进行拦截或者对哪些方法排除。 1.2.1 第一步：编写普通java类，继承AbstractInterceptor123456789101112131415161718192021222324252627282930313233/** * 自定义拦截器 * 步骤： * 第一步：编写一个普通类，继承AbstractInterceptor（也可以实现Interceptor接口） * 第二步：配置拦截器 * &lt;!-- 声明一个拦截器 --&gt; * &lt;interceptors&gt; * &lt;interceptor name=\"myInterceptor\" class=\"com.itheima.web.interceptors.MyInterceptor\"&gt;&lt;/interceptor&gt; * &lt;/interceptors&gt; * &lt;!-- 引用拦截器：写在action标签的内部。当我们写了自己的拦截器引用时，默认的拦截器栈就失效了 --&gt; * &lt;interceptor-ref name=\"myInterceptor\"&gt;&lt;/interceptor-ref&gt; * 拦截器的放行： * invocation.invoke(); * 返回值的内容是： * 动作方法的返回值 * 关于结果视图的执行时机以及拦截器的返回值问题 * 在放行之前，拦截器的返回值可以控制显示哪个结果视图。一旦放行之后，它一定会显示动作方法返回值所匹配的结果视图，此时已经不管拦截器返回什么内容。 * 多个拦截器的执行顺序问题： * 是由引用顺序决定的，与声明顺序无关 * * @author wgy */public class MyInterceptor extends AbstractInterceptor &#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"访问Action之前：MyInterceptor拦截了。。。。\"); //放行 String rtValue = invocation.invoke(); System.out.println(\"访问Action之后：MyInterceptor拦截了。。。。\"); return rtValue; &#125;&#125; 1.2.2 第二步：在struts.xml中配置拦截器1234567891011121314151617181920&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;!-- 声明一个拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name&#x3D;&quot;myIntercepter&quot; class&#x3D;&quot;com.wgy.web.interceptors.MyInterceptor&quot;&#x2F;&gt; &lt;&#x2F;interceptors&gt; &lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;!-- 引用拦截器：当我们写了自己的拦截器引用时，默认的拦截器栈就失效了 --&gt; &lt;interceptor-ref name&#x3D;&quot;myIntercepter&quot;&#x2F;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 1.3 案例-检查登录拦截器1.3.1 定义拦截器123456789101112131415161718/** * 检查登录拦截器 * * @author wgy */public class CheckLoginInterceptor2 extends MethodFilterInterceptor &#123; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; Object obj = ServletActionContext.getRequest().getSession().getAttribute(\"userinfo\"); if(obj == null)&#123; //没登录，去登录 return \"login\"; &#125; //已登录，就放行 return invocation.invoke(); &#125;&#125; 1.3.2 配置拦截器12345678910111213141516171819&lt;package name&#x3D;&quot;myDefault&quot; extends&#x3D;&quot;struts-default&quot; abstract&#x3D;&quot;true&quot;&gt; &lt;!-- 声明拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name&#x3D;&quot;checkLogin&quot; class&#x3D;&quot;com.wgy.web.interceptors.CheckLoginInterceptor2&quot;&#x2F;&gt; &lt;!-- 定义一个自己的拦截器栈 --&gt; &lt;interceptor-stack name&#x3D;&quot;myDefaultStack&quot;&gt; &lt;interceptor-ref name&#x3D;&quot;checkLogin&quot;&gt; &lt;!-- 告知拦截器，哪些方法需要拦截，哪些方法不需要拦截 --&gt; &lt;param name&#x3D;&quot;excludeMethods&quot;&gt;userLogin&lt;&#x2F;param&gt; &lt;&#x2F;interceptor-ref&gt; &lt;interceptor-ref name&#x3D;&quot;defaultStack&quot;&#x2F;&gt; &lt;&#x2F;interceptor-stack&gt; &lt;&#x2F;interceptors&gt; &lt;!-- 把我们自定义的拦截器栈声明为默认拦截器栈 --&gt; &lt;default-interceptor-ref name&#x3D;&quot;myDefaultStack&quot;&#x2F;&gt; &lt;global-results&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt; &lt;&#x2F;global-results&gt;&lt;&#x2F;package&gt; 1.3.3 编写和配置Action动作类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BBSAction extends ActionSupport implements ServletRequestAware &#123; private HttpServletRequest request; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; /** * 娱乐 * @return */ public String demo1()&#123; System.out.println(request); return SUCCESS; &#125; /** * 体育 * @return */ public String demo2()&#123; System.out.println(request); return SUCCESS; &#125; /** * 军事 * @return */ public String demo3()&#123; System.out.println(request); return SUCCESS; &#125; /** * 登录方法 * @return */ public String userLogin()&#123; //往session域中存入一个登录标记 ServletActionContext.getRequest().getSession().setAttribute(\"userinfo\", \"\"); return SUCCESS; &#125;&#125; 配置 1234567891011121314151617&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;myDefault&quot;&gt; &lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;demo1.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;demo2&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;demo2&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;demo2.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;demo3&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;demo3&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;demo3.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;login&quot; class&#x3D;&quot;com.wgy.web.action.BBSAction&quot; method&#x3D;&quot;userLogin&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;redirect&quot;&gt;&#x2F;main.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 2. Struts2的注解配置2.1 使用前提Struts2框架，它不仅支持基于XML的配置方式，同时也支持基于注解配置的方式。 注解和XML的配置，都是告知struts2框架，当我们jsp页面发送请求，根据配置执行对应动作类的方法，并根据返回值，前往指定的结果视图（jsp页面或者其他动作）。它们只是配置的形式不一样。 其次要想使用struts2的注解，必须要导入一个新的jar包。该jar包是： struts2-convention-plugin-2.3.24.jar 2.2 常用注解2.2.1 @NameSpace1234567891011121314151617出现的位置： 它只能出现在package上或者Action类上。一般情况下都是写在Action类上。作用： 指定当前Action中所有动作方法的名称空间。属性： value：指定名称空间的名称。写法和xml配置时一致。不指定的话，默认名称空间是&quot;&quot;。示例：@Namespace(&quot;&#x2F;customer&quot;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.2.2 @ParentPackage1234567891011121314151617出现的位置： 它只能出现在package上或者Action类上。一般情况下都是写在Action类上。作用： 指定当前动作类所在包的父包。由于我们已经是在类中配置了，所以无需在指定包名了。属性： value：指定父包的名称。示例：@ParentPackage(&quot;struts-default&quot;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.2.3 @Action12345678910111213141516171819出现的位置： 它只能出现在Action类上或者动作方法上。一般情况下都是写在动作方法上。作用： 指定当前动作方法的动作名称。也就是xml配置时action标签的name属性。属性： value：指定动作名称。 results[]：它是一个数组，数据类型是注解。用于指定结果视图。此属性可以没有，当没有该属性时，表示不返回任何结果视图。即使用response输出响应正文。 interceptorRefs[]：它是一个数组，数据类型是注解。用于指定引用的拦截器。示例：&#x2F;** * 获取添加客户页面 * @return *&#x2F;@Action(value&#x3D;&quot;addUICustomer&quot;,results&#x3D;&#123; @Result(name&#x3D;&quot;addUICustomer&quot;,location&#x3D;&quot;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&quot;)&#125;)public String addUICustomer()&#123; return &quot;addUICustomer&quot;;&#125; 2.2.4 @Result123456789101112131415161718192021出现的位置： 它可以出现在动作类上，也可以出现在Action注解中。作用： 出现在类上，表示当前动作类中的所有动作方法都可以用此视图。 出现在Action注解中，表示当前Action可用此视图。属性： name：指定逻辑结果视图名称。 type：指定前往视图的方式。例如：请求转发，重定向，重定向到另外的动作。 location：指定前往的地址。可以是一个页面，也可以是一个动作。示例：&#x2F;** * 保存客户 * @return *&#x2F;@Action(value&#x3D;&quot;addCustomer&quot;,results&#x3D;&#123; @Result(name&#x3D;&quot;addCustomer&quot;,type&#x3D;&quot;redirect&quot;,location&#x3D;&quot;&#x2F;jsp&#x2F;success.jsp&quot;)&#125;)public String addCustomer()&#123; customerService.saveCustomer(customer); return &quot;addCustomer&quot;;&#125; 2.2.5 @Results1234567891011121314151617181920出现的位置： 它可以出现在动作类上，也可以出现在Action注解中。作用： 用于配置多个结果视图。属性： value：它是一个数组，数据类型是result注解。示例：@Results(&#123; @Result(name&#x3D;&quot;login&quot;,location&#x3D;&quot;&#x2F;login.jsp&quot;), @Result(name&#x3D;&quot;error&quot;,location&#x3D;&quot;&#x2F;error.jsp&quot;)&#125;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.2.6 @InterceptorRef123456789101112131415161718192021222324252627282930313233343536出现的位置： 它可以出现在动作类上或者Action注解中。作用： 用于配置要引用的拦截器或者拦截器栈属性： value：用于指定拦截器或者拦截器栈示例：出现在动作方法上：&#x2F;** * 查询所有客户 * @return *&#x2F;@Action(value&#x3D;&quot;findAllCustomer&quot;, results&#x3D;&#123; @Result(name&#x3D;&quot;findAllCustomer&quot;,location&#x3D;&quot;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&quot;) &#125;, interceptorRefs&#x3D;&#123; @InterceptorRef(&quot;myDefaultStack&quot;) &#125;)public String findAllCustomer()&#123; customers &#x3D; customerService.findAllCustomer(); return &quot;findAllCustomer&quot;;&#125;出现在动作类上：@InterceptorRef(&quot;myDefaultStack&quot;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer &#x3D; new Customer(); @Override public Customer getModel() &#123; return customer; &#125;&#125; 2.3 案例-注解实现客户保存和查询列表2.3.1 拷贝必备jar包导入jar包： struts2-convention-plugin-2.3.24.jar 2.3.2 使用注解配置Action1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 客户的动作类 * * @author wgy */@ParentPackage(\"struts-default\")//指定当前包的父包@Namespace(\"/customer\")@Results(&#123; @Result(name=\"customerList\",type=\"redirect\",location=\"findAllCustomer.action\"), @Result(name=\"error\",location=\"/jsp/error.jsp\"), @Result(name=\"addUICustomer\",location=\"/jsp/customer/add.jsp\"), @Result(name=\"findAllCustomer\",location=\"/jsp/customer/list.jsp\")&#125;)public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private ICustomerService customerService = new CustomerServiceImpl(); private Customer customer = new Customer(); private List&lt;Customer&gt; customers; @Override public Customer getModel() &#123; return customer; &#125; /** * 查询所有客户 * @return */ @Action(\"findAllCustomer\") public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.返回 return \"findAllCustomer\"; &#125; /** * 获取添加客户页面 * @return */ @Action(\"addUICustomer\") public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 添加客户 * @return */ @Action(\"addCustomer\") public String addCustomer()&#123; customerService.saveCustomer(customer); return \"customerList\"; &#125; /** * 删除客户 * @return */ @Action(\"deleteCustomer\") public String deleteCustomer()&#123; customerService.deleteCustomer(customer); return \"customerList\"; &#125; //------getters and setters-------------- public List&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers; &#125;&#125;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Struts2(三)","date":"2020-06-07T11:48:27.000Z","path":"archives/4179e9cb.html","text":"1. OGNL表达式1.1 OGNL表达式概述1.1.1 什么是OGNL表达式OGNL的全称是对象图导航语言（Object-Graph Navigation Language），它是一种功能强大的开源表达式语言，使用这种表达式语言，可以通过某种表达式语法，存取Java对象的任意属性，调用Java对象的方法，同时能够自动实现必要的类型转换。如果把表达式看作是一个带有语义的字符串，那么OGNL无疑成为了这个语义字符串与Java对象之间沟通的桥梁。 1.1.2 OGNL表达式的由来它原本是xwork2中的默认表达式语言，当年OpenSymphony和apache在合作开发struts2框架时，把这个表达式也引进来了，所以就变成了struts2的默认表达式语言。 1.1.3 OGNL表达式的使用要求要想使用ognl表达式，一般情况下都得需要使用struts2的标签库。 1&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt; 1.1.4 它的特点它不仅可以用于取值，显示。还可以赋值。取值是我们程序员使用框架做的事情。赋值是框架为我们做的。 1.2 OGNL表达式的基本用法1.2.1 s:property标签输出内容到浏览器1.2.1.1 s:property的用法12345678&lt;%--要想使用OGNL表达式获取数据，此时需要借助struts2的标签库 s:property标签实现把数据输出到浏览器上 &lt;s:property value=\"\"/&gt; value属性的取值是一个OGNL表达式。 标签会把value属性取值所对应的内容输出到浏览器上 如果没有任何对应内容，则什么都不显示--%&gt;OGNL的最基本用法：&lt;s:property value=\"OGNLExpression\"/&gt; 1.2.1.2 OGNL表达式和字符串的转换12345678910111213141516&lt;%--OGNL表达式和字符串的转换 表达式转成字符串 %&#123;''&#125; | %&#123;\"\"&#125; 可以把%&#123;&#125;去掉 --%&gt;OGNL转成一个普通的字符串：&lt;s:property value=\"%&#123;'OGNLExpression1'&#125;\"/&gt;&lt;br/&gt;OGNL转成一个普通的字符串：&lt;s:property value='%&#123;\"OGNLExpression2\"&#125;'/&gt;&lt;br/&gt;OGNL转成一个普通的字符串：&lt;s:property value='\"OGNLExpression3\"'/&gt;&lt;br/&gt;OGNL转成一个普通的字符串：&lt;s:property value=\"'OGNLExpression4'\"/&gt;&lt;br/&gt;&lt;!-- 字符串转成表达式 %&#123;&#125;把字符串套起来--&gt;&lt;!-- user.name 看上去是字符串，当它执行user对象的getName方法时，表示用OGNL表达式解释。 --&gt;字符串转成一个OGNL表达式：&lt;s:textfield name=\"username\" value=\"%&#123;user.name&#125;\"/&gt; 1.2.2 OGNL表达式访问对象的方法1234&lt;%--OGNL表达式访问对象的方法 --%&gt;调用字符串的长度方法：&lt;s:property value=\"'OGNLExpression1'.length()\"/&gt;&lt;br/&gt;调用字符串的转大写方法：&lt;s:property value=\"'OGNLExpression1'.toUpperCase()\"/&gt;&lt;br/&gt;调用字符串的分隔方法：&lt;s:property value=\"'OGNLExpression1'.split('E')\"/&gt;&lt;br/&gt; 1.2.3 OGNL表达式访问类的静态属性和静态方法123456&lt;%--OGNL表达式访问类的静态成员(静态属性) 访问静态属性需要按照固定的书写规范来写。 规范是： @包名.包名...类名@静态属性名称--%&gt;OGNL表达式访问静态属性：&lt;s:property value=\"@java.lang.Integer@MAX_VALUE\"/&gt; 123456&lt;%--OGNL表达式访问类的静态方法 访问静态方法需要按照固定的书写规范来写。 规范是： @包名.包名...类名@静态方法名称--%&gt;OGNL表达式访问静态方法：&lt;s:property value=\"@java.lang.Math@random()\"/&gt; 1.2.4 OGNL表达式操作集合1.2.4.1 list集合1234567891011&lt;%--操作List集合 s:radio标签的list取值就是一个OGNL表达式。 &#123;&#125;就表示创建了一个List集合 &#123;'男','女'&#125;=== List list = new ArrayList(); list.add(\"男\"); list.add(\"女\");--%&gt;Struts2的单选按钮：&lt;br/&gt;&lt;s:radio list=\"&#123;'男','女'&#125;\" name=\"gender2\" label=\"性别\"&gt;&lt;/s:radio&gt;HTML的单选按钮：&lt;br/&gt;性别：&lt;input type=\"radio\" name=\"gender1\" value=\"男\"&gt;男&lt;input type=\"radio\" name=\"gender1\" value=\"女\"&gt;女 1.2.4.2 map集合1234567891011&lt;%--操作Map集合 #&#123;&#125;就表示创建了一个Map集合。 #&#123;key:value,key:value&#125; #&#123;'male':'男','female':'女'&#125;=== Map map = new HashMap(); map.put(\"male\",\"男\"); map.put(\"female\",\"女\");--%&gt;Struts2的单选按钮：&lt;br/&gt;&lt;s:radio list=\"#&#123;'male':'男','female':'女'&#125;\" name=\"gender4\" label=\"性别\"&gt;&lt;/s:radio&gt;HTML的单选按钮：&lt;br/&gt;性别：&lt;input type=\"radio\" name=\"gender3\" value=\"male\"&gt;男&lt;input type=\"radio\" name=\"gender3\" value=\"female\"&gt;女 2. OGNL上下文2.1 ContextMap2.1.1 ContextMap概述它是OGNL上下文对象，是struts2中封装数据最大的对象。我们一次请求中所有用到的信息都可以在它里面找到。它是一个Map结构的对象，其中key是字符串，value是一个Object。 2.1.2 ContextMap中封装的数据 我们把这些内容拿出来逐个分析一下，得到下面的表格： Map的key（类型是String） Map的Value （类型是Object） 说明信息 application Java.util.Map&lt;String,Object&gt; 封装的应用域中的所有数据 session Java.util.Map&lt;String,Object&gt; 封装的会话域中的所有数据 request Java.util.Map&lt;String,Object&gt; 封装的请求域中的所有数据 valueStack(特殊) com.opensymphony.xwork2.ognl.OgnlValueStack 它是List结构 parameters Java.util.Map&lt;String,String[]&gt; 封装的是请求参数 attr Java.util.Map&lt;String,Object&gt; 封装的是四大域的组合数据，从最小的域开始搜索 action com.opensymphony.xwork2.ActionSupport 当前执行的动作类对象 2.2 ActionContext2.2.1 ActionContext对象概述它是一个工具类，是struts2框架提供给我们的，可以让我们调用其中的方法，快速的操作ContextMap。用它操作OGNL上下文对象，比直接操作ContextMap要方便很多。 2.2.2 ActionContext对象与ContextMap的关系ActionContext就相当于对ContextMap进行了一次再封装。 2.2.3 ActionContext何时创建由于ActionContext是操作的ContextMap，而ContextMap中封了我们一次请求的所有数据，所以它的创建应该是每次请求访问Action时，即核心控制器(StrutsPrepareAndExecuteFilter)的doFilter方法执行时，下图是代码截取： 2.2.4 ActionContext的线程安全我们都知道，java的web工程是多线程的，那么每个线程在访问Action时，都会创建自己的ActionContext,那么是如何保证在获取ActionContext时，每个线程都能获取到自己的那个呢？ 答案就是，每次创建ActionContext时，把对象绑定到当前线程上。下图是代码截取： 2.2.5 ActionContext的获取使用ActionContext类中的静态方法getContext()从当前线程上获取 2.2.6 获取ContextMap中的数据2.2.6.1 s:debug标签的使用123456&lt;%-- 引入标签库 --%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;%--1、struts2的debug标签 它是一个用于开发阶段的标签，查看我们OGNL上下文中内容的标签 --%&gt;&lt;s:debug/&gt; 2.2.6.2 使用OGNL表达式获取Map中的数据动作类存数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ActionContext的数据存取 * * @author wgy */public class Demo1Action extends ActionSupport &#123; /** * 通过ActionContext往ContextMap中存入数据 * contextMap hello context map * * 往应用域中存入数据：用两种方式实现 * applicationMap hello application map * applicationAttr hello application attr * * 往会话域中存入数据：同上用两种方式 * @return */ public String demo1()&#123; //1.获取ActionContext //从当前线程上获取 ActionContext context = ActionContext.getContext(); //2.存入数据 context.put(\"contextMap\", \"hello context map\"); //3.往应用域中存入数据 //第一种方式：使用原始ServletAPI对象ServletContext ServletContext applicationAttr = ServletActionContext.getServletContext(); applicationAttr.setAttribute(\"applicationAttr\", \"hello application attr\"); //第二种方式：根据key从ActionContext中获取应用域的map，往map中存入数据 Map&lt;String,Object&gt; applicationMap = context.getApplication(); applicationMap.put(\"applicationMap\",\"hello application map\"); //4.往会话域中存入数据 //第一种：使用ServletAPI的HttpSession HttpSession session = ServletActionContext.getRequest().getSession(); session.setAttribute(\"sessionAttr\", \"hello session attr\"); //第二种：获取key为session的map Map&lt;String,Object&gt; sessionMap = context.getSession(); sessionMap.put(\"sessionMap\",\"hello session map\"); return SUCCESS; &#125;&#125; 在页面中使用OGNL表达式获取： 1234567891011&lt;%--借助struts2的s:property标签和OGNL表达式获取ActionContext存入的数据 我们现在获取的数据，都是在map中。 获取Map中的数据，OGNL表达式的写法： #key 如果还想继续向下获取，使用.key的方式--%&gt;&lt;s:property value=\"#contextMap\"/&gt;&lt;br/&gt;&lt;s:property value=\"#application.applicationMap\"/&gt;&lt;br/&gt;&lt;s:property value=\"#session.sessionAttr\"/&gt;&lt;s:property value=\"#session.sessionMap\"/&gt; 2.3 ValueStack对象2.3.1 ValueStack对象概述ValueStack是Struts的一个接口，字面意义为值栈，OgnlValueStack是ValueStack的实现类，客户端发起一个请求struts2架构会创建一个action实例同时创建一个OgnlValueStack值栈实例，OgnlValueStack贯穿整个 Action 的生命周期。 它是ContextMap中的一部分，里面的结构是一个List，是我们可以快速访问数据一个容器。它的封装是由struts2框架完成的。 通常情况下我们是从页面上获取数据。它实现了栈的特性（先进后出）。 2.3.2 ValueStack的内部结构在 OnglValueStack 中包含了一个CompoundRoot的对象，该对象继承了ArrayList，并且提供了只能操作集合第一个元素的方法，所以我们说它实现了栈的特性。同时，它里面定义了一个ContextMap的引用，也就是说，我们有值栈对象，也可以通过值栈来获取ContextMap。 2.3.3 获取ValueStack中的数据2.3.3.1 值栈中都有什么首先我们要明确，值栈中存的都是对象。因为它本质就是一个List，List中只能存对象。 值栈中包含了我们通过调用push方法压栈的对象，当前执行的动作了和一个名称为DefaultTextProvider的类。值栈中的内容如下图： 2.3.3.2 在动作类中往值栈中存入数据12345678910111213141516171819202122232425262728293031/** * ValueStack的数据存取 * * @author wgy */public class Demo2Action extends ActionSupport &#123; //把私有成员放入值栈中 private String name = \"泰斯特\"; public String getName() &#123; return name; &#125; /** * 获取ValueStack，并且压栈操作 * @return */ public String demo2()&#123; //1.获取ActionContext //从当前线程上获取 ActionContext context = ActionContext.getContext(); //2.获取ValueStack对象 ValueStack vs = context.getValueStack(); //3.压栈操作 Student s = new Student(\"张三\",18,\"male\"); vs.push(s); return SUCCESS; &#125;&#125; 2.3.3.3 我们可以获取值栈中的什么一般情况下，我们都是根据debug标签中显示的Property Name来获取Property Value。 当然我们也可以获取栈顶对象。 2.3.3.5 在页面上使用OGNL表达式获取数据123456789101112131415&lt;%--获取值栈的数据也需要借助于struts2的标签库 使用s:property获取 获取值栈的数据，是直接写属性名称，得到的就是属性的值。 OGNL表达式的找法，是从栈顶逐个属性名称开始查找，只要找到之后，就不再继续查找，而是返回结果。 --%&gt;姓名：&lt;s:property value=\"name\"/&gt;&lt;br/&gt;年龄：&lt;s:property value=\"age\"/&gt;&lt;br/&gt;性别：&lt;s:property value=\"gender\"/&gt;&lt;br/&gt;&lt;%--获取指定位置的属性 --%&gt;获取第一个name:&lt;s:property value=\"[0].name\"/&gt;&lt;br/&gt;获取第二个name:&lt;s:property value=\"[1].name\"/&gt;&lt;%--如果使用s:property标签，没有写value属性，取的是栈顶对象 --%&gt;&lt;s:property/&gt; 2.3.3.6 OGNL表达式执行时调用的方法12345678910111213&lt;%--s:property在通过OGNL表达式获取数据时，所调用的方法：ValueStack中的findValue(String expr); --%&gt;&lt;% ActionContext context = ActionContext.getContext(); ValueStack vs = context.getValueStack(); Object o1 = vs.findValue(\"[0].name\"); out.println(o1); out.println(\"&lt;br/&gt;\"); Object o2 = vs.findValue(\"[1].name\"); out.print(o2); out.println(\"&lt;br/&gt;\"); Object o3 = vs.findValue(\"#application.applicationMap\"); out.print(o3);%&gt; 3. Struts2中使用EL表达式3.1 EL表达式回顾EL表达式的写法：${表达式}。 它是从四大域中，由小到大逐个域搜索，根据名称获取值。只要找到了，就不再继续搜索。 它的原理：使用的是PageContext类中的findValue方法。 3.2 Struts2对EL表达式的改变Struts2框架中对EL表达式做了如下改变： 1234EL表达式原来的搜素顺序： page Scope——&gt;request Scope——&gt;session Scope——&gt;application ScopeEL表达式改变后的搜索顺序： page Scope—&gt;request Scope—&gt;valueStack—&gt;contextMap—&gt;session Scope—&gt;application Scope struts2框架对request对象进行了包装，并且对getAttribute方法进行了增强，代码如下： 4. OGNL表达式中的各种符号总结4.1 %121、把OGNL表达式转成普通字符串 %&#123;&quot;&quot;&#125;2、把字符串转成OGNL表达式%&#123;&#125; 4.2 #121、获取ContextMap中的数据。#key2、在页面中可以创建Map集合。 #&#123;&#125; 4.3 $121、EL表达式使用2、可以在struts2的配置中使用OGNL表达式（配置可以是xml文件，也可以是注解）$&#123;&#125; 5. 案例-优化客户列表的展示5.1 改造Action我们把之前查询所有客户的动作方法改造一下，之前我们是把查询结果存入请求域中了，而此时我们只需要在Action中定义一个集合，并且提供get/set方法，它就会出现在值栈中。就可以在页面中使用OGNL表达式获取。 1234567891011121314151617181920/** * 查询所有客户 * @return */private List&lt;Customer&gt; customers;public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.返回 return \"findAllCustomer\";&#125;public List&lt;Customer&gt; getCustomers() &#123; return customers;&#125;public void setCustomers(List&lt;Customer&gt; customers) &#123; this.customers = customers;&#125; 5.2 改造jsp在显示客户列表时，我们之前采用的是jstl标签库的c:forEach标签，今天我们将使用struts2提供的迭代标签s:iterator。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%-- &lt;c:forEach items=\"$&#123;customers&#125;\" var=\"customer\"&gt; &lt;TR&gt; &lt;TD&gt;$&#123;customer.custName &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custLevel &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custSource &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custIndustry &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custAddress &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custPhone &#125;&lt;/TD&gt; &lt;/TR&gt; &lt;/c:forEach&gt; --%&gt;&lt;%-- struts2中的迭代标签： 属性： value：它的取值是一个OGNL表达式 var：写了该属性：它会把var的值作为key，把当前遍历的对象作为value，存入contextMap中 没写该属性：它会把每次遍历的对象压入栈顶--%&gt;&lt;%-- &lt;s:iterator value=\"customers\" var=\"cust\"&gt; &lt;TR&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custName\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custLevel\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custSource\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custIndustry\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custAddress\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"#cust.custPhone\"/&gt;&lt;/TD&gt; &lt;/TR&gt; &lt;/s:iterator&gt; --%&gt;&lt;s:iterator value=\"customers\"&gt; &lt;TR&gt; &lt;TD&gt;&lt;s:property value=\"custName\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custLevel\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custSource\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custIndustry\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custAddress\"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value=\"custPhone\"/&gt;&lt;/TD&gt; &lt;/TR&gt;&lt;/s:iterator&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Struts2(二)","date":"2020-06-05T09:14:53.000Z","path":"archives/3f8ac9e0.html","text":"1. 结果视图的配置1.1 result标签在sturts.xml文件中，Result的配置非常简单，使用元素来配置Result逻辑视图与物理视图之间的映射，元素可以有name和type属性，但这两种属性都不是必选的。 1234567891011121314151617181920212223242526&lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;!-- result标签： 作用：用于配置结果视图（结果视图可以是一个jsp&#x2F;html，也可以是一个action） 属性： name：指定逻辑结果视图。作用就是和动作方法的返回值进行比较，当一致时，前往配置的页面或者action。不写的话:默认值是success——&gt;去哪 type：指定前往结果视图的方式。以何种方式前往。 ——&gt;怎么去 type取值都是来源于struts-default.xml文件中package名称是struts-default包中定义类型 常用的结果类型： dispatcher：请求转发 （默认值） redirect：重定向(可以是重定向到另外一个动作或者是重定向到一个jsp) redirectAction：重定向到另外一个动作(它由于会自动在后面为我们拼接url后缀，所以只能重定向到动作) 请求转发和重定向的区别： 请求转发：一次请求 地址栏不变 请求域中数据不丢失 服务器行为 只能是在当前应用中转发 重定向： 两次请求 地址栏改变 请求域中数据丢失 浏览器行为 可以定向到当前应用的外部 响应浏览器的三种方式： 请求转发 重定向 使用流输出（如果只有一种方式，那就是此种方式） --&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;redirectAction&quot;&gt;demo2&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;error&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;error.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt;&lt;action name&#x3D;&quot;demo2&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 1.2 配置全局结果视图1.2.1 局部结果视图和全局结果视图配置在action标签内的result，我们成为局部结果视图，它只能由当前action使用。 而在实际开发中，有很多页面，每个action可能都会用到。比如：success.jsp,error.jsp,login.jsp等等。当我们很多action都用到了login.jsp，在每个action标签中都配置一次，显然是不合理的，这个时候我们就用到了全局结果视图。 1.2.2 配置方式12345678910111213141516171819202122&lt;!-- 定义一个公共包 全局结果视图和局部结果视图 定义是放在action标签外面， 在global-results标签内部的结果视图。 可以在多个action中使用 优先级：先找局部，再找全局。--&gt;&lt;package name&#x3D;&quot;myDefault&quot; extends&#x3D;&quot;struts-default&quot; abstract&#x3D;&quot;true&quot;&gt; &lt;global-results&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt; &lt;&#x2F;global-results&gt;&lt;&#x2F;package&gt;&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;myDefault&quot;&gt; &lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;redirectAction&quot;&gt;demo2&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;demo2&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;login&quot;&gt;&#x2F;login.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 2. 访问Servlet的API的两种方式2.1 使用ServletActionContext12345678910111213141516171819202122232425262728293031323334353637383940/** * 访问ServletAPI: * 有两种方式： * 第一种方式： * 使用struts2框架提供的一个工具类，该类中包含了相应的静态方法，可以直接获取 * 工具类是：ServletActionContext * 此种方式是我们实际开发中用的最多的方式 * * 输出结果之后，找出其中一个和其他三个不一样： * org.apache.struts2.dispatcher.StrutsRequestWrapper@1c6e453 它和其他三个不一样，它是struts2提供的 * org.apache.catalina.connector.ResponseFacade@b846ae * org.apache.catalina.core.ApplicationContextFacade@287809 * org.apache.catalina.session.StandardSessionFacade@e0d480 * * @author wgy */public class Demo1Action extends ActionSupport &#123; private HttpServletRequest request; private HttpServletResponse response; private HttpSession session; private ServletContext application; /** * 动作方法 * * @return */ public String demo1()&#123; request = ServletActionContext.getRequest(); response = ServletActionContext.getResponse(); application = ServletActionContext.getServletContext(); session = request.getSession(); System.out.println(request); System.out.println(response); System.out.println(application); System.out.println(session); return SUCCESS; &#125;&#125; 2.2 通过实现接口的方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 访问ServletAPI: * 有两种方式： * 第二种方式： * 通过实现不同的接口，获取不同的对象。 * 要想使用request，需要实现ServletRequestAware * 要想使用response，需要实现ServletResponseAware * 要想使用servletContext，需要实现SerlvetContextAware * 输出结果之后，找出其中一个和其他三个不一样： * org.apache.struts2.dispatcher.StrutsRequestWrapper@1c6e453 它和其他三个不一样，它是struts2提供的 * org.apache.catalina.connector.ResponseFacade@b846ae * org.apache.catalina.core.ApplicationContextFacade@287809 * org.apache.catalina.session.StandardSessionFacade@e0d480 * * * 如果说是一种方式获取ServletAPI对象：ActionContext中的get(key) * 如果说是三种方式获取ServletAPI对象，除了我们讲的两种之外，也可以使用ActionContext获取 * * 通过分析源码，我们得知，ActionContext看上去是一个类似Map的结构。 * map的key是String类型，Map的value是Object类型 * * @author wgy */public class Demo2Action extends ActionSupport implements ServletRequestAware, ServletResponseAware, ServletContextAware &#123; private HttpServletRequest request = null; private HttpServletResponse response = null; private ServletContext application = null; /** * 动作方法 * * @return */ public String demo2()&#123; System.out.println(request); System.out.println(response); System.out.println(application); return SUCCESS; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; @Override public void setServletResponse(HttpServletResponse response) &#123; this.response = response; &#125; @Override public void setServletContext(ServletContext application) &#123; this.application = application; &#125;&#125; 3. 请求参数的封装3.1 请求参数封装概述封装请求参数就是把我们通过浏览器发送请求时，要转递给服务器的数据封装到指定的对象中。这个对象一般都是实体类。但是有时就是Action中的一个属性。也就是说，我们封装请求参数时，可以有实体类，也可以没有。同时，我们还需要知道，请求参数的封装和请求方式无关。无论get还是post都可以封装。 3.2 属性驱动3.2.1 没有实体类此种情况，我们一般也称为动作类和模型在一起，也就是说我们在action中定义一些私有成员，并且提供它们的公有get/set方法。具体代码如下 动作类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 请求参数封装 * 第一种情况： * 属性驱动：没有实体类 * 表单数据的接收都定义在动作类中，所以称为动作类和模型数据写在一起 * 要想封装成功，需要按照要求书写： * 要求是：表单元素的name属性取值，必须和动作类中成员get/set方法后面的部分保持一致 * * 细节： * 1、struts2框架会我们解决post请求的中文乱码问题，但是get请求不解决。 * 2、struts2框架会自动为我们转换数据类型： * 基本类型自动转换 * 字符串数组会按照逗号+空格的方式拼接成字符串 * 日期类型会按照本地格式转成日期对象 * 本地格式：yyyy-MM-dd * * 执行参数封装，是一个名称为params的拦截器实现的。 * 封装的规则只有一个，它要去指定位置找属性，找到之后调用set方法赋值。 * * @author wgy */public class Demo1Action extends ActionSupport &#123; private String username; private Integer age; private Date birthday; private String hobby; /** * 动作方法 * * @return */ public String demo1()&#123; System.out.println(username+\"===\"+age+\"===\"+birthday+\"===\"+hobby); return SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125; jsp页面： 1234567891011&lt;%--请求参数封装：第一种情况：属性驱动-没有实体类 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo1.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo1&quot; class&#x3D;&quot;com.wgy.web.action.Demo1Action&quot; method&#x3D;&quot;demo1&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.2.2 有实体类此种情况是，我们有独立的实体类，在action中定义的是实体类对象，并且提供get/set方法。代码如下： 动作类： 1234567891011121314151617181920212223242526272829303132333435363738/** * 请求参数封装 * 第二种情况： * 属性驱动：有实体类 * 表单数据的接收都定义在实体类中，把实体类定义在动作类中。 * 要想封装成功，需要按照要求书写： * 此时需要使用OGNL表达式来指定表单元素的name取值 * OGNL表达式全称：Object Graphic Navigation Language * 对象 图 导航 语言 * 写法： * user.username user.age * * 执行参数封装，是一个名称为params的拦截器实现的。 * 封装的规则只有一个，它要去指定位置找属性，找到之后调用set方法赋值。 * * @author wgy */public class Demo2Action extends ActionSupport &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; /** * 动作方法 * @return */ public String demo2()&#123; System.out.println(user); return SUCCESS; &#125;&#125; jsp页面： 1234567891011&lt;%--请求参数封装：第二种情况：属性驱动-有实体类 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo2.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"user.username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"user.birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"user.hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"user.hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"user.hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo2&quot; class&#x3D;&quot;com.wgy.web.action.Demo2Action&quot; method&#x3D;&quot;demo2&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3 模型驱动在Struts2中，Action处理请求参数还有另外一种方式，叫做模型驱动（ModelDriven）。通过实现ModelDriven接口来接收请求参数。 动作类： 12345678910111213141516171819202122232425262728293031323334/** * 请求参数封装 * 第三种情况： 我们在后面用的最多的方式 * 模型驱动 * 要想封装成功，需要按照要求书写： * 1、动作类必须实现ModelDriven接口 * 2、动作类中需要定义模型，并且必须实例化出来 * 3、提供接口抽象方法的实现，返回值必须是模型对象 * * 执行参数封装，是一个名称为params的拦截器实现的。 * 模型驱动的实现，除了params拦截器之外，还需要一个叫modelDriven的拦截器配合 * 封装的规则只有一个，它要去指定位置找属性，找到之后调用set方法赋值。 * * @author wgy */public class Demo3Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123; private User user = new User(); @Override public User getModel() &#123; return user; &#125; /** * 动作方法 * * @return */ public String demo3()&#123; System.out.println(user); return SUCCESS; &#125;&#125; jsp页面： 1234567891011&lt;%--请求参数封装：第三种情况：模型驱动 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo3.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo3&quot; class&#x3D;&quot;com.wgy.web.action.Demo3Action&quot; method&#x3D;&quot;demo3&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4 封装集合数据在实际的开发中，有些时候我们需要批量插入用户或者批量插入其他的对象，在Action中需要接受到这多个Action中封装的对象，然后传递给业务层。那么这个时候就需要将表单的数据封装到集合中。 3.4.1 封装到List动作类： 12345678910111213141516171819202122232425262728/** * 请求参数封装 * 复杂类型的封装：List集合封装 * 复杂类型的封装都需要基于第二种情况实现 * * @author wgy */public class Demo4Action extends ActionSupport &#123; private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; /** * 动作方法 * * @return */ public String demo4()&#123; System.out.println(users); return SUCCESS; &#125;&#125; jsp页面： 123456789101112131415161718&lt;%--请求参数封装：List集合类型的封装 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo4.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"users[0].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users[0].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users[0].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users[0].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users[0].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users[0].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; 姓名：&lt;input type=\"text\" name=\"users[1].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users[1].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users[1].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users[1].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users[1].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users[1].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo4&quot; class&#x3D;&quot;com.wgy.web.action.Demo4Action&quot; method&#x3D;&quot;demo4&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4.2 封装到Map动作类： 1234567891011121314151617181920212223242526272829/** * 请求参数封装 * 复杂类型的封装：Map集合封装 * 复杂类型的封装都需要基于第二种情况实现 * * @author wgy */public class Demo5Action extends ActionSupport &#123; private Map&lt;String, User&gt; users; public Map&lt;String, User&gt; getUsers() &#123; return users; &#125; public void setUsers(Map&lt;String, User&gt; users) &#123; this.users = users; &#125; /** * 动作方法 * * @return */ public String demo5()&#123; System.out.println(users); return SUCCESS; &#125;&#125; jsp页面： 123456789101112131415161718&lt;%--请求参数封装：Map集合类型的封装 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo5.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"users['key1'].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users['key1'].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users['key1'].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users['key1'].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users['key1'].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users['key1'].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; 姓名：&lt;input type=\"text\" name=\"users['abc'].username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"users['abc'].age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"users['abc'].birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"users['abc'].hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"users['abc'].hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"users['abc'].hobby\" value=\"写代码\"/&gt;写代码 &lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; struts.xml： 123&lt;action name&#x3D;&quot;demo5&quot; class&#x3D;&quot;com.wgy.web.action.Demo5Action&quot; method&#x3D;&quot;demo5&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 4. 案例：Struts2+Hibernate实现保存删除客户4.1 Struts24.1.1 修改jspmenu.jsp 12345&lt;TR&gt; &lt;TD class=menuSmall&gt; &lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/addUICustomer.action\" target=main&gt;－ 新增客户&lt;/A&gt; &lt;/TD&gt;&lt;/TR&gt; add.jsp 123&lt;FORM id=form1 name=form1 action=\"$&#123;pageContext.request.contextPath &#125;/customer/addCustomer.action\" method=post&gt; ...&lt;/FORM&gt; list.jsp 123456789&lt;SCRIPT language=javascript&gt; function delOne(custId)&#123; var sure = window.confirm(\"确定删除吗？\"); if(sure)&#123; window.location.href = \"$&#123;pageContext.request.contextPath&#125;/customer/deleteCustomer?custId=\"+custId; &#125; &#125;&lt;/SCRIPT&gt;&lt;a href=\"javascript:delOne('$&#123;customer.custId&#125;')\" &gt;删除&lt;/a&gt; 4.1.2 配置xml并编写Actionstruts.xml的配置 12345678910111213141516171819202122232425262728293031&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; &lt;!-- 动作配置 --&gt; &lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;!-- 查询所有客户 --&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;!-- 获取添加客户页面 --&gt; &lt;action name&#x3D;&quot;addUICustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;addUICustomer&quot;&gt; &lt;result name&#x3D;&quot;addUICustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;add.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;!-- 添加客户 --&gt; &lt;action name&#x3D;&quot;addCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;addCustomer&quot;&gt; &lt;!-- &lt;result name&#x3D;&quot;addCustomer&quot; type&#x3D;&quot;redirect&quot;&gt;&#x2F;jsp&#x2F;success.jsp&lt;&#x2F;result&gt; --&gt; &lt;result name&#x3D;&quot;addCustomer&quot; type&#x3D;&quot;redirect&quot;&gt;findAllCustomer&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;!-- 删除客户 --&gt; &lt;action name&#x3D;&quot;deleteCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;deleteCustomer&quot;&gt; &lt;result name&#x3D;&quot;deleteCustomer&quot; type&#x3D;&quot;redirect&quot;&gt;findAllCustomer&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 动作类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 客户的动作类 * * @author wgy */public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private ICustomerService customerService = new CustomerServiceImpl(); private Customer customer = new Customer(); @Override public Customer getModel() &#123; return customer; &#125; /** * 查询所有客户 * @return */ public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //3.把查询的结果存入请求域中 request.setAttribute(\"customers\", customers); //4.返回 return \"findAllCustomer\"; &#125; /** * 获取添加客户页面 * @return */ public String addUICustomer()&#123; return \"addUICustomer\"; &#125; /** * 添加客户 * @return */ public String addCustomer()&#123; customerService.saveCustomer(customer); return \"addCustomer\"; &#125; /** * 删除客户 * @return */ public String deleteCustomer()&#123; customerService.deleteCustomer(customer); return \"deleteCustomer\"; &#125;&#125; 4.2 Hibernate4.2.1 编写业务层接口及实现类123456789101112131415161718192021222324252627/** * 客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer(); /** * 添加客户 * * @param customer */ void saveCustomer(Customer customer); /** * 删除客户 * @param customer */ void deleteCustomer(Customer customer);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 客户的业务层实现类 * 事务控制在业务层的 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 List&lt;Customer&gt; customers = customerDao.findAllCustomer(); //4.提交事务 tx.commit(); //5.返回结果 return customers; &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125; @Override public void saveCustomer(Customer customer) &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 customerDao.saveCustomer(customer); //4.提交事务 tx.commit(); &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125; @Override public void deleteCustomer(Customer customer) &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 customerDao.deleteCustomer(customer); //4.提交事务 tx.commit(); &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 4.2.2 编写持久层接口及实现类123456789101112131415161718192021222324252627282930313233/** * 客户的持久层接口 * * @author wgy */public interface ICustomerDao &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer(); /** * 添加客户 * @param customer */ void saveCustomer(Customer customer); /** * 删除客户 * @param customer */ void deleteCustomer(Customer customer); /** * 根据id查询客户 * @param custID * @return */ Customer findCustomerById(Long custID);&#125; 123456789101112131415161718192021222324252627/** * 客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return HibernateUtil.getCurrentSession().createQuery(\"from Customer\").list(); &#125; @Override public void saveCustomer(Customer customer) &#123; HibernateUtil.getCurrentSession().save(customer); &#125; @Override public void deleteCustomer(Customer customer) &#123; HibernateUtil.getCurrentSession().delete(findCustomerById(customer.getCustId())); &#125; @Override public Customer findCustomerById(Long custID) &#123; return HibernateUtil.getCurrentSession().get(Customer.class,custID); &#125;&#125; 5. 请求参数封装失败后处理办法5.1 配置input结果视图视图路径应该是从哪来回哪去 1234&lt;action name&#x3D;&quot;demo3&quot; class&#x3D;&quot;com.wgy.web.action.Demo3Action&quot; method&#x3D;&quot;demo3&quot;&gt; &lt;result&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;result name&#x3D;&quot;input&quot;&gt;&#x2F;user.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 5.2 提示错误信息引入struts2标签库 1&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt; 1234567891011&lt;%--请求参数封装：类型转换失败的处理方式 --%&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/demo3.action\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;s:fielderror fieldName=\"username\"/&gt;&lt;br/&gt; 年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;s:fielderror fieldName=\"age\"/&gt;&lt;br/&gt; 生日：&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;s:fielderror fieldName=\"birthday\"/&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"/&gt;吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"/&gt;睡觉 &lt;input type=\"checkbox\" name=\"hobby\" value=\"写代码\"/&gt;写代码 &lt;s:fielderror fieldName=\"hobby\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt; 5.3 把提交的数据回显回来html标签和struts2标签都可以实现 123456&lt;s:form action=\"demo3\"&gt; &lt;s:textfield name=\"username\" label=\"姓名\"/&gt; &lt;s:textfield name=\"age\" label=\"年龄\"/&gt; &lt;s:textfield name=\"birthday\" label=\"生日\"/&gt; &lt;s:submit value=\"提交\"/&gt;&lt;/s:form&gt; 5.4 关于中文提示的问题I18N ： 国际化 Internationalization 同实体类创建.properties文件 1invalid.fieldvalue.birthday=请输入正确的日期格式。正确的格式是：yyyy-MM-dd","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Struts2(一)","date":"2020-06-04T15:33:21.000Z","path":"archives/90bb5282.html","text":"1. Struts2基本概念1.1 三层架构和三大框架各自的位置1.1.1 三层架构我们的开发架构一般都是基于两种形式，一种是C/S架构，也就是客户端/服务器，另一种是B/S架构，也就是浏览器/服务器。在JavaEE开发中，几乎全都是基于B/S架构的开发。那么在B/S架构中，系统标准的三层架构包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层： 也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web层，web需要接收http请求，完成http响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用MVC模型。（MVC是表现层的设计模型，和其他层没有关系） 业务层： 也就是我们常说的service层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web层依赖业务层，但是业务层不依赖web层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制） 持久层： 也就是我们是常说的dao层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。 通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。 1.1.2 三大框架和三层架构的关系 1.2 Struts2概述Struts2是一种基于MVC模式的轻量级Web框架，它自问世以来，就受到了广大Web开发者的关注，并广泛应用于各种企业系统的开发中。目前掌握Struts2框架几乎成为Web开发者的必备技能之一。 在介绍Struts2之前，先来认识一下Struts1。Struts1是最早的基于MVC模式的轻量级Web框架，它能够合理的划分代码结构，并包含验证框架、国际化框架等多种实用工具框架。但是随着技术的进步，Struts1的局限性也越来越多的暴露出来。为了符合更加灵活、高效的开发需求，Struts2框架应运而生。 Struts2是Struts1的下一代产品，是在 Struts1和WebWork技术的基础上进行合并后的全新框架（WebWork是由OpenSymphony组织开发的，致力于组件化和代码重用的J2EE Web框架，它也是一个MVC框架）。虽然Struts2的名字与Struts1相似，但其设计思想却有很大不同。实质上，Struts2是以WebWork为核心的，它采用拦截器的机制来处理用户的请求。这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts2可以理解为WebWork的更新产品。 Struts2拥有优良的设计和功能，其优势具体如下： 项目开源，使用及拓展方便，天生优势。 提供Exception处理机制。 Result方式的页面导航，通过Result标签很方便的实现重定向和页面跳转。 通过简单、集中的配置来调度业务类，使得配置和修改都非常容易。 提供简单、统一的表达式语言来访问所有可供访问的数据。 提供标准、强大的验证框架和国际化框架。 提供强大的、可以有效减少页面代码的标签。 提供良好的Ajax支持。 拥有简单的插件，只需放入相应的JAR包，任何人都可以扩展Struts2框架，比如自定义拦截器、自定义结果类型、自定义标签等，为Struts2定制需要的功能，不需要什么特殊配置，并且可以发布给其他人使用。 拥有智能的默认设置，不需要另外进行繁琐的设置。使用默认设置就可以完成大多数项目程序开发所需要的功能。 2. Struts2的入门2.1 Struts2环境搭建2.1.1 下载struts2开发包Struts2的官网: https://struts.apache.org/ 2.1.2 Struts2开发包目录介绍解压后的目录结构如下： 2.1.3 搭建步骤2.1.3.1 第一步：拷贝struts2必备jar包到web工程的lib目录要进行struts2的基本的开发，可以参考struts-2.3.24中的apps下的一些示例代码，其中struts2-blank.war是一个struts2的空的工程。我们只需要将struts2-blank.war解压后进入到WEB-INF下的lib中查看。 2.1.3.2 第二步：在类的根路径下创建一个名称为struts.xml的文件，并导入约束在开发中需要将struts.xml文件引入到工程的src下，因为src下内容发布到web服务器中就是WEB-INF下的classes中。 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 导入约束： 约束的位置：在struts2的核心jar包中 struts2-core-2.3.24.jar中包含一个名称为： struts-2.3.dtd的约束文件--&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt;&lt;&#x2F;struts&gt; 2.1.3.3 第三步：在web.xml配置struts2的核心控制器Struts2框架要想执行，所有的请求都需要经过这个前端控制器（核心过滤器） 12345678910111213141516&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot; version&#x3D;&quot;4.0&quot;&gt; &lt;!-- 配置struts2的核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;&lt;&#x2F;web-app&gt; 2.1.3.4 验证搭建成功与否把应用部署到tomcat中，启动tomcat，不报异常则表示搭建成功。 2.2 Struts2入门案例2.2.1 案例需求通过点击超链接发送请求，由Struts2中类来负责接收，并且在控制台输出接收到了的语句。 2.2.2 案例实现2.2.2.1 第一步：编写index.jsp 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;struts2的入门案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--struts2的核心控制默认会处理以.action为后缀的url，或者是没有任何后缀的url --%&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/hello\"&gt;访问第一个struts2应用&lt;/a&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/hello.action\"&gt;访问第一个struts2应用.action&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 2.2.2.2 第二步：编写Class12345678910111213141516171819202122232425/** * 我们的第一个动作类。 * 动作类： * 它就是一个概念。它就是struts2框架中用于处理请求的类。 * 我们以后处理请求都写动作类。 * * @author wgy */public class HelloAction &#123; /** * 我们的第一个动作方法 * 动作方法： * 动作类中用于处理请求的方法 * 动作方法有编写规范： * 1、访问修饰符都是public * 2、方法的返回值一般都是String(但是可以是void) * 3、方法都没有参数 * @return */ public String sayHello()&#123; System.out.println(\"HelloAction的sayHello方法执行了。。。。\"+this); return \"success\"; &#125;&#125; 2.2.2.3 第三步：在配置文件中配置我们的动作类123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.0.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 配置文件 --&gt; &lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 2.2.2.4 第四步：编写success.jsp1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;执行结果页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;执行成功！&lt;/body&gt;&lt;/html&gt; 2.2.2.5 第五步：启动tomcat测试访问结果2.3 Struts2的执行过程2.3.1 执行时序首先是，启动tomcat服务器，这时候会加载web.xml，当读到filter标签时，会创建过滤器对象。 Struts2的核心过滤器（StrutsPrepareAndExecuteFilter）会负责加载类路径下的struts.xml配置文件。 接下来，从客户端发送请求过来 先经过前端控制器（核心过滤器StrutsPrepareAndExecuteFilter），前端控制器会根据请求的名称在struts.xml中找到对应的配置，创建我们的动作类对象（每次访问时都会创建新的Action对象），然后执行指定的方法，根据方法的返回值找到Result的配置进行页面的跳转.最后响应浏览器。 2.3.2 内部执行流程Struts2框架在默认情况下核心控制器（StrutsPrepareAndExecuteFilter）默认会拦截以.action为后缀的请求，或者是没有任何后缀的请求。当拦截下来后，送入Struts2的核心内部。如下图所示： 我们通过上面的图解，应该明确在实际开发中我们用struts2要做哪些： 写动作类 写jsp 写配置文件 其中，又以配置文件为重。 3. Struts2的配置文件详解3.1 Struts2中的配置文件3.1.1 配置文件说明在struts2中给我们提供了6个配置文件。他们的加载时机是tomcat启动服务一加载我们的应用时，就加载struts2的配置文件。 他们的加载顺序入如下： 顺序 配置文件名 所在位置 说明 1 default.properties struts2-core-2.3.15.3.jar\\org\\apache\\struts2 不能修改 2 struts-default.xml struts2-core-2.3.15.3.jar 不能修改 3 strtuts-plugin.xml 在struts2提供的插件jar包中 不能修改 4 struts.xml 我们的应用中 我们修改的：推荐 5 struts.properties 我们的应用中 我们修改的 6 web.xml 我们的应用中 我们修改的，可以给过滤器配置参数 3.1.2 配置文件的注意事项 Struts2提供了两种配置的方式。一种是key=value的方式，即使用.properties文件。另一种是xml文件配置。我们推荐使用xml文件（它能描述层级关系）。 当多个配置文件中，有相同的参数，后加载的会把前面的值给覆盖了。 3.1.3 Struts2中的常用常量常量定义在了default.properties配置文件中，体现形式都是key=value。所有的struts2应用都会用到这些常量。 常用的： 常量名 常量值 说明 struts.i18n.encoding UTF-8 应用中使用的编码 struts.objectFactory.spring.autoWire name 和spring框架整合有关 struts.multipart.parser jakarta 指定文件上传用的组件 struts.multipart.maxSize 2097152 文件上传总文件大小限制：2M struts.action.extension action,, 能进入Struts2框架内部的url地址后缀名。多个值用逗号分隔 struts.enable.DynamicMethodInvocation false 是否允许动态方法调用 struts.devMode false 是否是开发模式。开发模式：改了配置文件，不需要重启。输出更多的错误信息。开发阶段建议为true struts.ui.theme xhtml 页面展示用的主题 3.2 Struts.xml中的标签详解3.2.1 constant标签123456789&lt;!-- constant标签： 作用： 用于修改struts2中的常量 属性： name：指定常量的key value：指定常量的值--&gt;&lt;!-- 开启开发者模式 --&gt;&lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; 3.2.2 package标签1234567891011121314151617181920&lt;!-- package标签： 作用：给访问的action进行分包管理。把配置文件按照面向对象的思想来管理。 属性： name：指定包的名称。必须写，并且必须唯一。 extends：指定当前包的父包。子包自动具备父包所定义的配置。我们的包一般都需要继承struts-default包。 该包在struts-defaul.xml文件中定义着。如果不继承该包，则不能使用struts2的核心功能。 abstract：把当前包声明为抽象包。抽象包就是用来被继承的。里面定义一般都是公共的配置。 只有没有action标签的包，才能定义为抽象包。 namespace：指定当前包的名称空间。它可以让我们的访问URL模块化。当我们指定了该属性，访问URL就变成了：名称空间+&#x2F;hello 名称空间的写法：第一个字符必须是&#x2F;，后面紧跟的字符必须是一个字母。其余内容可以是字母，也可以是数字。 例如：我们访问用户 &#x2F;user&#x2F;addUser.action &#x2F;user&#x2F;updateUser.action 名称空间有默认值。默认值是：&quot;&quot;--&gt;&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;n1&quot;&gt; &lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.2.3 action标签12345678910&lt;!-- action标签： 作用：建立动作名称，动作类和动作方法的对应关系 属性： name:指定动作名称。它是唯一的 class:指定动作类的全限定类名 method：指定动作方法名称--&gt;&lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3 action的三种创建方式3.3.1 第一种：无侵入式创建(实际开发中基本不用)12345678910111213/** * 我们的第一个动作类 * 动作类的第一种创建方式： * 无侵入式的创建。 */public class HelloAction &#123; public String sayHello()&#123; System.out.println(this); System.out.println(\"HelloAction中的sayHello方法执行了。。。。\"); return \"success\"; &#125;&#125; 123&lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3.2 第二种：实现Action接口的定义方式 (实际开发中用的也不多)12345678910111213/** * 通过实现接口的方式创建动作类 * * @author wgy */public class Hello2Action implements Action &#123; @Override public String execute() throws Exception &#123; System.out.println(\"Hello2Action的execute方法执行了。。。。\"); return SUCCESS; &#125;&#125; 1234&lt;!-- 默认动作方法：当我们要是执行的是execute方法时，method属性可以不写。 --&gt;&lt;action name&#x3D;&quot;hello2&quot; class&#x3D;&quot;com.wgy.web.action.Hello2Action&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; Action接口中的常量 SUCCESS：一般多用于成功 ERROR：一般多用于动作方法执行失败 LOGIN：一般多用于返回登录页面 NONE：一般用于不返回任何结果视图，和return null作用是一样的 INPUT：一般多用于数据回显，也是struts2中数据回显时的默认返回值。 3.3.3 第三种：继承ActionSupport (实际开发中采用的方式)12345678/** * 通过继承ActionSupport的方式创建动作类 * * @author wgy */public class Hello3Action extends ActionSupport &#123;&#125; 123&lt;action name&#x3D;&quot;hello3&quot; class&#x3D;&quot;com.wgy.web.action.Hello3Action&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3.4 默认动作类：ActionSupport类1234&lt;!-- 通过struts-default.xml中我们知道默认的动作类是ActionSupport，所以如果实现该类的execute方法，则可以不用指定class和method属性 --&gt;&lt;action name&#x3D;&quot;hello4&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4 action的三种访问方式12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 用户的动作类 * * @author wgy */public class UserAction extends ActionSupport &#123; /** * 保存 * @return */ public String addUser() &#123; System.out.println(\"保存了用户\"); return SUCCESS; &#125; /** * 更新 * @return */ public String updateUser() &#123; System.out.println(\"更新了用户\"); return SUCCESS; &#125; /** * 查询 * @return */ public String deleteUser() &#123; System.out.println(\"删除了用户\"); return SUCCESS; &#125; /** * 删除 * @return */ public String findUser() &#123; System.out.println(\"查询了用户\"); return SUCCESS; &#125;&#125; 3.4.1 第一种：全匹配配置访问方式1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUser\"&gt;查询用户&lt;/a&gt; 1234567891011121314&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;addUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;addUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;updateUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;updateUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;deleteUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;deleteUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;findUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;findUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.4.2 第二种：使用通配符的方式* 通配符基本用法 1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUser\"&gt;查询用户&lt;/a&gt; 123456&lt;!-- 通配符基本用法 --&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;*&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;&#123;1&#125;&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 通配符的高级用法 1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/add_User\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/update_User\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/delete_User\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/find_User\"&gt;查询用户&lt;/a&gt; 123456&lt;!-- 通配符的高级用法 --&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;*_*&quot; class&#x3D;&quot;com.wgy.web.action.&#123;2&#125;Action&quot; method&#x3D;&quot;&#123;1&#125;&#123;2&#125;&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.4.3 第三种：使用动态方法调用的方式1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!findUser\"&gt;查询用户&lt;/a&gt; 1234567&lt;!-- 使用动态方法调用的方式 --&gt;&lt;constant name&#x3D;&quot;struts.enable.DynamicMethodInvocation&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;user&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 4. 案例：Strut2+Hibernate查询客户列表4.1 第一步：搭建hibernate开发环境并准备实体类和映射配置可参考Hibernate环境搭建。 Hibernate开发环境 1234567891011121314151617181920212223242526272829303132&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory--&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;struts2&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;property&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;&#x2F;property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping class&#x3D;&quot;com.wgy.domain.Customer&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 实体类和映射配置 123456789101112131415161718192021222324252627282930313233/** * 客户的实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name = \"cust_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 4.2 第二步：搭建struts2环境参考2.1.3章节的步骤去做。 4.3 第三步：导入crm的jsp页面把下图中红框内文件夹下所有内容都拷贝到WebContent目录中 4.4 第四步：修改menu.jsp12345&lt;TR&gt; &lt;TD class=menuSmall&gt; &lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/findAllCustomer.action\" target=main&gt;－ 客户列表&lt;/A&gt; &lt;/TD&gt;&lt;/TR&gt; 4.5 第五步：在配置文件中配置findAllCustomer.action1234567891011121314&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; &lt;!-- 动作配置 --&gt; &lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 4.6 第六步：创建动作类并提供动作方法123456789101112131415161718192021222324/** * 客户的动作类 * * @author wgy */public class CustomerAction extends ActionSupport &#123; private ICustomerService customerService = new CustomerServiceImpl(); /** * 查询所有客户 * @return */ public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //3.把查询的结果存入请求域中 request.setAttribute(\"customers\", customers); //4.返回 return \"findAllCustomer\"; &#125;&#125; 4.7 第七步：编写service接口和实现类1234567891011121314/** * 客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617181920212223242526272829303132/** * 客户的业务层实现类 * 事务控制在业务层的 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 List&lt;Customer&gt; customers = customerDao.findAllCustomer(); //4.提交事务 tx.commit(); //5.返回结果 return customers; &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 4.8 第八步：编写dao接口和实现类1234567891011121314/** * 客户的持久层接口 * * @author wgy */public interface ICustomerDao &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 123456789101112/** * 客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return HibernateUtil.getCurrentSession().createQuery(\"from Customer\").list(); &#125;&#125; 4.9 第九步：页面展示jsp/customer/list.jsp12345678910&lt;c:forEach items=\"$&#123;customers&#125;\" var=\"customer\"&gt; &lt;TR&gt; &lt;TD&gt;$&#123;customer.custName &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custLevel &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custSource &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custIndustry &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custAddress &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custPhone &#125;&lt;/TD&gt; &lt;/TR&gt; &lt;/c:forEach&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Hibernate(四)","date":"2020-06-03T14:33:02.000Z","path":"archives/c4c4045f.html","text":"1. JPA相关概念1.1 JPA概述全称是：Java Persistence API。是SUN公司推出的一套基于ORM的规范。Hibernate框架中提供了JPA的实现。 JPA通过JDK 5.0注解或XML描述对象—关系表的映射关系，并将运行期的实体对象持久化到数据库中。 1.2 JPA的优势 标准化 JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。 容器级特性的支持 JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。 简单方便 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成。 查询能力 JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。 高级特性 JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。 1.3 学习JPA要明确的 JPA是一套ORM规范，Hibernate实现了JPA规范 hibernate中有自己的独立ORM操作数据库方式，也有JPA规范实现的操作数据库方式。 2. JPA入门2.1 需求介绍本章节我们实现基于JPA注解的对象关系映射，配置实体类和数据库表的对应关系。并且使用JPA规范中的方法实现CRUD操作。 2.2 JPA环境搭建2.2.1 第一步：拷贝jar包 2.2.2 第二步：创建配置文件在src下面的META-INF文件夹下面创建一个名称为persistence.xml的文件。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;persistence xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence&#x2F;persistence_2_0.xsd&quot; version&#x3D;&quot;2.0&quot;&gt; &lt;!-- 配置持久化单元，可以配置多个，但是名称不能重复 name:用于指定持久化单元名称 transaction-type:指定事务的类型。 JTA：Java Transaction API RESOURCE_LOCAL:指的是本地代码事务。（我们用这个） --&gt; &lt;persistence-unit name&#x3D;&quot;myJPAUnit&quot; transaction-type&#x3D;&quot;RESOURCE_LOCAL&quot;&gt; &lt;!-- JPA规范的提供商 可以不写。--&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;&#x2F;provider&gt; &lt;!-- 指定由Jpa注解的实体类位置 可以不写。--&gt; &lt;class&gt;com.wgy.domain.Customer&lt;&#x2F;class&gt; &lt;!-- 连接库相关的一些配置 --&gt; &lt;properties&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot; value&#x3D;&quot;org.hibernate.dialect.MySQLDialect&quot;&#x2F;&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot; value&#x3D;&quot;update&quot;&#x2F;&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;persistence-unit&gt;&lt;&#x2F;persistence&gt; 2.2.3 第三步：编写工具类，用于获取JPA的操作数据库对象1234567891011121314151617181920212223/** * JPA的工具类 * * @author wgy */public class JPAUtil &#123; //它就相当于SessionFactory private static EntityManagerFactory factory; static &#123; //注意：该方法参数必须和persistence.xml中persistence-unit标签name属性取值一致 factory = Persistence.createEntityManagerFactory(\"myJPAUnit\"); &#125; /** * 获取EntityManager对象 * * @return */ public static EntityManager createEntityManager() &#123; return em.createEntityManager(); &#125;&#125; 2.2.4 第四步：编写实体类并使用注解配置12345678910111213141516171819202122232425262728293031323334/** * 客户实体类 * 使用的注解都是JPA规范，所以导包，都需要导入javax.persistence包下的 * * @author wgy */@Entity//表明该类是一个实体类@Table(name = \"cst_customer\")//建立当前类和数据库表的对应关系public class Customer implements Serializable &#123; @Id//表明当前字段是主键 @Column(name = \"cust_id\")//表明对应数据库的主键字段是cust_id @GeneratedValue(strategy = GenerationType.IDENTITY)//指定主键生成策略。 private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 2.3 JPA的CRUD操作2.3.1 保存123456789101112131415161718192021/** * 保存 */@Testpublic void test1() &#123; //创建客户对象 Customer c = new Customer(); c.setCustName(\"JPA Customer\"); //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行保存操作 em.persist(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.2 快照更新12345678910111213141516171819/** * 更新操作 */@Testpublic void test3() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //修改客户的地址为：顺义区 c.setCustAddress(\"顺义区\"); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.3 merge更新12345678910111213141516171819202122/** * 更新的另一种操作方式 * merge是合并 （两个实体合并） */@Testpublic void test4() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //修改客户的地址为：顺义区 c.setCustAddress(\"北京市顺义区\"); em.merge(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.4 删除1234567891011121314151617181920/** * 删除操作 */@Testpublic void test5() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //删除操作 em.remove(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.5 查询一个12345678910111213141516171819202122232425262728293031323334353637/** * 查询一个实体 立即加载 */@Testpublic void test2() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); System.out.println(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125;/** * 查询一个实体 延迟加载 */@Testpublic void test2_1() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.getReference(Customer.class, 1L); System.out.println(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.6 查询所有12345678910111213141516171819202122232425262728293031323334353637/** * 查询所有 * * 涉及的对象是： * JPA的Query * 如何获取该对象： * EntityManager的createQuery(String jpql) * 参数含义： * JPQL：Java Persistence Query Language * 他的写法和HQL很相似。也是把表名换成类名，把字段名换成属性名称 * 它在写查询所有时，不能直接用 from 实体类 * 需要使用select关键字 * select c from Customer c */@Testpublic void test6() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.获取JPA的查询对象Query Query query = em.createQuery(\"select c from Customer c where custName like ? and custLevel = ? \"); //给占位符赋值 query.setParameter(1, \"%集%\"); query.setParameter(2, \"23\"); //执行方法获取结果集 //getSingleResult()：查询结果是一个对象 List list = query.getResultList(); for (Object o : list) &#123; System.out.println(o); &#125; //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 3. JPA的多表操作3.1 一对多关系配置及操作3.1.1 配置123456789101112131415161718192021222324252627282930313233343536373839404142/** * 客户实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name = \"cust_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; /** * 一对多关系映射：一个客户可以有多个联系人 * mappedBy 取消维护 * cascade 级联保存 * fetch 查询加载时机 */ @OneToMany(targetEntity = LinkMan.class,mappedBy = \"customer\",cascade = CascadeType.ALL,fetch = FetchType.EAGER) private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); ...&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 联系人的实体类 * * @author wgy */@Entity@Table(name = \"cst_linkman\")public class LinkMan implements Serializable &#123; @Id @Column(name = \"lkm_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long lkmId; @Column(name = \"lkm_name\") private String lkmName; @Column(name = \"lkm_gender\") private String lkmGender; @Column(name = \"lkm_phone\") private String lkmPhone; @Column(name = \"lkm_mobile\") private String lkmMobile; @Column(name = \"lkm_email\") private String lkmEmail; @Column(name = \"lkm_position\") private String lkmPosition; @Column(name = \"lkm_memo\") private String lkmMemo; /** * 一对多关系映射，多的一方。 * 从表实体包含主表实体的对象引用 */ @ManyToOne(targetEntity = Customer.class,fetch = FetchType.LAZY) @JoinColumn(name = \"lkm_cust_id\",referencedColumnName = \"cust_id\") private Customer customer; ...&#125; 3.1.2 操作3.1.2.1 保存123456789101112131415161718192021222324/** * 保存操作 * 创建一个客户和一个联系人 * 建立客户和联系人的双向关联关系 * 先保存客户，再保存联系人 */@Testpublic void test1() &#123; Customer c = new Customer(); LinkMan l = new LinkMan(); c.setCustName(\"JPA One To Many Customer\"); l.setLkmName(\"JPA One To Many LinkMan\"); c.getLinkmans().add(l); l.setCustomer(c); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); em.persist(c); em.persist(l); tx.commit(); em.close();&#125; 3.1.2.2 更新1234567891011121314151617181920212223/** * 更新操作 * 创建一个联系人 * 查询id为5的客户 * 为5这个客服分配该联系人 * 更新客户 */@Testpublic void test2() &#123; LinkMan l = new LinkMan(); l.setLkmName(\"JPA One To Many LinkMan 2\"); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer c = em.find(Customer.class, 5L); c.getLinkmans().add(l); l.setCustomer(c); tx.commit(); em.close();&#125; 3.1.2.3 删除123456789101112131415/** * 删除操作 */@Testpublic void test3() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer c = em.find(Customer.class, 5L); em.remove(c); tx.commit(); em.close();&#125; 3.1.2.4 查询12345678910111213141516171819202122232425262728293031323334353637/** * 根据客户查询客户下的联系人 */@Testpublic void test1() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //1.查询id为1的客户 Customer c = em.find(Customer.class, 1l); System.out.println(c); //查询当前客户下的联系人 Set&lt;LinkMan&gt; linkmans = c.getLinkmans(); System.out.println(linkmans); tx.commit(); em.close();&#125;/** * 根据联系人，查询联系人的所属客户 */@Testpublic void test2() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //1.查询id为1的客户 LinkMan l = em.find(LinkMan.class, 1l); System.out.println(l); //查询当前客户下的联系人 Customer c = l.getCustomer(); System.out.println(c); tx.commit(); em.close();&#125; 3.2 多对多关系配置及操作3.2.1 配置12345678910111213141516171819202122232425262728293031/** * 角色的实体类 * * @author wgy */@Entity@Table(name = \"sys_role\")public class SysRole implements Serializable &#123; @Id @Column(name = \"role_id\") @GenericGenerator(name = \"uuid\", strategy = \"uuid\")//声明一个主键生成器 name属性：给生成器起个名字。strategy：指定的就是hibernate中包含的生成策略 @GeneratedValue(generator = \"uuid\") private String roleId; @Column(name = \"role_name\") private String roleName; @Column(name = \"role_memo\") private String roleMemo; //多对多关系映射：一个角色可以赋予多个用户 @ManyToMany(cascade=CascadeType.ALL) //加入一张表 @JoinTable(name=\"user_role_ref\", joinColumns = &#123;@JoinColumn(name=\"role_id\",referencedColumnName=\"role_id\")&#125;,//写的是当前实体在中间表的外键字段 inverseJoinColumns=&#123;@JoinColumn(name=\"user_id\",referencedColumnName=\"user_id\")&#125;//写的是对方实体在中间表的外键字段 ) private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); ...&#125; 1234567891011121314151617181920212223242526272829/** * 用户的实体类 * * @author wgy */@Entity@Table(name = \"sys_user\")public class SysUser implements Serializable &#123; @Id @Column(name = \"user_id\") @GenericGenerator(name = \"uuid\", strategy = \"uuid\") @GeneratedValue(generator = \"uuid\") private String userId; @Column(name = \"user_name\") private String userName; @Column(name = \"user_password\") private String userPassword; @Column(name = \"user_state\") private Integer userState; //多对多关系映射：一个用户可以具备多个角色 @ManyToMany(mappedBy=\"users\",cascade= CascadeType.ALL) private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); ...&#125; 3.2.2 操作3.2.2.1 保存1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 保存操作 * 创建两个用户 * 创建三个角色 * 让1号用户具备1号和2号角色 * 让2号用户具备2号和3号角色 * 保存用户和角色 */@Testpublic void test1() &#123; SysUser u1 = new SysUser(); SysUser u2 = new SysUser(); u1.setUserName(\"JPA Many to Many u1\"); u2.setUserName(\"JPA Many to Many u2\"); SysRole r1 = new SysRole(); SysRole r2 = new SysRole(); SysRole r3 = new SysRole(); r1.setRoleName(\"JPA Many to Many r1\"); r2.setRoleName(\"JPA Many to Many r2\"); r3.setRoleName(\"JPA Many to Many r3\"); //建立用户和角色的关联关系 u1.getRoles().add(r1); u1.getRoles().add(r2); u2.getRoles().add(r2); u2.getRoles().add(r3); r1.getUsers().add(u1); r2.getUsers().add(u1); r2.getUsers().add(u2); r3.getUsers().add(u2); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //保存操作 em.persist(u1); tx.commit(); em.close();&#125; 3.2.2.2 删除123456789101112131415/** * 删除操作 * 双向级联删除，不管是hibernate还是Jpa,多对多中都不能配置 */@Testpublic void test2() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //查询用户 SysUser u1 = em.find(SysUser.class, \"8a7e83cc5fbf19b6015fbf19bada0000\"); em.remove(u1); tx.commit(); em.close();&#125; 4. JPA的其他说明4.1 JPA中使用C3P0连接池4.1.1 第一步：拷贝C3P0所必须的3个jar包 4.1.2 第二步：在persistence.xml配置文件中配置12&lt;!-- 配置使用C3P0数据源 --&gt;&lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot; value&#x3D;&quot;org.hibernate.connection.C3P0ConnectionProvider&quot;&#x2F;&gt; 4.1.3 验证是否配置成功1234567891011121314151617/** * 验证c3p0连接池是否配置成功 */@Testpublic void test1() &#123; //1.获取jpa中的操作对象 EntityManager em = JPAUtil.createEntityManager(); //2. Session session = em.unwrap(Session.class); //3.执行session的doWork方法 session.doWork(new Work() &#123; @Override public void execute(Connection conn) throws SQLException &#123; System.out.println(conn.getClass().getName()); &#125; &#125;);&#125; 12345678@Testpublic void test2() &#123; //1.获取jpa中的操作对象 EntityManager em1 = JPAUtil.createEntityManager(); EntityManager em2 = JPAUtil.createEntityManager(); //false System.out.println(em1 == em2);&#125; 4.2 JPA与Hibernate中操作数据的方法对照 5. Hibernate中使用JPA注解映射配置5.1 编写主配置文件(hibernate.cfg.xml)1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!-- 在类的根路径下创建名称为hibernate.cfg.xml的配置文件导入约束：dtd约束 --&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory SessionFactory的作用就是用于创建Session对象的。 Session对象就是hibernate中操作数据库的核心对象。 此处的配置不要求背，但是要求记住创建SessionFactory必须的三部分信息 第一部分： 连接数据库的信息 第二部分： hibernate的可选配置 第三部分： 映射文件的位置 --&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider &lt;&#x2F;property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping class&#x3D;&quot;com.wgy.domain.Customer&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 5.2 编写实体类并使用JPA注解配置123456789101112131415161718192021222324252627282930313233/** * 客户实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name=\"cust_id\") @GeneratedValue(strategy=GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 5.2 操作5.2.1 保存12345678910111213/** * 保存 */@Testpublic void test1() &#123; Customer c = new Customer(); c.setCustName(\"hibernate jpa customer\"); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); s.save(c); tx.commit();&#125; 5.2.2 查询1234567891011/** * 查询一个 */@Testpublic void test2() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); System.out.println(c); tx.commit();&#125; 5.2.3 修改1234567891011/** * 修改 */@Testpublic void test3() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); c.setCustAddress(\"顺义区\"); tx.commit();&#125; 5.2.4 删除1234567891011/** * 删除操作 */@Testpublic void test4() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); s.delete(c); tx.commit();&#125;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(三)","date":"2020-05-31T08:27:38.000Z","path":"archives/3e87eb50.html","text":"1. 多表设计1.1 表之间的关系划分 一对一 一对多（多对一） 多对多 2. 如何确立和实现数据库中的表关系2.1 一对多的表关系在数据库中如何实现?使用外键约束。我们一般习惯把一的方称为主表，把多的一方称为从表。 什么是外键： 从表中有一列，该列的取值除了null之外，只能来源于主表的主键。默认情况下，外键字段的值是可以重复的。 2.2 多对多的表关系在数据库中如何实现？使用中间表。中间表中只有两个外键，引用两个多对多表的主键。不能有其他字段信息，至于中间表的主键，应该采用联合主键。 任何一个多方的表和中间表去比较，都是一对多的关系。 2.3 一对一的表关系在数据库中如何实现？有两种： 第一种：建立外键的方式： 使用外键约束，唯一约束，非空约束。它是把外键字段加了非空和唯一约束。从而实现了一对一。 第二种：使用主键的方式： 让其中一张表既是主键，又是外键。 2.4 如何确立两张表之间的关系：找外键。 3. 学习多表映射配置要遵循的步骤 第一步：确定两张表之间的关系 第二步：在数据库中实现两张表之间的关系建立 第三步：在实体类中描述出两个实体之间的关系 第四步：在映射配置文件中建立两个实体和两张表之间的关系 4. 一对多关系映射配置示例：客户和联系人两张表 4.1 确定两张表之间的关系一个客户可以包含多个联系人，多个联系人可以属于同一个客户。所以：客户和联系人之间的关系是一对多。 4.2 在数据库中实现两张表之间的关系建立实现一对多的关系，靠外键。客户表是主表，联系人表是从表。我们需要在联系人表中添加外键。 4.3 在实体类中描述出两个实体之间的关系主表的实体类应该包含从表实体类的集合引用，从表的实体类应该包含主表实体类的对象引用 123456789101112131415161718192021/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; /** * 一对多关系映射：一的一方 * 主表实体应该包含从表实体的集合引用 */ private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); ...&#125; 1234567891011121314151617181920212223/** * 联系人的实体类 * * @author wgy */public class LinkMan implements Serializable &#123; private Long lkmId; private String lkmName; private String lkmGender; private String lkmPhone; private String lkmMobile; private String lkmEmail; private String lkmPosition; private String lkmMemo; /** * 一对多关系映射，多的一方。 * 从表实体包含主表实体的对象引用 */ private Customer customer; ...&#125; 4.4 在映射配置文件中建立两个实体和两张表之间的关系客户配置文件： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml导入约束：dtd约束 --&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot; lazy&#x3D;&quot;true&quot;&gt; &lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&#x2F;&gt; &lt;!-- 一对多关系映射：主表实体的映射配置 涉及的标签： set： 作用：用于配置set集合属性。 属性： name：指定实体类中set集合的属性名称。 table：指定从表的名称。在一对多配置时可以不写。 key: 作用：用于映射外键字段。 属性： column：指定外键字段名称 one-to-many: 作用：用于建立一对多的映射配置 属性： class：用于指定从表实体的名称 --&gt; &lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 联系人配置文件： 1234567891011121314151617181920212223242526272829&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;LinkMan&quot; table&#x3D;&quot;cst_linkman&quot;&gt; &lt;id name&#x3D;&quot;lkmId&quot; column&#x3D;&quot;lkm_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;lkmName&quot; column&#x3D;&quot;lkm_name&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmGender&quot; column&#x3D;&quot;lkm_gender&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmPhone&quot; column&#x3D;&quot;lkm_phone&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmMobile&quot; column&#x3D;&quot;lkm_mobile&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmEmail&quot; column&#x3D;&quot;lkm_email&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmPosition&quot; column&#x3D;&quot;lkm_position&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmMemo&quot; column&#x3D;&quot;lkm_memo&quot;&#x2F;&gt; &lt;!-- 一对多关系映射：从表实体的映射配置 涉及的标签： many-to-one： 作用：建立多对一的映射配置 属性： name：从表实体中引用主表实体对象引用的名称 class：指定属性所对应的实体类名称 column：指定从表中外键字段的名称 --&gt; &lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 5. 多对多关系映射配置示例：用户和角色 5.1 确定两张表之间的关系一个用户可以有多个角色，一个角色可以赋给多个用户，所以用户和角色之间是多对多。 5.2 在数据库中实现两张表之间的关系建立在数据库中实现多对多要靠中间表。中间表中只能出现用户和角色主键。 5.3 在实体类中描述出两个实体之间的关系各自包含对方一个集合引用 12345678910111213141516/** * 用户的实体类 * * @author wgy */public class SysUser implements Serializable &#123; private Long userId; private String userName; private String userPassword; private Integer userState; //多对多关系映射：一个用户可以具备多个角色 private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); ...&#125; 123456789101112131415/** * 角色的实体类 * * @author wgy */public class SysRole implements Serializable &#123; private Long roleId; private String roleName; private String roleMemo; //多对多关系映射：一个角色可以赋予多个用户 private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); ...&#125; 5.4 在映射配置文件中建立两个实体和两张表之间的关系用户配置文件： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;SysUser&quot; table&#x3D;&quot;sys_user&quot;&gt; &lt;id name&#x3D;&quot;userId&quot; column&#x3D;&quot;user_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;userName&quot; column&#x3D;&quot;user_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;userPassword&quot; column&#x3D;&quot;user_password&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;userState&quot; column&#x3D;&quot;user_state&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 多对多关系映射 涉及的标签： set: 作用：用于映射set集合属性 属性： name：指定集合的名称 table：指定的是中间表的名称 key: 作用：用于映射外键字段 属性： column：指定的是当前实体在中间表的外键字段名称 many-to-many 作用：用于映射多对多的关系 属性： class：对方的实体类名称 column：对方在中间表的外键字段名称 --&gt; &lt;set name&#x3D;&quot;roles&quot; table&#x3D;&quot;user_role_ref&quot;&gt; &lt;key column&#x3D;&quot;user_id&quot;&gt;&lt;&#x2F;key&gt; &lt;many-to-many class&#x3D;&quot;SysRole&quot; column&#x3D;&quot;role_id&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 角色配置文件： 12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;SysRole&quot; table&#x3D;&quot;sys_role&quot;&gt; &lt;id name&#x3D;&quot;roleId&quot; column&#x3D;&quot;role_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;roleName&quot; column&#x3D;&quot;role_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;roleMemo&quot; column&#x3D;&quot;role_memo&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 多对多关系映射 --&gt; &lt;set name&#x3D;&quot;users&quot; table&#x3D;&quot;user_role_ref&quot; inverse&#x3D;&quot;true&quot;&gt; &lt;key column&#x3D;&quot;role_id&quot;&gt;&lt;&#x2F;key&gt; &lt;many-to-many class&#x3D;&quot;SysUser&quot; column&#x3D;&quot;user_id&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 6. 多表增删改操作6.1 一对多关系的操作6.1.1 保存操作6.1.1.1 正常保存12345678910111213141516171819/** * 保存操作 * 正常的保存：创建一个新的联系人，需要关联一个客户 */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c1 = s.get(Customer.class, 1L); //2.创建一个新的联系人 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人\"); //3.建立客户和联系人的关联关系（让联系人知道属于哪个客户即可） l.setCustomer(c1); //4.保存联系人 s.save(l); tx.commit();&#125; 6.1.1.2 特殊情况1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 特殊的情况： * 创建一个客户和一个联系人 * 建立联系人和客户的双向关联关系 * 使用符合原则的保存 * 原则是：先保存主表实体，再保存从表实体 * * 此时保存会有问题： * 我们保存两个实体，应该只有两条insert语句。 * 而执行结果却是多了一条update的语句。 * * 解决办法： * 让客户在执行操作的时候，放弃维护关联关系的权利。 * 配置的方式： * 在Customer的映射配置文件中的set标签上使用inverse属性。 * inverse含义：是否放弃维护关联关系的权利 * true：放弃 * false：不放弃（默认值） * */@Testpublic void test2()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_4\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_4\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 //持久态 有一级缓存和快照 s.save(c1); //持久态 有一级缓存和快照 s.save(l); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 6.1.1.3 级联保存级联操作是指当主控方执行保存、更新或者删除操作时，其关联对象（被控方）也执行相同的操作。 保存客户 123456789101112131415161718192021222324252627282930/** * 保存操作： * 级联保存 * 使用级联保存，配置的方式，仍然是找到Customer的映射配置文件的Set标签， * 也可以配置在many-to-one上。 * 在上面加入cascade属性 * cascade：配置级联操作 * 级联保存更新的取值：save-update */@Testpublic void test3()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_5\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_5\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 s.save(c1); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 保存联系人 123456789101112131415161718192021@Testpublic void test4()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_6\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_6\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 s.save(l); tx.commit();&#125; 1&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot;&#x2F;&gt; 6.1.2 更新操作123456789101112131415161718192021222324/** * 更新操作 * 需求： * 创建一个新的联系人，查询一个已有客户 * 联系人新联系人和已有客户的双向关联关系 * 更新客户 */@Testpublic void test5()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c1 = s.get(Customer.class, 1L); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人\"); //3.建立客户和联系人的关联关系（双向） l.setCustomer(c1); c1.getLinkmans().add(l); //4.更新客户 s.update(c1); tx.commit();&#125; 6.1.3 删除操作123456789101112131415161718192021/** * 删除操作 * 删除从表数据就是单表 * 删除主表数据： * 看有没有从表数据引用 * 有引用： * 在删除是，hibernate会把从表中的外键字段置为null，然后再删除主表数据。 * 如果外键字段有非空约束，则hibernate不能更新外键字段为null，会报错。 * 如果仍然想删除，此时需要使用级联删除。同时必须配置inverse属性是true。 * 没有引用： 就是单表，直接删 */@Testpublic void test6()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c9 = s.get(Customer.class, 5L); //2.删除id为5的客户 s.delete(c9); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update,delete&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 6.2 多对多关系的操作6.2.1 保存操作12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 保存操作 * 需求： * 创建2个用户和3个角色 * 让1号用户具备1号和2号角色 * 让2号用户具备2号和3号角色 * 保存用户和角色 */@Testpublic void test1()&#123; SysUser u1 = new SysUser(); u1.setUserName(\"用户1\"); SysUser u2 = new SysUser(); u2.setUserName(\"用户2\"); SysRole r1 = new SysRole(); r1.setRoleName(\"角色1\"); SysRole r2 = new SysRole(); r2.setRoleName(\"角色2\"); SysRole r3 = new SysRole(); r3.setRoleName(\"角色3\"); //建立双向关联关系 //先建立用户的 u1.getRoles().add(r1); u1.getRoles().add(r2); u2.getRoles().add(r2); u2.getRoles().add(r3); //再建立角色 r1.getUsers().add(u1); r2.getUsers().add(u1); r2.getUsers().add(u2); r3.getUsers().add(u2); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); s.save(u1); s.save(u2); s.save(r1); s.save(r2); s.save(r3); tx.commit();&#125; 6.2.2 删除操作12345678910111213141516/** * 删除操作 * 实际开发中：多对多的双向级联删除是禁止使用的 */@Testpublic void test2()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1查询id为3的用户 SysUser u3 = s.get(SysUser.class, 3L); //删除 s.delete(u3); tx.commit();&#125; 7. Hibernate中的多表查询7.1 对象导航查询7.1.1 概述对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。 例如：我们通过OID查询方式查出一个客户，可以调用Customer类中的getLinkMans()方法来获取该客户的所有联系人。 对象导航查询的使用要求是：两个对象之间必须存在关联关系。 7.1.2 对象导航检索示例查询联系人 123456789101112131415/** * 查询id为1的客户下所属联系人 * 一对多时，根据一的一方查询多的一方时，需要使用延迟加载。（默认配置即可） */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //查询id为1的客户 Customer c = s.get(Customer.class, 1L); System.out.println(c); Set&lt;LinkMan&gt; linkmans = c.getLinkmans(); System.out.println(linkmans); tx.commit();&#125; 查询客户 12345678910111213141516171819/** * 查询id为5的联系人属于哪个客户 * 多对一时，根据多的一方查询一的一方时，不需要使用延迟加载，而是使用立即加载，需要配置一下 * 需要找到联系人的映射配置文件：在many-to-one标签上使用lazy属性。 * 取值有： * false：使用立即加载。 * proxy：是看load方法是延迟加载还是立即加载 * no-proxy：不管 */@Testpublic void test2()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); LinkMan l = s.get(LinkMan.class, 5L); System.out.println(l); Customer c = l.getCustomer(); System.out.println(c); tx.commit();&#125; 1&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot; lazy&#x3D;&quot;false&quot;&#x2F;&gt; load方法加载 1234567891011121314/** * 关于load方法改为立即加载的方式 * 找到查询实体的映射配置文件，它的class标签上也有一个lazy属性。含义是：是否延迟加载 * true：延迟加载(默认值) * false：立即加载 */@Testpublic void test3()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.load(Customer.class, 1L); System.out.println(c); tx.commit();&#125; class标签的lazy：它只能管load方法是否是延迟加载。 set标签的lazy：它管查询关联的集合对象是否是延迟加载。 many-to-one的lazy：它管查询关联的主表实体是否是立即加载。","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(二)","date":"2020-05-28T16:09:27.000Z","path":"archives/4074cb7b.html","text":"1. Hibernate的持久化类和对象标识符1.1 持久化类的编写规范1.1.1 什么是持久化类Hibernate是持久层的ORM映射框架，专注于数据的持久化工作。 持久化就是将内存中的数据永久存储到关系型数据库中。 持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为是持久化类。其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。 1.1.2 持久化类的编写规范应该遵循JavaBean的编写规范: Bean：在软件开发中是指的可重用的组件。 JavaBean：指的是用java语言编写的可重用组件。在我们的实际项目中：domain,service,dao都可以看成是JavaBean。 编写规范： 类都是public的 一般实现序列化接口 类成员（字段）都是私有的 私有类成员都有公有get/set方法 类都有默认无参构造函数 细节： 数据类型的选择问题： 基本类型和包装类，选择哪个？由于包装类可以有null值。所以实际开发中都是用包装类。 1.2 Hibernate中对象标识符（OID）OID全称是Object Identifier，又叫做对象标识符。 它是hibernate用于区分两个对象是否是同一个对象的标识。 我们都知道，虚拟机内存区分两个对象看的是内存的地址是否一致。数据库区分两个对象，靠的是表的主键。Hibernate负责把内存中的对象持久化到数据库表中，靠的就是对象标识符来区分两个对象是否是同一个。实体类中映射主键的字段就是OID，如下图所示： 1.3 Hibernate的主键生成策略 2. Hibernate的一级缓存和对象状态2.1 Hibernate的一级缓存什么缓存？ 它就是内存中的临时数据。 什么样的数据适用于缓存，什么样的数据不适用缓存？ 适用缓存的数据： 经常查询的，并且不经常修改的。同时数据一旦出现问题，对最终结果影响不大的。 不适用缓存的数据： 不管是否经常查询，只要是经常修改的，都可以不用缓存。并且如果数据由于使用缓存，产生了异常数据，对最终结果影响很大，则不能使用。例如：股市的牌价，银行的汇率，商品的库存等等。 2.1.1 Hibernate中的一级缓存Hibernate的一级缓存就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。Hibernate的一级缓存的作用就是减少对数据库的访问次数。 在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存。只要 Session 实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。 Hibernate的一级缓存有如下特点： 当应用程序调用Session接口的save()、update()、saveOrUpdate时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。 当调用Session接口的load()、get()方法，以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中。 当调用Session的close()方法时，Session缓存会被清空。 2.1.2 测试一级缓存123456789101112131415161718192021/** * 证明一级缓存确实存在 */@Testpublic void test1() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //1.根据id查询客户 //先去数据库查询，并且把查询的结果存入了一级缓存之中 Customer c1 = s.get(Customer.class, 1L); System.out.println(c1); //2.根据id再次查询客户 //先去一级缓存中看看有没有，如果有的话，直接拿过来用，如果没有的话，再去查询。 Customer c2 = s.get(Customer.class, 1L); System.out.println(c2); //true 一级缓存缓存的是对象的地址 System.out.println(c1 == c2); tx.commit(); //session关闭，一级缓存就消失了 s.close();&#125; 2.1.3 快照机制Hibernate 向一级缓存放入数据时，同时复制一份数据放入到Hibernate快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。 1234567891011121314151617181920212223@Testpublic void test2() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //1.根据id查询客户 Customer c5 = s.get(Customer.class, 2L); //输出客户的地址：北京市顺义区 System.out.println(c5.getCustAddress()); //2.修改客户的地址为 湖北省 c5.setCustAddress(\"湖北省\"); //输出客户的地址：湖北省 System.out.println(c5.getCustAddress()); //没有写update语句 tx.commit(); //session关闭，一级缓存就消失了 s.close(); //打印c5的address，这个c5能不能用 答案是可以使用。 //此时输出是什么 北京市顺义区 | 湖北省 System.out.println(c5.getCustAddress());&#125; 2.2 对象的状态2.2.1 对象的状态说明Hibernate为了更好的来管理持久化类，特将持久化类分成了三种状态。在Hibernate中持久化的对象可以划分为四种状态，分别是瞬时态、持久态、脱管态和删除状态，一个持久化类的实例可能处于四种不同状态中的某一种，四种状态的详细介绍如下。 瞬时态（transient） 瞬时态也称为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，不存在持久化标识OID（相当于主键值），尚未与Hibernate Session关联，在数据库中也没有记录，失去引用后将被JVM回收。瞬时状态的对象在内存中是孤立存在的，与数据库中的数据无任何关联，仅是一个信息携带的载体。 持久态（persistent） 持久态的对象存在持久化标识OID ，加入到了Session缓存中，并且相关联的Session没有关闭，在数据库中有对应的记录，每条记录只对应唯一的持久化对象，需要注意的是，持久态对象是在事务还未提交前变成持久态的。 脱管态（detached） 脱管态也称离线态或者游离态，当某个持久化状态的实例与Session的关联被关闭时就变成了脱管态。脱管态对象存在持久化标识OID，并且仍然与数据库中的数据存在关联，只是失去了与当前Session的关联，脱管状态对象发生改变时Hibernate不能检测到。 删除状态（了解） 2.2.2 学习对象状态我们要明确的 是为了更好的掌握hibernate中操作的方法。 区分状态只有两个标识：一是否有OID，二是否和Session建立的关系 瞬时状态（临时状态） 标志：没有OID，和Session没有关系。 持久化状态 标志：有OID，和Session有关系。只有持久化状态的对象才会有一级缓存的概念。 脱管状态（游离状态） 标志：有OID，和Session没有关系。 删除状态（了解）： 标志：有OID，和Session有关系。同时已经调用了删除方法，即将从数据库中把记录删除。但是事务还没有提交，此时的对象状态是删除态。 1234567891011@Testpublic void test2() &#123; //瞬时状态 Customer c = new Customer(); c.setCustName(\"测试_saveOrUpdate\"); Session s1 = HibernateUtil.openSession(); Transaction tx1 = s1.beginTransaction(); s1.saveOrUpdate(c); tx1.commit(); s1.close();&#125; 1234567891011121314151617181920@Testpublic void test3() &#123; Session s1 = HibernateUtil.openSession(); Transaction tx1 = s1.beginTransaction(); //持久化状态 Customer c = s1.get(Customer.class, 9L); tx1.commit(); s1.close(); c.setCustAddress(\"顺义校区\"); //脱管状态 System.out.println(c); Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); //持久化状态 session.saveOrUpdate(c); tx.commit(); session.close();&#125; 3. Hibernate的事务控制3.1 配置Session和线程绑定保证在Service中开启的事务时使用的Session对象和DAO中多个操作使用的是同一个Session对象。 在hibernate.cfg.xml文件中配置 12&lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt;&lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; 获取Session时使用的方法 1234567891011121314151617181920212223242526272829/** * 抽取hibernate的工具类 * * @author wgy */public class HibernateUtil &#123; private static SessionFactory factory; //了解：hibernate把可以预见的异常都转成了运行时异常 static &#123; try &#123; Configuration configuration = new Configuration(); configuration.configure(); factory = configuration.buildSessionFactory(); &#125; catch (ExceptionInInitializerError e) &#123; throw new ExceptionInInitializerError(\"初始化SessionFactory失败,请检查配置文件\"); &#125; &#125; /** * 从当前线程上获取Session对象 * @return session */ public static Session getCurrentSession()&#123; //只有配置了把session和线程绑定之后，才能使用此方法，否则返回值是null return factory.getCurrentSession(); &#125;&#125; 验证session和线程绑定的配置 12345678910111213141516171819202122@Testpublic void test1() &#123; Session s1 = HibernateUtil.getCurrentSession(); Session s2 = HibernateUtil.getCurrentSession(); // true System.out.println(s1 == s2);&#125;/** * 当我们把session和线程绑定之后，hibernate就会在提交或者回滚事务之后，自动帮我们关闭session */@Testpublic void test2() &#123; //瞬时状态 Customer c = new Customer(); c.setCustName(\"测试_getCurrentSession\"); Session s1 = HibernateUtil.getCurrentSession(); Transaction tx1 = s1.beginTransaction(); s1.saveOrUpdate(c); tx1.commit(); //s1.close();&#125; 4. Hibernate中的查询方式hibernate中一共有5种查询方式 OID查询： 根据id查询一个实体。涉及的方法：get和load SQL查询： 使用SQL语句查询数据库。涉及两种方式： 第一种：SQLQuery（一般不怎么用） 1234567891011121314151617@Testpublic void testFindAll() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //使用session对象，获取一个查询对象Query SQLQuery sqlquery = s.createSQLQuery(\"select * from cst_customer\"); //使用sqlquery对象获取结果集 List&lt;Object[]&gt; list = sqlquery.list(); for (Object[] os : list) &#123; System.out.println(\"------------数组中的内容-----------\"); for (Object o : os) &#123; System.out.println(o); &#125; &#125; tx.commit(); s.close();&#125; 第二种：session的doWork方法，它可以拿到Connection 1234567891011121314151617181920/** * hibernate中如何使用原始JDBC API * JDBC的API： * Connection * Statement * PreparedStatement * ResultSet */@Testpublic void test1() &#123; //1.获取Session对象 Session s = HibernateUtil.openSession(); //2.调用doWork方法 s.doWork(new Work() &#123; @Override public void execute(Connection conn) throws SQLException &#123; System.out.println(conn.getClass().getName()); &#125; &#125;);&#125; HQL查询： 使用HQL语句查询数据库 QBC查询： 使用Criteria对象查询数据库 对象导航查询： 对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。 5. Hibernate查询对象的API5.1 Query5.1.1 概述Query代表面向对象的一个Hibernate查询操作。 在Hibernate中，通常使用session.createQuery()方法接受一个HQL语句，然后调用Query的list()或uniqueResult()方法执行查询。 所谓的HQL是Hibernate Query Language缩写，其语法很像SQL语法，但它是完全面向对象的。 在Hibernate中使用Query对象的步骤，具体所示： 获得Hibernate的Session对象 编写HQL语句 调用session.createQuery 创建查询对象 如果HQL语句包含参数，则调用Query的setXxx设置参数 调用Query对象的方法执行查询 HQL的说明： ​ 把表的名称换成实体类名称。把表字段名称换成实体类属性名称。 例如： 12345SQL：select * from cst_customer where cust_name like ?HQL：select * from Customer where custName &#x3D; ?其中select * 可以省略，写为：from Customer where custName &#x3D; ? 5.1.2 常用查询5.1.2.1 基本查询12345678910111213141516/** * 基本查询 */@Testpublic void test1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.2 条件查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 条件查询 */@Testpublic void test2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer where custLevel = ? and custName like ?\"); //给参数占位符赋值 //hibernate的参数占位符是从0开始的 query.setString(0, \"23\"); query.setString(1, \"%集%\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125;/** * 条件查询 * 给参数占位符提供一个具体的名称 * 参数占位符的写法： * :名称 * 赋值的时候不需要写冒号，直接写名称 */@Testpublic void test3()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.获取Query对象 Query query = s.createQuery(\"from Customer where custName like :custName and custLevel = :custLevel\"); //2.给参数占位符赋值 //query.setString(\"custName\", \"%集%\"); //query.setString(\"custLevel\", \"普通客户\"); query.setParameter(\"custLevel\", \"23\"); query.setParameter(\"custName\", \"%集%\"); //3.执行对象的方法，获取结果集 List list = query.list(); for(Object o : list)&#123; System.out.println(o); &#125; tx.commit();&#125; 5.1.2.3 分页查询123456789101112131415161718192021222324252627282930/** * 分页查询 * mysql分页关键字 * limit * Limit的两个参数含义 * 第一个：查询的开始记录索引 * 第二个：每次查询的条数 * hibernate为我们提供了两个方法： * setFirstResult：设置查询的开始记录索引 * setMaxResults：设置每次查询的条数 * * 不管是用什么数据库，涉及分页的都是这两个方法。 * 因为SQL语句的生成已经是hibernate的事了。 */@Testpublic void test5() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer\"); //设置分页的方法 query.setFirstResult(2); query.setMaxResults(2); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.4 排序查询12345678910111213141516/** * 排序查询 */@Testpublic void test4() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer order by custId desc\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.5 统计查询12345678910111213141516171819202122232425/** * HQL使用聚合函数： * 统计查询 * 聚合函数： * count sum max min avg * * sql语句使用聚合函数时，在不使用group by子句的情况下，返回的结果，永远只有一行一列的情况。 * * 在SQL语句时： * select count(*) from table 它是统计所有字段，效率没有只统计主键字段高 * select count(主键) from table 它和第一个的结果是一样的，但是效率更高 * select count(非主键) from table 只统计不为null的字段 */@Testpublic void test1()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.获取Query对象 Query query = s.createQuery(\"select count(*) from Customer\"); //2.获取结果集 //当返回的结果唯一时，可以使用此方法。如果返回的结果不唯一，使用了此方法会抛异常。 Long total = (Long)query.uniqueResult(); System.out.println(total); tx.commit();&#125; 5.1.2.6 投影查询12345678910111213141516171819202122/** * 投影查询 * 当我们在查询实体时，只需要部分字段，而是全部。并且希望它的返回结果使用实体类来封装，而不是Object[] * 这个时候我们称之为创建实体类的投影 * * 投影查询的用法： * 1.查询语句需要时使用new关键字 * 2.在实体类中添加对应参数列表的构造函数 */@Testpublic void test7() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"select new com.wgy.domain.Customer(custId,custName) from Customer\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 123456789101112131415161718192021222324252627/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; public Customer() &#123; &#125; /** * //提供对应参数列表的构造函数 * @param custId * @param custName */ public Customer(Long custId, String custName) &#123; this.custId = custId; this.custName = custName; &#125; ..... 5.1.3 Query中的方法说明 list方法：该方法用于查询语句，返回的结果是一个list集合。 uniqueResult方法：该方法用于查询，返回的结果是一个Object对象。 setter方法：Query接口中提供了一系列的setter方法用于设置查询语句中的参数，针对不同的数据类型，需要用到不同的setter方法。 uniqueResult()方法：该方法用于返回唯一的结果，在确保只有一条记录的查询时可以使用该方法。 setFirstResult()方法：该方法可以设置获取第一个记录的位置，也就是它表示从第几条记录开始查询，默认从0开始计算。 setMaxResult()方法：该方法用于设置结果集的最大记录数，通常与setFirstResult()方法结合使用，用于限制结果集的范围，以实现分页功能。 5.2 Criteria5.2.1 概述Criteria是一个完全面向对象，可扩展的条件查询API，通过它完全不需要考虑数据库底层如何实现，以及SQL语句如何编写，它是Hibernate框架的核心查询对象。 Criteria 查询，又称为QBC查询（Query By Criteria），它是Hibernate的另一种对象检索方式。 通常，使用Criteria对象查询数据的主要步骤，具体如下： 获得Hibernate的Session对象 通过Session获得Criteria对象 使用Restrictions的静态方法创建Criterion条件对象。Restrictions类中提供了一系列用于设定查询条件的静态方法，这些静态方法都返回Criterion实例，每个Criterion实例代表一个查询条件 向Criteria对象中添加Criterion 查询条件。Criteria的add()方法用于加入查询条件 执行Criterita的 list() 或uniqueResult() 获得结果 细节： HQL能查的，QBC都能查，反之亦然。 5.2.2 常用查询5.2.2.1 基本查询1234567891011121314151617/** * 基本查询 */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 //它就相当于HQL的from Customer Criteria c = s.createCriteria(Customer.class); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.2 条件查询12345678910111213141516171819/** * 条件查询 */@Testpublic void test2() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //使用criteria对象的add方法来添加条件 c.add(Restrictions.eq(\"custLevel\", \"23\")); c.add(Restrictions.like(\"custName\", \"%集%\")); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.3 分页查询1234567891011121314151617181920/** * 分页查询 * QBC的分页查询和HQL的分页查询所用的方法和方法的含义都是一模一样的 */@Testpublic void test4() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //设置分页条件 c.setFirstResult(2); c.setMaxResults(2); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.4 排序查询123456789101112131415161718/** * 排序查询 */@Testpublic void test3() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //添加排序 c.addOrder(Order.desc(\"custId\")); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.5 统计查询1234567891011121314151617/** * 统计（投影）查询 */@Testpublic void test5() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //设置聚合函数 //c.setProjection(Projections.rowCount()); c.setProjection(Projections.count(\"custId\")); //2. 获取结果集 Long count = (Long)c.uniqueResult(); System.out.println(count); tx.commit();&#125; 5.2.2.6 离线查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 离线查询 * 离线： * 它是和在线对应的。 * Criteria对象是一个在线对象，它是由一个可用的（活动的）Session对象获取的出来的。 * 当session失效时，就无法再获取该对象了。 * 有一个对象，它也可以用于设置条件，但是获取的时候并不需要Session对象。该对象就叫做离线对象： * DetachedCriteria对象 * 使用该对象进行的查询就叫做：离线查询 * * 如何获取该对象 * DetachedCriteria dCriteria = DetachedCriteria.forClass(要查询的实体类字节码); */@Testpublic void testServlet()&#123; //1.获取离线对象，不需要Session DetachedCriteria dc = DetachedCriteria.forClass(Customer.class); //2.封装查询条件 dc.add(Restrictions.eq(\"custLevel\", \"23\")); dc.add(Restrictions.like(\"custName\",\"%集%\")); List list = testService(dc); for(Object o : list)&#123; System.out.println(o); &#125;&#125;private List testService(DetachedCriteria dc) &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); List list = testDao(dc); tx.commit(); return list; &#125;catch(Exception e)&#123; tx.rollback(); &#125; return null;&#125;private List testDao(DetachedCriteria dc) &#123; Session s = HibernateUtil.getCurrentSession(); //把离线对象转成在线对象 Criteria c = dc.getExecutableCriteria(s); return c.list();&#125; 5.2.3 QBC常用查询条件说明 短语 含义 Restrictions.eq 等于= Restrictions.allEq 使用Map,使用key/value进行多个等于的判断 Restrictions.gt 大于&gt; Restrictions.ge 大于等于&gt;= Restrictions.lt 小于&lt; Restrictions.le 小于等于&lt;= Restrictions.between 对应sql的between子句 Restrictions.like 对应sql的like子句 Restrictions.in 对应sql的in子句 Restrictions.and and 关系 Restrictions.or or关系 Restrictions.sqlRestriction Sql限定查询 Restrictions.asc() 根据传入的字段进行升序排序 Restrictions.desc() 根据传入的字段进行降序排序 运算类型 HQL运算符 QBC运算方法 type = Restrictions.eq() Restrictions.not(Restrictions.eq()) >= Restrictions.ge()","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(一)","date":"2020-05-28T06:17:43.000Z","path":"archives/ef455019.html","text":"1. Hibernate和ORM的概念1.1 Hibrenate概述它是一个轻量级，企业级，开源的ORM持久层框架。是可以操作数据库的框架。 框架：它就是一个架构。 通常情况下，软件工程的持久层解决方案，一个为主一个为辅。两者并存（写SQL语句的和不写SQL语句的 轻量级：指的是使用时依赖的资源很少。（目前我们使用的阶段，只依赖log4j，c3p0连接池） 企业级：指的是在企业级应用中使用的比较多 开源的：开放源代码。 ORM的操作方式：建立对象关系映射，实现操作实体类就相当于操作数据库表。 Hibernate框架是当今主流的Java持久层框架之一，由于它具有简单易学、灵活性强、扩展性强等特点，能够大大地简化程序的代码量，提高工作效率，因此受到广大开发人员的喜爱。 Hibernate是一个开放源代码的ORM框架，它对JDBC进行了轻量级的对象封装，使得Java开发人员可以使用面向对象的编程思想来操作数据库。 1.2 ORMObject Relational Mapping 对象关系映射 就是建立实体类和数据库表的对应关系。 实现操作实体类对象就相当于操作数据库表 Object Relation Mapping 对象关系映射。 对象-关系映射（OBJECT/RELATIONALMAPPING，简称ORM），是随着面向对象的软件开发方法发展而产生的。用来把对象模型表示的对象映射到基于S Q L 的关系模型数据库结构中去。这样，我们在具体的操作实体对象的时候，就不需要再去和复杂的 SQ L 语句打交道，只需简单的操作实体对象的属性和方法[2] 。O R M 技术是在对象和关系之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化[1] 。 简单的说就是把我们程序中的实体类和数据库表建立起来对应关系。 1.3 为什么要学习Hibernate与其它操作数据库的技术相比，Hibernate具有以下几点优势： Hibernate对JDBC访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了DAO（Data Access Object，数据访问对象）层编码工作。 Hibernate的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。 可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。 明确： ​ 操作实体类就相当于操作数据库表 使用传统的JDBC开发应用系统时，如果是小型应用系统，并不觉得有什么麻烦，但是对于大型应用系统的开发，使用JDBC就会显得力不从心。例如对几十、几百张包含几十个字段的表进行插入操作时，编写的SQL语句不但很长，而且繁琐，容易出错；在读取数据时，需要写多条getXxx语句从结果集中取出各个字段的信息，不但枯燥重复，并且工作量非常大。为了提高数据访问层的编程效率，Gavin King开发出了一个当今最流行的的ORM框架，它就是Hibernate框架。 所谓的ORM就是利用描述对象和数据库表之间映射的元数据，自动把Java应用程序中的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库表的操作。可以把ORM理解为关系型数据和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。ORM原理如图所示。 2. CRMCRM：客户关系管理系统 CRM（Customer Relationship Management）客户关系管理，是利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，向客户提供创新式的个性化的客户交互和服务的过程。 其最终目标是将面向客户的各项信息和活动集成起来，组建一个以客户为中心的企业，实现对面向客户的活动的全面管理。 3. Hibernate快速入门3.1 需求介绍保存一个客户到数据库的客户表中。 3.2 搭建Hibernate开发环境3.2.1 第一步：拷贝必备的jar包到开发目录数据库驱动包，如下图： Hibernate/lib/required/*.jar，如下图： 日志记录的包，如下图: 3.2.2 第二步：创建数据库和实体类持久化类是应用程序中的业务实体类，这里的持久化是指类的对象能够被持久化保存到数据库中。Hibernate使用普通Java对象（Plain Old Java Object），即POJO的编程模式来进行持久化。POJO类中包含的是与数据库表相对应的各个属性，这些属性通过getter和setter方法来访问，对外部隐藏了内部的实现细节。下面就来编写Customer持久化类。 在项目src目录下，创建cn.wgy.domain包，并在包中创建实体类Customer（对应数据库表cst_customer），Customer类包含与cst_customer数据表字段对应的属性，以及相应的getXxx ()和setXxx ()方法。 1234567891011&#x2F;*创建客户表*&#x2F;CREATE TABLE &#96;cst_customer&#96; ( &#96;cust_id&#96; bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#39;客户编号(主键)&#39;, &#96;cust_name&#96; varchar(32) NOT NULL COMMENT &#39;客户名称(公司名称)&#39;, &#96;cust_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户信息来源&#39;, &#96;cust_industry&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户所属行业&#39;, &#96;cust_level&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户级别&#39;, &#96;cust_address&#96; varchar(128) DEFAULT NULL COMMENT &#39;客户联系地址&#39;, &#96;cust_phone&#96; varchar(64) DEFAULT NULL COMMENT &#39;客户联系电话&#39;, PRIMARY KEY (&#96;cust_id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;94 DEFAULT CHARSET&#x3D;utf8; 123456789101112131415/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; ...&#125; 3.2.3 第三步：编写映射配置文件（xml）实体类Customer目前还不具备持久化操作的能力，而Hibernate需要知道实体类Customer映射到数据库Hibernate中的哪个表，以及类中的哪个属性对应数据库表中的哪个字段，这些都需要在映射文件中配置。 在实体类Customer所在的包中，创建一个名称为Customer.hbm.xml的映射文件，在该文件中定义了实体类Customer的属性是如何映射到cst_customer表的列上的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml --&gt;&lt;!-- 导入约束:dtd约束 位置：在Hibernate的核心jar包中名称为hibernate-mapping-3.0.dtd 明确该文件中的内容： 实体类和表的对应关系 实体类中属性和表的字段的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;!-- package属性用于设定包的名称，接下来该配置文件中凡是用到此包中的对象时都可以省略包名 --&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;!-- class标签 作用：建立实体类和表的对应关系 属性： name：指定实体类的名称 table：指定数据库表的名称 --&gt; &lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot;&gt; &lt;!-- id标签 作用：用于映射主键 属性： name：指定的是属性名称。也就是get&#x2F;set方法后面的部分，并且首字母要转小写。 column:指定的是数据库表的字段名称 --&gt; &lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt; &lt;!-- generator标签： 作用：配置主键的生成策略。 属性： class:指定生成方式的取值。 取值之一：native。使用本地数据库的自动增长能力。 mysql数据库的自动增长能力是让某一列自动+1。但是不是所有数据库都支持这种方式。 --&gt; &lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;!-- property标签： 作用：映射其他字段 属性： name：指定属性的名称。和id标签的name属性含义一致 column：指定数据库表的字段名称 --&gt; &lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 3.2.4 第四步：编写主配置文件（hibernate.cfg.xml）Hibernate的映射文件反映了持久化类和数据库表的映射信息，而Hibernate的配置文件则主要用来配置数据库连接以及Hibernate运行时所需要的各个属性的值。在项目的src下创建一个名称为hibernate.cfg.xml的文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 在类的根路径下创建名称为hibernate.cfg.xml的配置文件 --&gt;&lt;!-- 导入dtd约束： 位置：在核心jar包中的名称为hibernate-configuration-3.0.dtd中--&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory SessionFactory的作用就是用于创建Session对象的。 Session对象就是hibernate中操作数据库的核心对象。 此处的配置不要求背，但是要求记住创建SessionFactory必须的三部分信息 第一部分： 连接数据库的信息 第二部分： hibernate的可选配置 第三部分： 映射文件的位置 --&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;property&gt; &lt;!-- 是否让hibernate根据表结构的变化来生成DDL语句 DDL:数据定义语言 hibernate可以根据映射文件来为我们生成数据库的表结构。但是他不能生成数据库。 hbm2ddl.auto的取值 * none:不用Hibernate自动生成表. * create:每次都会创建一个新的表.(测试) * create-drop:每次都会创建一个新的表，执行程序结束后删除这个表.(测试) * update:如果数据库中有表，使用原来的表，如果没有表，创建一个新表.可以更新表结构。 * validate:只会使用原有的表.对映射关系进行校验. --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping resource&#x3D;&quot;com&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 3.4 实现保存操作在项目中新建一个名称为cn.wgy.test的包，然后在包中建立一个名为HibernateDemo1Test.java的文件，该文件是用来测试的类文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * hibernate的入门案例 * 需求： * 实现保存一个客户到数据库 * * @author wgy */public class HibernateDemo1Test &#123; /** * 步骤分析 * 1、解析主配置文件 * 2、根据配置文件创建SessionFactory * 3、根据SessionFactory创建Session * 4、开启事务 * 5、执行操作（保存） * 6、提交事务 * 7、释放资源 */ @Test public void test1() &#123; Customer customer = new Customer(); customer.setCustName(\"测试1\"); // 1、解析主配置文件 Configuration configuration = new Configuration(); configuration.configure(); // 2、根据配置文件创建SessionFactory SessionFactory sessionFactory = configuration.buildSessionFactory(); // 3、根据SessionFactory创建Session Session session = sessionFactory.openSession(); // 4、开启事务 Transaction transaction = session.beginTransaction(); // 5、执行操作（保存） session.save(customer); // 6、提交事务 transaction.commit(); // 7、释放资源 session.close(); sessionFactory.close(); &#125;&#125; 3.5 入门案例的执行过程首先创建Configuration类的实例，并通过它来读取并解析配置文件hibernate.cfg.xml。然后创建SessionFactory读取解析映射文件信息，并将Configuration对象中的所有配置信息拷贝到SessionFactory内存中。接下来，打开Session，让SessionFactory提供连接，并开启一个事务，之后创建对象，向对象中添加数据，通过session.save()方法完成向数据库中保存数据的操作。最后提交事务，并关闭资源。 4. Hibernate中API介绍4.1 Configuration对象4.1.1 作用在使用Hibernate时，首先要创建Configuration实例，Configuration实例主要用于启动、加载、管理hibernate的配置文件信息。在启动Hibernate的过程中，Configuration实例首先确定Hibernate配置文件的位置，然后读取相关配置，最后创建一个唯一的SessionFactory实例。Configuration对象只存在于系统的初始化阶段，它将SessionFactory创建完成后，就完成了自己的使命。 Hibernate通常使用Configuration config = new Configuration().configure();的方式创建实例，此种方式默认会去src下读取 hibernate.cfg.xml配置文件。如果不想使用默认的hibernate.cfg.xml配置文件，而是使用指定目录下（或自定义）的配置文件，则需要向configure()方法中传递一个文件路径的参数，其代码写法如下： 1Configuration config &#x3D; new Configuration().configure(&quot;xml文件位置&quot;); 此种写法hibernate会去指定位置查找配置文件，例如，想要使用src下config包中的 hibernate.cfg.xml文件，只需将文件位置加入configure()中即可，其代码如下所示： 1Configuration config = new Configuration().configure(\"/config/hibernate.cfg.xml\"); 【加载映射文件】 Hibernate除了可以使用Configuration对象加载核心配置文件以外，还可以利用该对象加载映射文件。因为如何使用properties文件作为Hibernate的核心配置文件，其他的属性可以使用key=value的格式来设置，但是映射没有办法加载。这时这个对象就有了用武之地。可以在手动编写代码的时候去加载映射文件。 123Configuration configuration &#x3D; new Configuration().configure(&quot;xml文件位置&quot;);configuration.addResource(&quot;cn&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;); 4.1.2 常用方法1234567891011121314默认构造函数： 它只能加载类的根路径下，名称为hibernate.properties的配置文件。不能加载xmlconfigure()： 它用于加载类的根路径下，名称为hibernate.cfg.xml的配置文件。 configuration.configure();buildSessionFactory()： 根据配置文件，构建SessionFactory SessionFactory sessionFactory &#x3D; configuration.buildSessionFactory();addResource(String url); 指定映射文件的位置 configuration.addResource(&quot;com&#x2F;itheima&#x2F;domain&#x2F;Customer.hbm.xml&quot;);addClass(Class clazz); 指定实体类的字节码 configuration.addClass(Customer.class); 4.2 SessionFactory4.2.1 作用SessionFactory接口负责Hibernate的初始化和建立Session对象。它在Hibernate中起到一个缓冲区作用，Hibernate可以将自动生成的SQL语句、映射数据以及某些可重复利用的的数据放在这个缓冲区中。同时它还保存了对数据库配置的所有映射关系，维护了当前的二级缓存。 SessionFactory 实例是通过Configuration对象获取的，其获取方法如下所示。 1SessionFactory sessionFactory = config.buildSessionFactory(); 4.2.2 常用方法1openSession()：每次都是生成一个新的Session 4.2.3 细节该对象维护了很多信息： 连接数据库的信息 hibernate的基本配置 映射文件的位置，以及映射文件中的配置 一些预定义的SQL语句（这些语句都是通用的） 比如：全字段保存，根据id的全字段更新，根据id的全字段查询，根据id的删除等等。 hibernate的二级缓存（了解） 同时，它是一个线程安全的对象，所有由该工厂生产的Session都共享工厂中维护的数据。 4.2.4 使用原则由于SessionFactory维护了很多信息同时又是线程安全的，一般情况下，一个项目中只需要一个SessionFactory，只有当应用中存在多个数据源时，才为每个数据源建立一个SessionFactory实例。因此，不应该反复的创建和销毁。 原则：一个应用应该只有一个SessionFactory。在应用加载时创建，应用卸载时销毁。 4.2.5 在hibernate中使用数据源(连接池)SessionFactory内部还维护了一个连接池，如果我们需要使用第三方的连接池如C3P0，那么需要我们自己手动进行配置 配置C3P0步骤如下： 导入连接池的jar包 在hibernate主配置文件中配置 1234&lt;!-- 配置数据源的提供商 --&gt;&lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt; org.hibernate.connection.C3P0ConnectionProvider&lt;&#x2F;property&gt; 4.3 Session4.3.1 作用Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。 创建SessionFactory实例后，就可以通过它获取Session实例。获取Session实例有两种方式，一种是通过openSession()方法，另一种是通过getCurrentSession()方法。两种方法获取session的代码如下所示： 12345//采用openSession方法创建sessionSession session = sessionFactory.openSession();//采用getCurrentSession()方法创建sessionSession session = sessionFactory.getCurrentSession(); 以上两种获取session实例方式的主要区别是，采用openSession方法获取Session实例时，SessionFactory直接创建一个新的Session实例，并且在使用完成后需要调用close方法进行手动关闭。而getCurrentSession方法创建的Session实例会被绑定到当前线程中，它在提交或回滚操作时会自动关闭。 4.3.2 常用方法123456789save(Object entity); ：保存一个实体到数据库update(Object entity);：更新一个实体delete(Object entity);：删除一个实体get(Class clazz,Serializable id);：根据id查询一个实体。参数的含义：Class表示要查询的实体类字节码。Serializable就是查询的条件。beginTransaction();：开启事务，并返回事务对象 4.3.3 细节由于SessionFactory已经维护了很多数据，所以Session就维护较少的内容。 它是一个轻量级对象。并且：它不是线程安全的！！！！！！！ 它维护了hibernate的一级缓存。 它的反复创建销毁不会消耗太多资源。 4.3.4 使用原则每个线程都只有一个Session对象。 4.4 Transaction4.4.1 作用Transaction接口主要用于管理事务，它是Hibernate的数据库事务接口，且对底层的事务接口进行了封装。Transaction接口的事务对象是通过Session对象开启的，其开启方式如下所示。 1Transaction transaction &#x3D; session.beginTransaction(); 4.4.2 常用方法123commit()：提交事务rollback()：回滚事务 Session执行完数据库操作后，要使用Transaction接口的commit()方法进行事务提交，才能真正的将数据操作同步到数据库中。发生异常时，需要使用rollback()方法进行事务回滚，以避免数据发生错误。因此，在持久化操作后，必须调用Transaction接口的commit()方法和rollback()方法。如果没有开启事务，那么每个Session的操作，都相当于一个独立的操作。 123456789101112131415161718@Testpublic void testSave1() &#123; Customer c = new Customer(); c.setCustName(\"测试保存功能\"); Transaction tx = null; Session s = null; try &#123; s = HibernateUtil.openSession(); tx = s.beginTransaction(); //保存客户 s.save(c); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); &#125; finally &#123; s.close(); &#125;&#125; 5. 抽取HibernateUtil工具类1234567891011121314151617181920212223242526272829/** * hibernate的工具类 * 用于生产一个Session对象 * * @author wgy */public class HibernateUtil &#123; private static SessionFactory factory; static&#123; try &#123; Configuration cfg = new Configuration(); cfg.configure(); factory = cfg.buildSessionFactory(); &#125; catch (Exception e) &#123; //e.printStackTrace(); throw new ExceptionInInitializerError(\"初始化SessionFactory失败\"); &#125; &#125; /** * 获取一个新的Session对象 * @return */ public static Session openSession()&#123; return factory.openSession(); &#125;&#125; 6. 案例：使用Hibernate实现CRUD6.1 保存操作12345678910111213141516@Testpublic void testAdd()&#123; Customer c = new Customer(); c.setCustName(\"测试保存功能\"); //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 //Transaction tx = session.beginTransaction(); //3.保存客户 session.save(c); //4.提交事务 //tx.commit(); //5.释放资源 session.close();&#125; 6.2 查询一个实体1234567891011121314@Testpublic void testFindOne()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为2的客户 Customer c = session.get(Customer.class, 2L); System.out.println(c); //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.3 修改操作1234567891011121314151617@Testpublic void testUpdate()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为2的客户 Customer c = session.get(Customer.class, 2L); //修改客户的地址为：湖北省 c.setCustAddress(\"湖北省\"); //执行更新 session.update(c); //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.4 删除操作123456789101112131415@Testpublic void testDelete()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为1的客户 Customer c = session.get(Customer.class, 1L); //删除实体 session.delete(c);//delete from cst_customer where cust_id = ? //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.5 实体查询get和load方法6.5.1 实体查询的概念所谓实体查询即OID查询，就是使用主键作为条件来查询一个实体。其中涉及的方法是Session对象get方法和load方法。 6.5.2 方法的说明get方法： 12345678910111213141516/** * 根据id查询一个实体 * @param entityType 指的是要查询的实体类字节码对象 * @param id 查询的条件，即主键的值。 * @return 返回的是实体类对象 */&lt;T&gt; T get(Class&lt;T&gt; entityType, Serializable id);@Testpublic void testGet()&#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 2L); System.out.println(\"get : \"+c.toString()); tx.commit();&#125; load方法： 12345678910111213141516/** * 根据id查询一个实体 * @param theClass 指的是要查询的实体类字节码 * @param id查询的条件，即主键的值。 * @return 返回的是实体类对象或者是实体类对象的代理对象 */&lt;T&gt; T load(Class&lt;T&gt; theClass, Serializable id);@Testpublic void testLoad()&#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); Customer c = s.load(Customer.class, 2L); System.out.println(\"load : \"+c.toString()); tx.commit();&#125; 6.5.3 get和load的区别 查询的时机不一样。 get的查询时机：每次调用get方法时，马上发起查询。 立即加载 load的查询时机：每次真正使用的时候，发起查询。 延迟加载 懒加载 惰性加载 返回的结果不一样。 get方法返回的对象是实体类类型 load方法返回的对象是实体类类型的代理对象 load方法默认情况下是延迟，可以通过配置的方式改为立即加载。 12&lt;!-- 由于load方法是hibernate的方法所以只有XML的方式：--&gt;&lt;class name=\"Customer\" table=\"cst_customer\" lazy=\"false\"&gt;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"MySQL高级教程(四)","date":"2020-05-21T07:21:30.000Z","path":"archives/e6ab56f8.html","text":"1. MySql中常用工具1.1 mysql该mysql不是指mysql服务，而是指mysql的客户端工具。 语法 ： 1mysql [options] [database] 1.1.1 连接选项12345678910参数 ： -u, --user&#x3D;name 指定用户名 -p, --password[&#x3D;name] 指定密码 -h, --host&#x3D;name 指定服务器IP或域名 -P, --port&#x3D;# 指定连接端口示例 ： mysql -h 127.0.0.1 -P 3306 -u root -p mysql -h127.0.0.1 -P3306 -uroot -p2143 1.1.2 执行选项1-e, --execute&#x3D;name 执行SQL语句并退出 此选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。 12示例： mysql -uroot -p2143 db01 -e &quot;select * from tb_book&quot;; 1.2 mysqladminmysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。 可以通过 ： mysqladmin –help 指令查看帮助文档 1234示例 ： mysqladmin -uroot -p2143 create &#39;test01&#39;; mysqladmin -uroot -p2143 drop &#39;test01&#39;; mysqladmin -uroot -p2143 version; 1.3 mysqlbinlog由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。 语法 ： 123456789101112131415mysqlbinlog [options] log-files1 log-files2 ...选项： -d, --database&#x3D;name : 指定数据库名称，只列出指定的数据库相关操作。 -o, --offset&#x3D;# : 忽略掉日志中的前n行命令。 -r,--result-file&#x3D;name : 将输出的文本格式日志输出到指定文件。 -s, --short-form : 显示简单格式， 省略掉一些信息。 --start-datatime&#x3D;date1 --stop-datetime&#x3D;date2 : 指定日期间隔内的所有日志。 --start-position&#x3D;pos1 --stop-position&#x3D;pos2 : 指定位置间隔内的所有日志。 1.4 mysqldumpmysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。 语法 ： 12345mysqldump [options] db_name [tables]mysqldump [options] --database&#x2F;-B db1 [db2 db3...]mysqldump [options] --all-databases&#x2F;-A 1.4.1 连接选项12345参数 ： -u, --user&#x3D;name 指定用户名 -p, --password[&#x3D;name] 指定密码 -h, --host&#x3D;name 指定服务器IP或域名 -P, --port&#x3D;# 指定连接端口 1.4.2 输出内容选项12345678910参数： --add-drop-database 在每个数据库创建语句前加上 Drop database 语句 --add-drop-table 在每个表创建语句前加上 Drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table) -n, --no-create-db 不包含数据库的创建语句 -t, --no-create-info 不包含数据表的创建语句 -d --no-data 不包含数据 -T, --tab&#x3D;name 自动生成两个文件：一个.sql文件，创建表结构的语句； 一个.txt文件，数据文件，相当于select into outfile 1234示例 ： mysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table &gt; a mysqldump -uroot -p2143 -T &#x2F;tmp test city 1.5 mysqlimport/sourcemysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。 语法： 1mysqlimport [options] db_name textfile1 [textfile2...] 示例： 1mysqlimport -uroot -p2143 test &#x2F;tmp&#x2F;city.txt 如果需要导入sql文件,可以使用mysql中的source 指令 : 1source &#x2F;root&#x2F;tb_book.sql 1.6 mysqlshowmysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。 语法： 1mysqlshow [options] [db_name [table_name [col_name]]] 参数： 123--count 显示数据库及表的统计信息（数据库，表 均可以不指定）-i 显示指定数据库或者指定表的状态信息 示例： 12345678#查询每个数据库的表的数量及表中记录的数量mysqlshow -uroot -p2143 --count#查询test库中每个表中的字段书，及行数mysqlshow -uroot -p2143 test --count#查询test库中book表的详细情况mysqlshow -uroot -p2143 test book --count 2. Mysql 日志在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件。MySQL 也不例外，在 MySQL 中，有 4 种不同的日志，分别是错误日志、二进制日志（BINLOG 日志）、查询日志和慢查询日志，这些日志记录着数据库在不同方面的踪迹。 2.1 错误日志错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。 该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录（var/lib/mysql）, 默认的日志文件名为 hostname.err（hostname是主机名）。 查看日志位置指令 ： 1show variables like &#39;log_error%&#39;; 查看日志内容 ： 1tail -f /var/lib/mysql/xaxh-server.err 2.2 二进制日志2.2.1 概述二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。 二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。 配置文件位置 : /usr/my.cnf 日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入Mysql的数据目录。 12345#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002log_bin&#x3D;mysqlbin#配置二进制日志的格式binlog_format&#x3D;STATEMENT 2.2.2 日志格式STATEMENT 该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。 ROW 该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status=’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。 MIXED 这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。 2.2.3 日志读取由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下 ： 1mysqlbinlog log-file； 查看STATEMENT格式日志 执行插入语句 ： 1insert into tb_book values(null,&#39;Lucene&#39;,&#39;2088-05-01&#39;,&#39;0&#39;); 查看日志文件 ： mysqlbin.index : 该文件是日志索引文件 ， 记录日志的文件名； mysqlbing.000001 ：日志文件 查看日志内容 ： 1mysqlbinlog mysqlbing.000001； 查看ROW格式日志 配置 : 12345#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002log_bin&#x3D;mysqlbin#配置二进制日志的格式binlog_format&#x3D;ROW 插入数据 : 1insert into tb_book values(null,&#39;SpringCloud实战&#39;,&#39;2088-05-05&#39;,&#39;0&#39;); 如果日志格式是 ROW , 直接查看数据 , 是查看不懂的 ; 可以在mysqlbinlog 后面加上参数 -vv 1mysqlbinlog -vv mysqlbin.000002 2.2.4 日志删除对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清楚，将会占用大量的磁盘空间。下面我们将会讲解几种删除日志的常见方法 ： 方式一 通过 Reset Master 指令删除全部 binlog 日志，删除之后，日志编号，将从 xxxx.000001重新开始 。 查询之前 ，先查询下日志文件 ： 执行删除日志指令： 1Reset Master 执行之后， 查看日志文件 ： 方式二 执行指令 purge master logs to &#39;mysqlbin.******&#39; ，该命令将删除 ****** 编号之前的所有日志。 方式三 执行指令 purge master logs before &#39;yyyy-mm-dd hh24:mi:ss&#39; ，该命令将删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志 。 方式四 设置参数 –expire_logs_days=# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。 配置如下 ： 2.3 查询日志查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。 默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ： 12345#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 general_log&#x3D;1#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log general_log_file&#x3D;file_name 在 mysql 的配置文件 /usr/my.cnf 中配置如下内容 ： 配置完毕之后，在数据库执行以下操作 ： 1234select * from tb_book;select * from tb_book where id &#x3D; 1;update tb_book set name &#x3D; &#39;lucene入门指南&#39; where id &#x3D; 5;select * from tb_book where id &lt; 8; 执行完毕之后， 再次来查询日志文件 ： 2.4 慢查询日志慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。 2.4.1 文件位置和格式慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ： 12345678# 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭slow_query_log&#x3D;1 # 该参数用来指定慢查询日志的文件名slow_query_log_file&#x3D;slow_query.log# 该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10slong_query_time&#x3D;10 2.4.2 日志的读取和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。 1） 查询long_query_time 的值。 2） 执行查询操作 1select id, title,price,num ,status from tb_item where id &#x3D; 1; 由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。 1select * from tb_item where title like &#39;%阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待165454%&#39; ; 该SQL语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。 3） 查看慢查询日志文件 直接通过cat 指令查询该日志文件 ： 如果慢查询日志内容很多， 直接查看文件，比较麻烦， 这个时候可以借助于mysql自带的 mysqldumpslow 工具， 来对慢查询日志进行分类汇总。 3. Mysql复制3.1 复制概述复制是指将主数据库的DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。 MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。 3.2 复制原理MySQL 的主从复制原理如下。 从上层来看，复制分成三步： Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。 主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log 。 slave重做中继日志中的事件，将改变反映它自己的数据。 3.3 复制优势MySQL 复制的有点主要包含以下三个方面： 主库出现问题，可以快速切换到从库提供服务。 可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。 可以在从库中执行备份，以避免备份期间影响主库的服务。 3.4 搭建步骤3.4.1 master1） 在master 的配置文件（/usr/my.cnf）中，配置如下内容： 1234567891011121314151617181920212223242526#mysql 服务ID,保证整个集群环境中唯一server-id=1#mysql binlog 日志的存储路径和文件名log-bin=/var/lib/mysql/mysqlbin#错误日志,默认已经开启#log-err#mysql的安装目录#basedir#mysql的临时目录#tmpdir#mysql的数据存放目录#datadir#是否只读,1 代表只读, 0 代表读写read-only=0#忽略的数据, 指不需要同步的数据库binlog-ignore-db=mysql#指定同步的数据库#binlog-do-db=db01 2） 执行完毕之后，需要重启Mysql： 1service mysql restart ; 3） 创建同步数据的账户，并且进行授权操作： 123grant replication slave on *.* to &#39;root&#39;@&#39;192.168.192.131&#39; identified by &#39;root&#39;; flush privileges; 4） 查看master状态： 1show master status; 字段含义： 123File : 从哪个日志文件开始推送日志文件 Position ： 从哪个位置开始推送日志Binlog_Ignore_DB : 指定不需要同步的数据库 3.4.2 slave1） 在 slave 端配置文件中，配置如下内容： 12345#mysql服务端ID,唯一server-id=2#指定binlog日志log-bin=/var/lib/mysql/mysqlbin 2） 执行完毕之后，需要重启Mysql： 1service mysql restart； 3） 执行如下指令 ： 1change master to master_host= '192.168.192.130', master_user='root', master_password='root', master_log_file='mysqlbin.000001', master_log_pos=413; 指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。 4） 开启同步操作 123start slave;show slave status; 5） 停止同步操作 1stop slave; 3.4.3 验证同步操作1） 在主库中创建数据库，创建表，并插入数据 ： 1234567891011121314create database db01;user db01;create table user( id int(11) not null auto_increment, name varchar(50) not null, sex varchar(1), primary key (id))engine&#x3D;innodb default charset&#x3D;utf8;insert into user(id,name,sex) values(null,&#39;Tom&#39;,&#39;1&#39;);insert into user(id,name,sex) values(null,&#39;Trigger&#39;,&#39;0&#39;);insert into user(id,name,sex) values(null,&#39;Dawn&#39;,&#39;1&#39;); 2） 在从库中查询数据，进行验证 ： 在从库中，可以查看到刚才创建的数据库： 在该数据库中，查询user表中的数据： 4. 综合案例4.1 需求分析在业务系统中，需要记录当前业务系统的访问日志，该访问日志包含：操作人，操作时间，访问类，访问方法，请求参数，请求结果，请求结果类型，请求时长等信息。记录详细的系统访问日志，主要便于对系统中的用户请求进行追踪，并且在系统 的管理后台可以查看到用户的访问记录。 记录系统中的日志信息，可以通过Spring 框架的AOP来实现。具体的请求处理流程，如下： 4.2 搭建案例环境4.2.1 数据库表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647CREATE DATABASE mysql_demo DEFAULT CHARACTER SET utf8mb4 ；CREATE TABLE &#96;brand&#96; ( &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT, &#96;name&#96; varchar(255) DEFAULT NULL COMMENT &#39;品牌名称&#39;, &#96;first_char&#96; varchar(1) DEFAULT NULL COMMENT &#39;品牌首字母&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;CREATE TABLE &#96;item&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;商品id&#39;, &#96;title&#96; varchar(100) NOT NULL COMMENT &#39;商品标题&#39;, &#96;price&#96; double(10,2) NOT NULL COMMENT &#39;商品价格，单位为：元&#39;, &#96;num&#96; int(10) NOT NULL COMMENT &#39;库存数量&#39;, &#96;categoryid&#96; bigint(10) NOT NULL COMMENT &#39;所属类目，叶子类目&#39;, &#96;status&#96; varchar(1) DEFAULT NULL COMMENT &#39;商品状态，1-正常，2-下架，3-删除&#39;, &#96;sellerid&#96; varchar(50) DEFAULT NULL COMMENT &#39;商家ID&#39;, &#96;createtime&#96; datetime DEFAULT NULL COMMENT &#39;创建时间&#39;, &#96;updatetime&#96; datetime DEFAULT NULL COMMENT &#39;更新时间&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品表&#39;;CREATE TABLE &#96;user&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;username&#96; varchar(45) NOT NULL, &#96;password&#96; varchar(96) NOT NULL, &#96;name&#96; varchar(45) NOT NULL, &#96;birthday&#96; datetime DEFAULT NULL, &#96;sex&#96; char(1) DEFAULT NULL, &#96;email&#96; varchar(45) DEFAULT NULL, &#96;phone&#96; varchar(45) DEFAULT NULL, &#96;qq&#96; varchar(32) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;CREATE TABLE &#96;operation_log&#96; ( &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;, &#96;operate_class&#96; varchar(200) DEFAULT NULL COMMENT &#39;操作类&#39;, &#96;operate_method&#96; varchar(200) DEFAULT NULL COMMENT &#39;操作方法&#39;, &#96;return_class&#96; varchar(200) DEFAULT NULL COMMENT &#39;返回值类型&#39;, &#96;operate_user&#96; varchar(20) DEFAULT NULL COMMENT &#39;操作用户&#39;, &#96;operate_time&#96; varchar(20) DEFAULT NULL COMMENT &#39;操作时间&#39;, &#96;param_and_value&#96; varchar(500) DEFAULT NULL COMMENT &#39;请求参数名及参数值&#39;, &#96;cost_time&#96; bigint(20) DEFAULT NULL COMMENT &#39;执行方法耗时, 单位 ms&#39;, &#96;return_value&#96; varchar(200) DEFAULT NULL COMMENT &#39;返回值&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4; 4.2.2 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 4.2.3 web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4.2.4 db.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://192.168.142.128:3306/mysql_demojdbc.username=rootjdbc.password=root 4.2.5 applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; &lt;!-- 配置 spring 创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package=\"com.wgy\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"&gt; &lt;/context:exclude-filter&gt; &lt;/context:component-scan&gt; &lt;!-- 配置 MyBatis 的 Session 工厂 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.wgy.domain\"/&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 Mapper 扫描器 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.wgy.mapper\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务的注解驱动 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt; 4.2.6 springmvc.xml123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.wgy.controller\"&gt;&lt;/context:component-scan&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 4.2.7 导入基础工程 4.3 通过AOP记录操作日志4.3.1 自定义注解通过自定义注解，来标示方法需不需要进行记录日志，如果该方法在访问时需要记录日志，则在该方法上标示该注解既可。 123456@Inherited@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface OperateLog &#123;&#125; 4.3.2 定义通知类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Component@Aspectpublic class OperateAdvice &#123; private static Logger log = Logger.getLogger(OperateAdvice.class); @Autowired private OperationLogService operationLogService; @Around(\"execution(* com.wgy.controller.*.*(..)) &amp;&amp; @annotation(operateLog)\") public Object insertLogAround(ProceedingJoinPoint pjp , OperateLog operateLog) throws Throwable&#123; System.out.println(\" ************************ 记录日志 [start] ****************************** \"); OperationLog op = new OperationLog(); DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); op.setOperateTime(sdf.format(new Date())); op.setOperateUser(DataUtils.getRandStr(8)); op.setOperateClass(pjp.getTarget().getClass().getName()); op.setOperateMethod(pjp.getSignature().getName()); //获取方法调用时传递的参数 Object[] args = pjp.getArgs(); op.setParamAndValue(Arrays.toString(args)); long start_time = System.currentTimeMillis(); //放行 Object object = pjp.proceed(); long end_time = System.currentTimeMillis(); op.setCostTime(end_time - start_time); if(object != null)&#123; op.setReturnClass(object.getClass().getName()); op.setReturnValue(object.toString()); &#125;else&#123; op.setReturnClass(\"java.lang.Object\"); op.setParamAndValue(\"void\"); &#125; log.error(JsonUtils.obj2JsonString(op)); operationLogService.insert(op); System.out.println(\" ************************** 记录日志 [end] *************************** \"); return object; &#125;&#125; 4.3.3 方法上加注解在需要记录日志的方法上加上注解@OperateLog。 1234567891011@OperateLog@RequestMapping(\"/insert\")public Result insert(@RequestBody Brand brand)&#123; try &#123; brandService.insert(brand); return new Result(true,\"操作成功\"); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(false,\"操作失败\"); &#125;&#125; 4.4 日志查询后端代码实现4.4.1 Mapper接口123456789public interface OperationLogMapper &#123; public void insert(OperationLog operationLog); public List&lt;OperationLog&gt; selectListByCondition(Map dataMap); public Long countByCondition(Map dataMap);&#125; 4.4.2 Mapper.xml 映射配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.wgy.mapper.OperationLogMapper\" &gt; &lt;insert id=\"insert\" parameterType=\"operationLog\"&gt; INSERT INTO operation_log(id,return_value,return_class,operate_user,operate_time,param_and_value, operate_class,operate_method,cost_time) VALUES(NULL,#&#123;returnValue&#125;,#&#123;returnClass&#125;,#&#123;operateUser&#125;,#&#123;operateTime&#125;,#&#123;paramAndValue&#125;, #&#123;operateClass&#125;,#&#123;operateMethod&#125;,#&#123;costTime&#125;) &lt;/insert&gt; &lt;select id=\"selectListByCondition\" parameterType=\"map\" resultType=\"operationLog\"&gt; select id , operate_class as operateClass , operate_method as operateMethod, return_class as returnClass, operate_user as operateUser, operate_time as operateTime, param_and_value as paramAndValue, cost_time as costTime, return_value as returnValue from operation_log &lt;include refid=\"oplog_where\"/&gt; limit #&#123;start&#125;,#&#123;size&#125; &lt;/select&gt; &lt;select id=\"countByCondition\" resultType=\"long\" parameterType=\"map\"&gt; select count(*) from operation_log &lt;include refid=\"oplog_where\"/&gt; &lt;/select&gt; &lt;sql id=\"oplog_where\"&gt; &lt;where&gt; &lt;if test=\"operateClass != null and operateClass != '' \"&gt; and operate_class = #&#123;operateClass&#125; &lt;/if&gt; &lt;if test=\"operateMethod != null and operateMethod != '' \"&gt; and operate_method = #&#123;operateMethod&#125; &lt;/if&gt; &lt;if test=\"returnClass != null and returnClass != '' \"&gt; and return_class = #&#123;returnClass&#125; &lt;/if&gt; &lt;if test=\"costTime != null\"&gt; and cost_time = #&#123;costTime&#125; &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt;&lt;/mapper&gt; 4.4.3 Service123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Service@Transactionalpublic class OperationLogService &#123; //private static Logger logger = Logger.getLogger(OperationLogService.class); @Autowired private OperationLogMapper operationLogMapper; //插入数据 public void insert(OperationLog operationLog)&#123; operationLogMapper.insert(operationLog); &#125; //根据条件查询 public PageResult selectListByCondition(Map dataMap, Integer pageNum , Integer pageSize)&#123; if(paramMap ==null)&#123; paramMap = new HashMap(); &#125; paramMap.put(\"start\" , (pageNum-1)*rows); paramMap.put(\"rows\",rows); Object costTime = paramMap.get(\"costTime\"); if(costTime != null)&#123; if(\"\".equals(costTime.toString()))&#123; paramMap.put(\"costTime\",null); &#125;else&#123; paramMap.put(\"costTime\",new Long(paramMap.get(\"costTime\").toString())); &#125; &#125; System.out.println(dataMap); long countStart = System.currentTimeMillis(); Long count = operationLogMapper.countByCondition(dataMap); long countEnd = System.currentTimeMillis(); System.out.println(\"Count Cost Time : \" + (countEnd-countStart)+\" ms\"); List&lt;OperationLog&gt; list = operationLogMapper.selectListByCondition(dataMap); long queryEnd = System.currentTimeMillis(); System.out.println(\"Query Cost Time : \" + (queryEnd-countEnd)+\" ms\"); return new PageResult(count,list); &#125;&#125; 4.4.4 Controller1234567891011121314@RestController@RequestMapping(\"/operationLog\")public class OperationLogController &#123; @Autowired private OperationLogService operationLogService; @RequestMapping(\"/findList\") public PageResult findList(@RequestBody Map dataMap, Integer pageNum , Integer pageSize)&#123; PageResult page = operationLogService.selectListByCondition(dataMap, pageNum, pageSize); return page; &#125;&#125; 4.5 日志查询前端代码实现前端代码使用 BootStrap + AdminLTE 进行布局， 使用Vuejs 进行视图层展示。 4.5.1 js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; dataList:[], searchEntity:&#123; operateClass:'', operateMethod:'', returnClass:'', costTime:'' &#125;, page: 1, //显示的是哪一页 pageSize: 10, //每一页显示的数据条数 total: 150, //记录总数 maxPage:8 //最大页数 &#125;, methods: &#123; pageHandler: function (page) &#123; this.page = page; this.search(); &#125;, search: function () &#123; var _this = this; this.showLoading(); axios.post('/operationLog/findList.do?pageNum=' + _this.page + \"&amp;pageSize=\" + _this.pageSize, _this.searchEntity).then(function (response) &#123; if (response) &#123; _this.dataList = response.data.dataList; _this.total = response.data.total; _this.hideLoading(); &#125; &#125;) &#125;, showLoading: function () &#123; $('#loadingModal').modal(&#123;backdrop: 'static', keyboard: false&#125;); &#125;, hideLoading: function () &#123; $('#loadingModal').modal('hide'); &#125;, &#125;, created:function()&#123; this.pageHandler(1); &#125; &#125;);&lt;/script&gt; 4.5.2 列表数据展示123456789101112131415&lt;tr v-for=\"item in dataList\"&gt; &lt;td&gt;&lt;input name=\"ids\" type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.operateClass&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.operateMethod&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.returnClass&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.returnValue&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.operateUser&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.operateTime&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.costTime&#125;&#125;&lt;/td&gt; &lt;td class=\"text-center\"&gt; &lt;button type=\"button\" class=\"btn bg-olive btn-xs\"&gt;详情&lt;/button&gt; &lt;button type=\"button\" class=\"btn bg-olive btn-xs\"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt; 4.5.3 分页插件12345&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;zpagenav v-bind:page=\"page\" v-bind:page-size=\"pageSize\" v-bind:total=\"total\" v-bind:max-page=\"maxPage\" v-on:pagehandler=\"pageHandler\"&gt; &lt;/zpagenav&gt;&lt;/div&gt; 4.6 联调测试可以通过postman来访问业务系统，再查看数据库中的日志信息，验证能不能将用户的访问日志记录下来。 4.7 分析性能问题系统中用户访问日志的数据量，随着时间的推移，这张表的数据量会越来越大，因此我们需要根据业务需求，来对日志查询模块的性能进行优化。 1） 分页查询优化 由于在进行日志查询时，是进行分页查询，那也就意味着，在查看时，至少需要查询两次： A. 查询符合条件的总记录数。–&gt; count 操作 B. 查询符合条件的列表数据。–&gt; 分页查询 limit 操作 通常来说，count() 都需要扫描大量的行（意味着需要访问大量的数据）才能获得精确的结果，因此是很难对该SQL进行优化操作的。如果需要对count进行优化，可以采用另外一种思路，可以增加汇总表，或者redis缓存来专门记录该表对应的记录数，这样的话，就可以很轻松的实现汇总数据的查询，而且效率很高，但是这种统计并不能保证百分之百的准确 。对于数据库的操作，“快速、精确、实现简单”，三者永远只能满足其二，必须舍掉其中一个。 2） 条件查询优化 针对于条件查询,需要对查询条件,及排序字段建立索引。 3） 读写分离 通过主从复制集群，来完成读写分离，使写操作走主节点， 而读操作，走从节点。 4） MySQL服务器优化 5） 应用优化 4.8 性能优化 - 分页4.8.1 优化count创建一张表用来记录日志表的总数据量： 123create table log_counter( logcount bigint not null)engine &#x3D; innodb default CHARSET &#x3D; utf8; 在每次插入数据之后，更新该表 ： 123&lt;update id=\"updateLogCounter\" &gt; update log_counter set logcount = logcount + 1&lt;/update&gt; 在进行分页查询时, 获取总记录数，从该表中查询既可。 123&lt;select id=\"countLogFromCounter\" resultType=\"long\"&gt; select logcount from log_counter limit 1&lt;/select&gt; 4.8.2 优化 limit在进行分页时，一般通过创建覆盖索引，能够比较好的提高性能。一个非常常见，而又非常头疼的分页场景就是 “limit 1000000,10” ，此时MySQL需要搜索出前1000010 条记录后，仅仅需要返回第 1000001 到 1000010 条记录，前1000000 记录会被抛弃，查询代价非常大。 当点击比较靠后的页码时，就会出现这个问题，查询效率非常慢。 优化SQL： 1select * from operation_log limit 3000000 , 10; 将上述SQL优化为 : 1select * from operation_log t , (select id from operation_log order by id limit 3000000,10) b where t.id &#x3D; b.id ; 123456789101112131415161718&lt;select id=\"selectListByCondition\" parameterType=\"map\" resultType=\"operationLog\"&gt; select id , operate_class as operateClass , operate_method as operateMethod, return_class as returnClass, operate_user as operateUser, operate_time as operateTime, param_and_value as paramAndValue, cost_time as costTime, return_value as returnValue from operation_log t, (select id from operation_log &lt;where&gt; &lt;include refid=\"oplog_where\"/&gt; &lt;/where&gt; order by id limit #&#123;start&#125;,#&#123;rows&#125;) b where t.id = b.id &lt;/select&gt; 4.9 性能优化 - 索引 当根据操作人进行查询时， 查询的效率很低，耗时比较长。原因就是因为在创建数据库表结构时，并没有针对于 操作人字段建立索引。 1CREATE INDEX idx_user_method_return_cost ON operation_log(operate_user,operate_method,return_class,cost_time); 同上 ， 为了查询效率高，我们也需要对 操作方法、返回值类型、操作耗时 等字段进行创建索引，以提高查询效率。 12345CREATE INDEX idx_optlog_method_return_cost ON operation_log(operate_method,return_class,cost_time);CREATE INDEX idx_optlog_return_cost ON operation_log(return_class,cost_time);CREATE INDEX idx_optlog_cost ON operation_log(cost_time); 4.10 性能优化 - 排序在查询数据时，如果业务需求中需要我们对结果内容进行了排序处理 , 这个时候,我们还需要对排序的字段建立适当的索引, 来提高排序的效率 。 4.11 性能优化 - 读写分离4.11.1 概述在Mysql主从复制的基础上，可以使用读写分离来降低单台Mysql节点的压力，从而来提高访问效率，读写分离的架构如下： 对于读写分离的实现，可以通过Spring AOP 来进行动态的切换数据源，进行操作 ： 4.11.2 实现方式db.properties 123456789jdbc.write.driver=com.mysql.jdbc.Driverjdbc.write.url=jdbc:mysql://192.168.142.128:3306/mysql_demojdbc.write.username=rootjdbc.write.password=rootjdbc.read.driver=com.mysql.jdbc.Driverjdbc.read.url=jdbc:mysql://192.168.142.129:3306/mysql_demojdbc.read.username=rootjdbc.read.password=root applicationContext-datasource.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置数据源 - Read --&gt; &lt;bean id=\"readDataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\" lazy-init=\"true\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.read.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.read.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.read.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.read.password&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 - Write --&gt; &lt;bean id=\"writeDataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\" lazy-init=\"true\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.write.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.write.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.write.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.write.password&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置动态分配的读写 数据源 --&gt; &lt;bean id=\"dataSource\" class=\"com.wgy.aop.datasource.ChooseDataSource\" lazy-init=\"true\"&gt; &lt;property name=\"targetDataSources\"&gt; &lt;map key-type=\"java.lang.String\" value-type=\"javax.sql.DataSource\"&gt; &lt;entry key=\"write\" value-ref=\"writeDataSource\"/&gt; &lt;entry key=\"read\" value-ref=\"readDataSource\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"defaultTargetDataSource\" ref=\"writeDataSource\"/&gt; &lt;property name=\"methodType\"&gt; &lt;map key-type=\"java.lang.String\"&gt; &lt;entry key=\"read\" value=\",get,select,count,list,query,find\"/&gt; &lt;entry key=\"write\" value=\",add,create,update,delete,remove,insert\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ChooseDataSource 123456789101112131415161718192021222324252627public class ChooseDataSource extends AbstractRoutingDataSource &#123; public static Map&lt;String, List&lt;String&gt;&gt; METHOD_TYPE_MAP = new HashMap&lt;String, List&lt;String&gt;&gt;(); /** * 实现父类中的抽象方法，获取数据源名称 * @return */ protected Object determineCurrentLookupKey() &#123; return DataSourceHandler.getDataSource(); &#125; // 设置方法名前缀对应的数据源 public void setMethodType(Map&lt;String, String&gt; map) &#123; for (String key : map.keySet()) &#123; List&lt;String&gt; v = new ArrayList&lt;String&gt;(); String[] types = map.get(key).split(\",\"); for (String type : types) &#123; if (!StringUtils.isEmpty(type)) &#123; v.add(type); &#125; &#125; METHOD_TYPE_MAP.put(key, v); &#125; System.out.println(\"METHOD_TYPE_MAP : \"+METHOD_TYPE_MAP); &#125;&#125; DataSourceHandler 12345678910111213141516171819public class DataSourceHandler &#123; // 数据源名称 public static final ThreadLocal&lt;String&gt; holder = new ThreadLocal&lt;String&gt;(); /** * 在项目启动的时候将配置的读、写数据源加到holder中 */ public static void putDataSource(String datasource) &#123; holder.set(datasource); &#125; /** * 从holer中获取数据源字符串 */ public static String getDataSource() &#123; return holder.get(); &#125;&#125; DataSourceAspect 1234567891011121314151617181920212223242526272829303132333435@Aspect@Component@Order(-9999)@EnableAspectJAutoProxy(proxyTargetClass = true)public class DataSourceAspect &#123; protected Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 配置前置通知,使用在方法aspect()上注册的切入点 */ @Before(\"execution(* com.wgy.service.*.*(..))\") @Order(-9999) public void before(JoinPoint point) &#123; String className = point.getTarget().getClass().getName(); String method = point.getSignature().getName(); logger.info(className + \".\" + method + \"(\" + Arrays.asList(point.getArgs())+ \")\"); try &#123; for (String key : ChooseDataSource.METHOD_TYPE_MAP.keySet()) &#123; for (String type : ChooseDataSource.METHOD_TYPE_MAP.get(key)) &#123; if (method.startsWith(type)) &#123; System.out.println(\"key : \" + key); DataSourceHandler.putDataSource(key); break; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 通过 @Order(-9999) 注解来控制事务管理器, 与该通知类的加载顺序 , 需要让通知类 , 先加载 , 来判定使用哪个数据源 . 4.11.3 验证在主库和从库中，执行如下SQL语句，来查看是否读的时候， 从从库中读取 ； 写入操作的时候，是否写入到主库。 1show status like &#39;Innodb_rows_%&#39; ; 4.11.4 原理 4.12 性能优化 - 应用优化4.12.1 缓存可以在业务系统中使用redis来做缓存，缓存一些基础性的数据，来降低关系型数据库的压力，提高访问效率。 4.12.2 全文检索如果业务系统中的数据量比较大（达到千万级别），这个时候，如果再对数据库进行查询，特别是进行分页查询，速度将变得很慢（因为在分页时首先需要count求合计数），为了提高访问效率，这个时候，可以考虑加入Solr 或者 ElasticSearch全文检索服务，来提高访问效率。 4.13.3 非关系数据库也可以考虑将非核心（重要）数据，存在 MongoDB 中，这样可以提高插入以及查询的效率。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wgy1993.gitee.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://wgy1993.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MySQL高级教程(三)","date":"2020-05-20T04:09:18.000Z","path":"archives/1ce8b9f7.html","text":"1. 应用优化我们已经介绍了很多数据库的优化措施。但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。 1.1 使用连接池对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立数据库连接池，以提高访问的性能。 1.2 减少对MySQL的访问1.2.1 避免对数据进行重复检索在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。 比如 ，需要获取书籍的id 和name字段 ， 则查询如下： 1select id , name from tb_book; 之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下： 1select id , status from tb_book; 这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。 1select id, name , status from tb_book; 1.2.2 增加cache层在应用中，我们可以在应用中增加缓存层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。 因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据 。 1.3 负载均衡负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。 1.3.1 利用MySQL复制分流查询通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。 1.3.2 采用分布式数据库架构分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。 2. Mysql中查询缓存优化2.1 概述开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。 2.2 操作流程 客户端发送一条查询给服务器； 服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段； 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划； MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询； 将结果返回给客户端。 2.3 查询缓存配置1）查看当前的MySQL数据库是否支持查询缓存： 1SHOW VARIABLES LIKE &#39;have_query_cache&#39;; 2）查看当前MySQL是否开启了查询缓存 ： 1SHOW VARIABLES LIKE &#39;query_cache_type&#39;; 3）查看查询缓存的占用大小 ： 1SHOW VARIABLES LIKE &#39;query_cache_size&#39;; 4）查看查询缓存的状态变量： 1SHOW STATUS LIKE &#39;Qcache%&#39;; 各个变量的含义如下： 参数 含义 Qcache_free_blocks 查询缓存中的可用内存块数 Qcache_free_memory 查询缓存的可用内存量 Qcache_hits 查询缓存命中数 Qcache_inserts 添加到查询缓存的查询数 Qcache_lowmen_prunes 由于内存不足而从查询缓存中删除的查询数 Qcache_not_cached 非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存） Qcache_queries_in_cache 查询缓存中注册的查询数 Qcache_total_blocks 查询缓存中的块总数 2.4 开启查询缓存MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ： 值 含义 OFF 或 0 查询缓存功能关闭 ON 或 1 查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存 DEMAND 或 2 查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存 在 /usr/my.cnf 配置中，增加以下配置 ： 配置完毕之后，重启服务既可生效 ； 然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。 2.5 查询缓存SELECT选项可以在SELECT语句中指定两个与查询缓存相关的选项 ： SQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。 SQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。 例子： 12SELECT SQL_CACHE id, name FROM customer;SELECT SQL_NO_CACHE id, name FROM customer; 2.6 查询缓存失效的情况1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。 12SQL1 : select count(*) from tb_item;SQL2 : Select count(*) from tb_item; 2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。 123SQL1 : select * from tb_item where updatetime &lt; now() limit 1;SQL2 : select user();SQL3 : select database(); 3） 不使用任何表查询语句。 1select &#39;A&#39;; 4） 查询 mysql， information_schema或 performance_schema 数据库中的表时，不会走查询缓存。 1select * from information_schema.engines; 5） 在存储的函数，触发器或事件的主体内执行的查询。 6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用MERGE映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。 3. Mysql内存管理及优化3.1 内存优化原则1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。 2） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。 3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。 3.2 MyISAM 内存优化myisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。 3.2.1 key_buffer_sizekey_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。 在/usr/my.cnf 中做如下配置： 1key_buffer_size&#x3D;512M 3.2.2 read_buffer_size如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。 3.2.3 read_rnd_buffer_size对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。 3.3 InnoDB 内存优化innodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。 3.3.1 innodb_buffer_pool_size该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。 1innodb_buffer_pool_size&#x3D;512M 3.3.2 innodb_log_buffer_size决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。 1innodb_log_buffer_size&#x3D;10M 4. Mysql并发参数调整从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。 4.1 max_connections采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。 Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。 4.2 back_logback_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。 如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。 4.3 table_open_cache该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ： max_connections x N ； 4.4 thread_cache_size为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。 4.5 innodb_lock_wait_timeout该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。 5. Mysql锁问题5.1 锁概述锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。 在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 5.2 锁分类从对数据操作的粒度分 ： 1） 表锁：操作时，会锁定整个表。 2） 行锁：操作时，会锁定当前操作行。 从对数据操作的类型分： 1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。 2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。 5.3 Mysql 锁相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况： 存储引擎 表级锁 行级锁 页面锁 MyISAM 支持 不支持 不支持 InnoDB 支持 支持 不支持 MEMORY 支持 不支持 不支持 BDB 支持 不支持 支持 MySQL这3种锁的特性可大致归纳如下 ： 锁类型 特点 表级锁 偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 行级锁 偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 页面锁 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。 5.2 MyISAM 表锁MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。 5.2.1 如何加表锁MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。 显示加表锁语法： 123加读锁 ： lock table table_name read;加写锁 ： lock table table_name write； 5.2.2 读锁案例准备环境 12345678910111213141516171819202122232425create database demo_03 default charset&#x3D;utf8mb4;use demo_03;CREATE TABLE &#96;tb_book&#96; ( &#96;id&#96; INT(11) auto_increment, &#96;name&#96; VARCHAR(50) DEFAULT NULL, &#96;publish_time&#96; DATE DEFAULT NULL, &#96;status&#96; CHAR(1) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;myisam DEFAULT CHARSET&#x3D;utf8 ;INSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,&#39;java编程思想&#39;,&#39;2088-08-01&#39;,&#39;1&#39;);INSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,&#39;solr编程思想&#39;,&#39;2088-08-08&#39;,&#39;0&#39;);CREATE TABLE &#96;tb_user&#96; ( &#96;id&#96; INT(11) auto_increment, &#96;name&#96; VARCHAR(50) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;myisam DEFAULT CHARSET&#x3D;utf8 ;INSERT INTO tb_user (id, name) VALUES(NULL,&#39;令狐冲&#39;);INSERT INTO tb_user (id, name) VALUES(NULL,&#39;田伯光&#39;); 客户端 一 ： 1）获得tb_book 表的读锁 1lock table tb_book read; 2） 执行查询操作 1select * from tb_book; 可以正常执行 ， 查询出数据。 客户端 二 ： 1） 执行查询操作 1select * from tb_book; 客户端 一 ： 1）查询未锁定的表 1select name from tb_seller; 客户端 二 ： 1）查询未锁定的表 1select name from tb_seller; 可以正常查询出未锁定的表； 客户端 一 ： 1） 执行插入操作 1insert into tb_book values(null,&#39;Mysql高级&#39;,&#39;2088-01-01&#39;,&#39;1&#39;); 执行插入， 直接报错 ， 由于当前tb_book 获得的是读锁， 不能执行更新操作。 客户端 二 ： 1） 执行插入操作 1insert into tb_book values(null,&#39;Mysql高级&#39;,&#39;2088-01-01&#39;,&#39;1&#39;); 当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 inesrt 语句 ， 立即执行 ； 5.2.3 写锁案例客户端 一 : 1）获得tb_book 表的写锁 1lock table tb_book write ; 2）执行查询操作 1select * from tb_book ; 查询操作执行成功； 3）执行更新操作 1update tb_book set name &#x3D; &#39;java编程思想（第二版）&#39; where id &#x3D; 1; 更新操作执行成功 ； 客户端 二 : 1）执行查询操作 1select * from tb_book ; 当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 select 语句 ， 立即执行 ； 5.2.4 结论锁模式的相互兼容性如表中所示： 由上表可见： 1）对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求； 2）对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作； 简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。 此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。 5.2.5 查看锁的争用情况1show open tables； In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。 Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。 1show status like &#39;Table_locks%&#39;; Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。 Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。 5.3 InnoDB 行锁5.3.1 行锁介绍行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是采用了行级锁。 5.3.2 背景知识事务及其ACID属性 事务是由一组SQL语句组成的逻辑处理单元。 事务具有以下4个特性，简称为事务ACID属性。 ACID属性 含义 原子性（Atomicity） 事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。 一致性（Consistent） 在事务开始和完成时，数据都必须保持一致状态。 隔离性（Isolation） 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。 持久性（Durable） 事务完成之后，对于数据的修改是永久的。 并发事务处理带来的问题 问题 含义 丢失更新（Lost Update） 当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。 脏读（Dirty Reads） 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。 不可重复读（Non-Repeatable Reads） 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。 幻读（Phantom Reads） 一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。 事务隔离级别 为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。 数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。 隔离级别 丢失更新 脏读 不可重复读 幻读 Read uncommitted × √ √ √ Read committed × × √ √ Repeatable read（默认） × × × √ Serializable × × × × 备注 ： √ 代表可能出现 ， × 代表不会出现 。 Mysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式： 1show variables like &#39;tx_isolation&#39;; 5.3.3 InnoDB 的行锁模式InnoDB 实现了以下两种类型的行锁。 共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。 排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)； 对于普通SELECT语句，InnoDB不会加任何锁； 可以通过以下语句显示给记录集加共享锁或排他锁 。 123共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE排他锁（X) ：SELECT * FROM table_name WHERE ... FOR UPDATE 5.3.4 案例准备工作123456789101112131415161718create table test_innodb_lock( id int(11), name varchar(16), sex varchar(1))engine &#x3D; innodb default charset&#x3D;utf8;insert into test_innodb_lock values(1,&#39;100&#39;,&#39;1&#39;);insert into test_innodb_lock values(3,&#39;3&#39;,&#39;1&#39;);insert into test_innodb_lock values(4,&#39;400&#39;,&#39;0&#39;);insert into test_innodb_lock values(5,&#39;500&#39;,&#39;1&#39;);insert into test_innodb_lock values(6,&#39;600&#39;,&#39;0&#39;);insert into test_innodb_lock values(7,&#39;700&#39;,&#39;0&#39;);insert into test_innodb_lock values(8,&#39;800&#39;,&#39;1&#39;);insert into test_innodb_lock values(9,&#39;900&#39;,&#39;1&#39;);insert into test_innodb_lock values(1,&#39;200&#39;,&#39;0&#39;);create index idx_test_innodb_lock_id on test_innodb_lock(id);create index idx_test_innodb_lock_name on test_innodb_lock(name); 5.3.5 行锁基本演示 Session-1 Session-2 关闭自动提交功能 关闭自动提交功能 可以正常的查询出全部的数据 可以正常的查询出全部的数据 查询id 为3的数据 ； 获取id为3的数据 ； 更新id为3的数据，但是不提交； 更新id为3 的数据， 出于等待状态 通过commit， 提交事务 解除阻塞，更新正常进行 以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ： 更新id为3数据，正常的获取到行锁 ， 执行更新 ； 由于与Session-1 操作不是同一行，获取当前行锁，执行更新； 5.3.6 无索引行锁升级为表锁如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。 查看当前表的索引 ： show index from test_innodb_lock ; Session-1 Session-2 关闭事务的自动提交 关闭事务的自动提交 执行更新语句 ： 执行更新语句， 但处于阻塞状态： 提交事务： 解除阻塞，执行更新成功 ： 执行提交操作 ： 由于 执行更新时 ， name字段本来为varchar类型， 我们是作为数组类型使用，存在类型转换，索引失效，最终行锁变为表锁 ； 5.3.7 间隙锁危害当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。 示例 ： Session-1 Session-2 关闭事务自动提交 关闭事务自动提交 根据id范围更新数据 插入id为2的记录， 出于阻塞状态 提交事务 ； 解除阻塞 ， 执行插入操作 ： 提交事务 ： 5.3.8 InnoDB 行锁争用情况1show status like &#39;innodb_row_lock%&#39;; 1234567891011Innodb_row_lock_current_waits: 当前正在等待锁定的数量Innodb_row_lock_time: 从系统启动到现在锁定总时间长度Innodb_row_lock_time_avg:每次等待所花平均时长Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间Innodb_row_lock_waits: 系统启动后到现在总共等待的次数当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。 5.3.9 总结InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。 但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。 优化建议： 尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。 合理设计索引，尽量缩小锁的范围 尽可能减少索引条件，及索引范围，避免间隙锁 尽量控制事务大小，减少锁定资源量和时间长度 尽可使用低级别事务隔离（但是需要业务层面满足需求） 6. 常用SQL技巧6.1 SQL执行顺序编写顺序 12345678910111213141516SELECT DISTINCT &lt;select list&gt;FROM &lt;left_table&gt; &lt;join_type&gt;JOIN &lt;right_table&gt; ON &lt;join_condition&gt;WHERE &lt;where_condition&gt;GROUP BY &lt;group_by_list&gt;HAVING &lt;having_condition&gt;ORDER BY &lt;order_by_condition&gt;LIMIT &lt;limit_params&gt; 执行顺序 1234567891011121314151617FROM &lt;left_table&gt;ON &lt;join_condition&gt;&lt;join_type&gt; JOIN &lt;right_table&gt;WHERE &lt;where_condition&gt;GROUP BY &lt;group_by_list&gt;HAVING &lt;having_condition&gt;SELECT DISTINCT &lt;select list&gt;ORDER BY &lt;order_by_condition&gt;LIMIT &lt;limit_params&gt; 6.2 正则表达式使用正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。 符号 含义 ^ 在字符串开始处进行匹配 $ 在字符串末尾处进行匹配 . 匹配任意单个字符, 包括换行符 […] 匹配出括号内的任意字符 [^…] 匹配不出括号内的任意字符 a* 匹配零个或者多个a(包括空串) a+ 匹配一个或者多个a(不包括空串) a? 匹配零个或者一个a a1|a2 匹配a1或a2 a(m) 匹配m个a a(m,) 至少匹配m个a a(m,n) 匹配m个a 到 n个a a(,n) 匹配0到n个a (…) 将模式元素组成单一元素 12345select * from emp where name regexp &#39;^T&#39;;select * from emp where name regexp &#39;2$&#39;;select * from emp where name regexp &#39;[uvw]&#39;; 6.3 MySQL 常用函数数字函数 函数名称 作 用 ABS 求绝对值 SQRT 求二次方根 MOD 求余数 CEIL 和 CEILING 两个函数功能相同，都是返回不小于参数的最小整数，即向上取整 FLOOR 向下取整，返回值转化为一个BIGINT RAND 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列 ROUND 对所传参数进行四舍五入 SIGN 返回参数的符号 POW 和 POWER 两个函数的功能相同，都是所传参数的次方的结果值 SIN 求正弦值 ASIN 求反正弦值，与函数 SIN 互为反函数 COS 求余弦值 ACOS 求反余弦值，与函数 COS 互为反函数 TAN 求正切值 ATAN 求反正切值，与函数 TAN 互为反函数 COT 求余切值 字符串函数 函数名称 作 用 LENGTH 计算字符串长度函数，返回字符串的字节长度 CONCAT 合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个 INSERT 替换字符串函数 LOWER 将字符串中的字母转换为小写 UPPER 将字符串中的字母转换为大写 LEFT 从左侧字截取符串，返回字符串左边的若干个字符 RIGHT 从右侧字截取符串，返回字符串右边的若干个字符 TRIM 删除字符串左右两侧的空格 REPLACE 字符串替换函数，返回替换后的新字符串 SUBSTRING 截取字符串，返回从指定位置开始的指定长度的字符换 REVERSE 字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串 日期函数 函数名称 作 用 CURDATE 和 CURRENT_DATE 两个函数作用相同，返回当前系统的日期值 CURTIME 和 CURRENT_TIME 两个函数作用相同，返回当前系统的时间值 NOW 和 SYSDATE 两个函数作用相同，返回当前系统的日期和时间值 MONTH 获取指定日期中的月份 MONTHNAME 获取指定日期中的月份英文名称 DAYNAME 获取指定曰期对应的星期几的英文名称 DAYOFWEEK 获取指定日期对应的一周的索引位置值 WEEK 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53 DAYOFYEAR 获取指定曰期是一年中的第几天，返回值范围是1~366 DAYOFMONTH 获取指定日期是一个月中是第几天，返回值范围是1~31 YEAR 获取年份，返回值范围是 1970〜2069 TIME_TO_SEC 将时间参数转换为秒数 SEC_TO_TIME 将秒数转换为时间，与TIME_TO_SEC 互为反函数 DATE_ADD 和 ADDDATE 两个函数功能相同，都是向日期添加指定的时间间隔 DATE_SUB 和 SUBDATE 两个函数功能相同，都是向日期减去指定的时间间隔 ADDTIME 时间加法运算，在原始时间上添加指定的时间 SUBTIME 时间减法运算，在原始时间上减去指定的时间 DATEDIFF 获取两个日期之间间隔，返回参数 1 减去参数 2 的值 DATE_FORMAT 格式化指定的日期，根据参数返回指定格式的值 WEEKDAY 获取指定日期在一周内的对应的工作日索引 聚合函数 函数名称 作用 MAX 查询指定列的最大值 MIN 查询指定列的最小值 COUNT 统计查询结果的行数 SUM 求和，返回指定列的总和 AVG 求平均值，返回指定列数据的平均值","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wgy1993.gitee.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://wgy1993.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MySQL高级教程(二)","date":"2020-05-19T09:27:28.000Z","path":"archives/621b99dc.html","text":"1. Mysql的体系结构概览整个MySQL Server由以下组成 Connection Pool : 连接池组件 Management Services &amp; Utilities : 管理服务和工具组件 SQL Interface : SQL接口组件 Parser : 查询分析器组件 Optimizer : 优化器组件 Caches &amp; Buffers : 缓冲池组件 Pluggable Storage Engines : 存储引擎 File System : 文件系统 1.1 连接层最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 1.2 服务层第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。 1.3 引擎层存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。 1.4 存储层数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。 和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 2. 存储引擎2.1 存储引擎概述和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。 存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。 Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。 MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。 可以通过指定 show engines ， 来查询当前数据库支持的存储引擎 ： 创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。 查看Mysql数据库默认的存储引擎 ， 指令 ： 1show variables like &#39;%storage_engine%&#39; ； 2.2 各种存储引擎特性下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： 特点 InnoDB MyISAM MEMORY MERGE NDB 存储限制 64TB 有 有 没有 有 事务安全 支持 锁机制 行锁(适合高并发) 表锁 表锁 表锁 行锁 B树索引 支持 支持 支持 支持 支持 哈希索引 支持 全文索引 支持(5.6版本之后) 支持 集群索引 支持 数据索引 支持 支持 支持 索引缓存 支持 支持 支持 支持 支持 数据可压缩 支持 空间使用 高 低 N/A 低 低 内存使用 高 低 中等 低 高 批量插入速度 低 高 高 高 高 支持外键 支持 下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。 2.2.1 InnoDBInnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。 InnoDB存储引擎不同于其他存储引擎的特点 ： 2.2.1.1 事务控制12345create table goods_innodb( id int NOT NULL AUTO_INCREMENT, name varchar(20) NOT NULL, primary key(id))ENGINE&#x3D;innodb DEFAULT CHARSET&#x3D;utf8; 12345start transaction;insert into goods_innodb(id,name)values(null,&#39;Meta20&#39;);commit; 测试，发现在InnoDB中是存在事务的 ； 2.2.1.2 外键约束MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。 下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。 1234567891011121314151617181920create table country_innodb( country_id int NOT NULL AUTO_INCREMENT, country_name varchar(100) NOT NULL, primary key(country_id))ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;create table city_innodb( city_id int NOT NULL AUTO_INCREMENT, city_name varchar(50) NOT NULL, country_id int NOT NULL, primary key(city_id), key idx_fk_country_id(country_id), CONSTRAINT &#96;fk_city_country&#96; FOREIGN KEY(country_id) REFERENCES country_innodb(country_id) ON DELETE RESTRICT ON UPDATE CASCADE)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;insert into country_innodb values(null,&#39;China&#39;),(null,&#39;America&#39;),(null,&#39;Japan&#39;);insert into city_innodb values(null,&#39;Xian&#39;,1),(null,&#39;NewYork&#39;,2),(null,&#39;BeiJing&#39;,1); 在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。 RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新； CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录； SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。 针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。 表中数据如下图所示 ： 外键信息可以使用如下两种方式查看 ： 1show create table city_innodb ; 删除country_id为1 的country数据： 1delete from country_innodb where country_id &#x3D; 1; 更新主表country表的字段 country_id : 1update country_innodb set country_id &#x3D; 100 where country_id &#x3D; 1; 更新后， 子表的数据信息为 ： 2.2.1.3 存储方式InnoDB 存储表和索引有以下两种方式 ： 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。 2.2.2 MyISAMMyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： 2.2.2.1 不支持事务12345create table goods_myisam( id int NOT NULL AUTO_INCREMENT, name varchar(20) NOT NULL, primary key(id))ENGINE&#x3D;myisam DEFAULT CHARSET&#x3D;utf8; 通过测试，我们发现，在MyISAM存储引擎中，是没有事务控制的 ； 2.2.2.2 文件存储方式每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： .frm (存储表定义)； .MYD(MYData , 存储数据)； .MYI(MYIndex , 存储索引)； 2.2.3 MEMORYMemory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。 2.2.4 MERGEMERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。 对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。 可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。 下面是一个创建和使用MERGE表的示例 ： 1）. 创建3个测试表 order_1990, order_1991, order_all , 其中order_all是前两个表的MERGE表 ： 1234567891011121314151617181920create table order_1990( order_id int , order_money double(10,2), order_address varchar(50), primary key (order_id))engine &#x3D; myisam default charset&#x3D;utf8;create table order_1991( order_id int , order_money double(10,2), order_address varchar(50), primary key (order_id))engine &#x3D; myisam default charset&#x3D;utf8;create table order_all( order_id int , order_money double(10,2), order_address varchar(50), primary key (order_id))engine &#x3D; merge union &#x3D; (order_1990,order_1991) INSERT_METHOD&#x3D;LAST default charset&#x3D;utf8; 2）. 分别向两张表中插入记录 12345insert into order_1990 values(1,100.0,&#39;北京&#39;);insert into order_1990 values(2,100.0,&#39;上海&#39;);insert into order_1991 values(10,200.0,&#39;北京&#39;);insert into order_1991 values(11,200.0,&#39;上海&#39;); 3）. 查询3张表中的数据。 order_1990中的数据 ： order_1991中的数据 ： order_all中的数据 ： 4）. 往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。 1insert into order_all values(100,10000.0,&#39;西安&#39;)； 2.3 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。 InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。 MyISAM ：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。 MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。 3. 优化SQL步骤在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。 当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。 3.1 查看SQL执行频率MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。 下面的命令显示了当前 session 中所有统计参数的值： 1show status like &#39;Com_______&#39;; 1show status like &#39;Innodb_rows_%&#39;; Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。 参数 含义 Com_select 执行 select 操作的次数，一次查询只累加 1。 Com_insert 执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。 Com_update 执行 UPDATE 操作的次数。 Com_delete 执行 DELETE 操作的次数。 Innodb_rows_read select 查询返回的行数。 Innodb_rows_inserted 执行 INSERT 操作插入的行数。 Innodb_rows_updated 执行 UPDATE 操作更新的行数。 Innodb_rows_deleted 执行 DELETE 操作删除的行数。 Connections 试图连接 MySQL 服务器的次数。 Uptime 服务器工作时间。 Slow_queries 慢查询的次数。 Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计。 Innodb_*** : 这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。 3.2 定位低效率执行SQL可以通过以下两种方式定位执行效率较低的 SQL 语句。 慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。 show processlist : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。 1234567891011121314151） id列，用户登录mysql时，系统分配的&quot;connection_id&quot;，可以使用函数connection_id()查看2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户4） db列，显示这个进程目前连接的是哪个数据库5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等6） time列，显示这个状态持续的时间，单位是秒7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成8） info列，显示这个sql语句，是判断问题语句的一个重要依据 3.3 explain分析执行计划通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。 查询SQL语句的执行计划 ： 1explain select * from tb_item where id &#x3D; 1; 1explain select * from tb_item where title &#x3D; &#39;阿尔卡特 (OT-979) 冰川白 联通3G手机3&#39;; 字段 含义 id select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。 select_type 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等 table 输出结果集的表 type 表示表的连接类型，性能由好到差的连接类型为( system —&gt; const —–&gt; eq_ref ——&gt; ref ——-&gt; ref_or_null—-&gt; index_merge —&gt; index_subquery —–&gt; range —–&gt; index ——&gt; all ) possible_keys 表示查询时，可能使用的索引 key 表示实际使用的索引 key_len 索引字段的长度 rows 扫描行的数量 extra 执行情况的说明和描述 3.3.1 环境准备 12345678910111213141516171819202122232425262728293031323334353637383940414243CREATE TABLE &#96;t_role&#96; ( &#96;id&#96; varchar(32) NOT NULL, &#96;role_name&#96; varchar(255) DEFAULT NULL, &#96;role_code&#96; varchar(255) DEFAULT NULL, &#96;description&#96; varchar(255) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;), UNIQUE KEY &#96;unique_role_name&#96; (&#96;role_name&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;CREATE TABLE &#96;t_user&#96; ( &#96;id&#96; varchar(32) NOT NULL, &#96;username&#96; varchar(45) NOT NULL, &#96;password&#96; varchar(96) NOT NULL, &#96;name&#96; varchar(45) NOT NULL, PRIMARY KEY (&#96;id&#96;), UNIQUE KEY &#96;unique_user_username&#96; (&#96;username&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;CREATE TABLE &#96;user_role&#96; ( &#96;id&#96; int(11) NOT NULL auto_increment , &#96;user_id&#96; varchar(32) DEFAULT NULL, &#96;role_id&#96; varchar(32) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;), KEY &#96;fk_ur_user_id&#96; (&#96;user_id&#96;), KEY &#96;fk_ur_role_id&#96; (&#96;role_id&#96;), CONSTRAINT &#96;fk_ur_role_id&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;t_role&#96; (&#96;id&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT &#96;fk_ur_user_id&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;t_user&#96; (&#96;id&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;1&#39;,&#39;super&#39;,&#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;超级管理员&#39;);insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;2&#39;,&#39;admin&#39;,&#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;系统管理员&#39;);insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;3&#39;,&#39;itcast&#39;,&#39;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#39;,&#39;test02&#39;);insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;4&#39;,&#39;stu1&#39;,&#39;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK&#x2F;y&#x2F;spH5rftCpUMZa&#39;,&#39;学生1&#39;);insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;5&#39;,&#39;stu2&#39;,&#39;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr&#x2F;p1FR6ZKgc18u.Tvqm&#39;,&#39;学生2&#39;);insert into &#96;t_user&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;, &#96;name&#96;) values(&#39;6&#39;,&#39;t1&#39;,&#39;$2a$10$TJ4TmCdK.X4wv&#x2F;tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;老师1&#39;);INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;5&#39;,&#39;学生&#39;,&#39;student&#39;,&#39;学生&#39;);INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;7&#39;,&#39;老师&#39;,&#39;teacher&#39;,&#39;老师&#39;);INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;8&#39;,&#39;教学管理员&#39;,&#39;teachmanager&#39;,&#39;教学管理员&#39;);INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;9&#39;,&#39;管理员&#39;,&#39;admin&#39;,&#39;管理员&#39;);INSERT INTO &#96;t_role&#96; (&#96;id&#96;, &#96;role_name&#96;, &#96;role_code&#96;, &#96;description&#96;) VALUES(&#39;10&#39;,&#39;超级管理员&#39;,&#39;super&#39;,&#39;超级管理员&#39;);INSERT INTO user_role(id,user_id,role_id) VALUES(NULL, &#39;1&#39;, &#39;5&#39;),(NULL, &#39;1&#39;, &#39;7&#39;),(NULL, &#39;2&#39;, &#39;8&#39;),(NULL, &#39;3&#39;, &#39;9&#39;),(NULL, &#39;4&#39;, &#39;8&#39;),(NULL, &#39;5&#39;, &#39;10&#39;) ; 3.3.2 explain 之 idid 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： 1） id 相同表示加载表的顺序是从上到下。 1explain select * from t_role r, t_user u, user_role ur where r.id &#x3D; ur.role_id and u.id &#x3D; ur.user_id ; 2） id 不同id值越大，优先级越高，越先被执行。 1EXPLAIN SELECT * FROM t_role WHERE id &#x3D; (SELECT role_id FROM user_role WHERE user_id &#x3D; (SELECT id FROM t_user WHERE username &#x3D; &#39;stu1&#39;)) 3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。 1EXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.&#96;user_id&#96; &#x3D; &#39;2&#39;) a WHERE r.id &#x3D; a.role_id ; 3.3.3 explain 之 select_type 表示 SELECT 的类型，常见的取值，如下表所示： select_type 含义 SIMPLE 简单的select查询，查询中不包含子查询或者UNION PRIMARY 查询中若包含任何复杂的子查询，最外层查询标记为该标识 SUBQUERY 在SELECT 或 WHERE 列表中包含了子查询 DERIVED 在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中 UNION 若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED UNION RESULT 从UNION表获取结果的SELECT 3.3.4 explain 之 table展示这一行的数据是关于哪一张表的 3.3.5 explain 之 typetype 显示的是访问类型，是较为重要的一个指标，可取值为： type 含义 NULL MySQL不访问任何表，索引，直接返回结果 system 表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现 const 表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常亮。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较 eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描 ref 非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个） range 只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。 index index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。 all 将遍历全表以找到匹配的行 结果值从最好到最坏以此是： 1234NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALLsystem &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。 3.3.6 explain 之 key12345possible_keys : 显示可能应用在这张表的索引， 一个或多个。 key ： 实际使用的索引， 如果为NULL， 则没有使用索引。key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。 3.3.7 explain 之 rows扫描行的数量。 3.3.8 explain 之 extra其他的额外的执行计划信息，在该列展示 。 extra 含义 using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。 using temporary 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低 using index 表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。 3.4 show profile分析SQLMysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。 通过 have_profiling 参数，能够看到当前MySQL是否支持profile： 默认profiling是关闭的，可以通过set语句在Session级别开启profiling： 1set profiling&#x3D;1; &#x2F;&#x2F;开启profiling 开关； 通过profile，我们能够更清楚地了解SQL执行的过程。 首先，我们可以执行一系列的操作，如下图所示： 123456789show databases;use db01;show tables;select * from tb_item where id &lt; 5;select count(*) from tb_item; 执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时： 通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间： 12TIP ： Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。 在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间 ： 字段 含义 Status sql 语句执行的状态 Duration sql 执行过程中每一个步骤的耗时 CPU_user 当前用户占有的cpu CPU_system 系统占有的cpu 3.5 trace分析优化器执行计划MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。 打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。 12SET optimizer_trace&#x3D;&quot;enabled&#x3D;on&quot;,end_markers_in_json&#x3D;on;set optimizer_trace_max_mem_size&#x3D;1000000; 执行SQL语句 ： 1select * from tb_item where id &lt; 4; 最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ： 1select * from information_schema.optimizer_trace\\G; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170*************************** 1. row ***************************QUERY: select * from tb_item where id &lt; 4TRACE: &#123; \"steps\": [ &#123; \"join_preparation\": &#123; \"select#\": 1, \"steps\": [ &#123; \"expanded_query\": \"/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` &lt; 4)\" &#125; ] /* steps */ &#125; /* join_preparation */ &#125;, &#123; \"join_optimization\": &#123; \"select#\": 1, \"steps\": [ &#123; \"condition_processing\": &#123; \"condition\": \"WHERE\", \"original_condition\": \"(`tb_item`.`id` &lt; 4)\", \"steps\": [ &#123; \"transformation\": \"equality_propagation\", \"resulting_condition\": \"(`tb_item`.`id` &lt; 4)\" &#125;, &#123; \"transformation\": \"constant_propagation\", \"resulting_condition\": \"(`tb_item`.`id` &lt; 4)\" &#125;, &#123; \"transformation\": \"trivial_condition_removal\", \"resulting_condition\": \"(`tb_item`.`id` &lt; 4)\" &#125; ] /* steps */ &#125; /* condition_processing */ &#125;, &#123; \"table_dependencies\": [ &#123; \"table\": \"`tb_item`\", \"row_may_be_null\": false, \"map_bit\": 0, \"depends_on_map_bits\": [ ] /* depends_on_map_bits */ &#125; ] /* table_dependencies */ &#125;, &#123; \"ref_optimizer_key_uses\": [ ] /* ref_optimizer_key_uses */ &#125;, &#123; \"rows_estimation\": [ &#123; \"table\": \"`tb_item`\", \"range_analysis\": &#123; \"table_scan\": &#123; \"rows\": 9816098, \"cost\": 2.04e6 &#125; /* table_scan */, \"potential_range_indices\": [ &#123; \"index\": \"PRIMARY\", \"usable\": true, \"key_parts\": [ \"id\" ] /* key_parts */ &#125; ] /* potential_range_indices */, \"setup_range_conditions\": [ ] /* setup_range_conditions */, \"group_index_range\": &#123; \"chosen\": false, \"cause\": \"not_group_by_or_distinct\" &#125; /* group_index_range */, \"analyzing_range_alternatives\": &#123; \"range_scan_alternatives\": [ &#123; \"index\": \"PRIMARY\", \"ranges\": [ \"id &lt; 4\" ] /* ranges */, \"index_dives_for_eq_ranges\": true, \"rowid_ordered\": true, \"using_mrr\": false, \"index_only\": false, \"rows\": 3, \"cost\": 1.6154, \"chosen\": true &#125; ] /* range_scan_alternatives */, \"analyzing_roworder_intersect\": &#123; \"usable\": false, \"cause\": \"too_few_roworder_scans\" &#125; /* analyzing_roworder_intersect */ &#125; /* analyzing_range_alternatives */, \"chosen_range_access_summary\": &#123; \"range_access_plan\": &#123; \"type\": \"range_scan\", \"index\": \"PRIMARY\", \"rows\": 3, \"ranges\": [ \"id &lt; 4\" ] /* ranges */ &#125; /* range_access_plan */, \"rows_for_plan\": 3, \"cost_for_plan\": 1.6154, \"chosen\": true &#125; /* chosen_range_access_summary */ &#125; /* range_analysis */ &#125; ] /* rows_estimation */ &#125;, &#123; \"considered_execution_plans\": [ &#123; \"plan_prefix\": [ ] /* plan_prefix */, \"table\": \"`tb_item`\", \"best_access_path\": &#123; \"considered_access_paths\": [ &#123; \"access_type\": \"range\", \"rows\": 3, \"cost\": 2.2154, \"chosen\": true &#125; ] /* considered_access_paths */ &#125; /* best_access_path */, \"cost_for_plan\": 2.2154, \"rows_for_plan\": 3, \"chosen\": true &#125; ] /* considered_execution_plans */ &#125;, &#123; \"attaching_conditions_to_tables\": &#123; \"original_condition\": \"(`tb_item`.`id` &lt; 4)\", \"attached_conditions_computation\": [ ] /* attached_conditions_computation */, \"attached_conditions_summary\": [ &#123; \"table\": \"`tb_item`\", \"attached\": \"(`tb_item`.`id` &lt; 4)\" &#125; ] /* attached_conditions_summary */ &#125; /* attaching_conditions_to_tables */ &#125;, &#123; \"refine_plan\": [ &#123; \"table\": \"`tb_item`\", \"access_type\": \"range\" &#125; ] /* refine_plan */ &#125; ] /* steps */ &#125; /* join_optimization */ &#125;, &#123; \"join_execution\": &#123; \"select#\": 1, \"steps\": [ ] /* steps */ &#125; /* join_execution */ &#125; ] /* steps */&#125; 4. 索引的使用索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。 4.1 验证索引提升查询效率在我们准备的表结构tb_item 中， 一共存储了 300 万记录； 1). 根据ID查询 1select * from tb_item where id &#x3D; 1999\\G; 查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引； 2). 根据 title 进行精确查询 1select * from tb_item where title &#x3D; &#39;iphoneX 移动3G 32G941&#39;\\G; 查看SQL语句的执行计划 ： 处理方案 ， 针对title字段， 创建索引 ： 1create index idx_item_title on tb_item(title); 索引创建完成之后，再次进行查询 ： 通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引 4.2 索引的使用4.2.1 准备环境12345678910111213141516171819202122232425create table &#96;tb_seller&#96; ( &#96;sellerid&#96; varchar (100), &#96;name&#96; varchar (100), &#96;nickname&#96; varchar (50), &#96;password&#96; varchar (60), &#96;status&#96; varchar (1), &#96;address&#96; varchar (100), &#96;createtime&#96; datetime, primary key(&#96;sellerid&#96;))engine&#x3D;innodb default charset&#x3D;utf8mb4; insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;alibaba&#39;,&#39;阿里巴巴&#39;,&#39;阿里小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;baidu&#39;,&#39;百度科技有限公司&#39;,&#39;百度小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;huawei&#39;,&#39;华为科技有限公司&#39;,&#39;华为小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;itcast&#39;,&#39;传智播客教育科技有限公司&#39;,&#39;传智播客&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;itheima&#39;,&#39;黑马程序员&#39;,&#39;黑马程序员&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;luoji&#39;,&#39;罗技科技有限公司&#39;,&#39;罗技小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;oppo&#39;,&#39;OPPO科技有限公司&#39;,&#39;OPPO官方旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;ourpalm&#39;,&#39;掌趣科技股份有限公司&#39;,&#39;掌趣小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;qiandu&#39;,&#39;千度科技&#39;,&#39;千度小店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;2&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;sina&#39;,&#39;新浪科技有限公司&#39;,&#39;新浪官方旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;xiaomi&#39;,&#39;小米科技&#39;,&#39;小米官方旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;西安市&#39;,&#39;2088-01-01 12:00:00&#39;);insert into &#96;tb_seller&#96; (&#96;sellerid&#96;, &#96;name&#96;, &#96;nickname&#96;, &#96;password&#96;, &#96;status&#96;, &#96;address&#96;, &#96;createtime&#96;) values(&#39;yijia&#39;,&#39;宜家家居&#39;,&#39;宜家家居旗舰店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);create index idx_seller_name_sta_addr on tb_seller(name,status,address); 4.2.2 避免索引失效1). 全值匹配 ，对索引中所有列都指定具体值。 改情况下，索引生效，执行效率高。 1explain select * from tb_seller where name&#x3D;&#39;小米科技&#39; and status&#x3D;&#39;1&#39; and address&#x3D;&#39;北京市&#39;\\G; 2). 最左前缀法则 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。 匹配最左前缀法则，走索引： 违法最左前缀法则 ， 索引失效： 如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效： 3). 范围查询右边的列，不能使用索引 。 根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。 4). 不要在索引列上进行运算操作， 索引将失效。 5). 字符串不加单引号，造成索引失效。 由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。 6). 尽量使用覆盖索引，避免select * 尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。 如果查询列，超出索引列，也会降低性能。 123456789TIP : using index ：使用覆盖索引的时候就会出现 using where：在查找使用索引的情况下，需要回表去查询所需的数据 using index condition：查找使用了索引，但是需要回表查询数据 using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 7). 用or分割开的条件 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。 示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ： 1explain select * from tb_seller where name&#x3D;&#39;黑马程序员&#39; or createtime &#x3D; &#39;2088-01-01 12:00:00&#39;\\G; 8). 以%开头的Like模糊查询，索引失效。 如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。 解决方案 ： 通过覆盖索引来解决 9). 如果MySQL评估使用索引比全表更慢，则不使用索引。 10). is NULL ， is NOT NULL 有时索引失效。 11). in 走索引， not in 索引失效。 12). 单列索引和复合索引。 尽量使用复合索引，而少使用单列索引 。 创建复合索引 123456create index idx_name_sta_address on tb_seller(name, status, address);就相当于创建了三个索引 ： name name + status name + status + address 创建单列索引 123create index idx_seller_name on tb_seller(name);create index idx_seller_status on tb_seller(status);create index idx_seller_address on tb_seller(address); 数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。 4.3 查看索引使用情况123show status like &#39;Handler_read%&#39;; show global status like &#39;Handler_read%&#39;; 1234567891011Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。 5. SQL优化5.1 大批量插入数据环境准备 ： 12345678910111213141516CREATE TABLE &#96;tb_user_2&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;username&#96; varchar(45) NOT NULL, &#96;password&#96; varchar(96) NOT NULL, &#96;name&#96; varchar(45) NOT NULL, &#96;birthday&#96; datetime DEFAULT NULL, &#96;sex&#96; char(1) DEFAULT NULL, &#96;email&#96; varchar(45) DEFAULT NULL, &#96;phone&#96; varchar(45) DEFAULT NULL, &#96;qq&#96; varchar(32) DEFAULT NULL, &#96;status&#96; varchar(32) NOT NULL COMMENT &#39;用户状态&#39;, &#96;create_time&#96; datetime NOT NULL, &#96;update_time&#96; datetime DEFAULT NULL, PRIMARY KEY (&#96;id&#96;), UNIQUE KEY &#96;unique_user_username&#96; (&#96;username&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 ; 当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。 对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率： 1） 主键顺序插入 因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。 123脚本文件介绍 : sql1.log ----&gt; 主键有序 sql2.log ----&gt; 主键无序 插入ID顺序排列数据： 插入ID无序排列数据： 2） 关闭唯一性校验 在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。 3） 手动提交事务 如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。 5.2 优化insert语句当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。 如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。 示例， 原始方式为： 123insert into tb_test values(1,&#39;Tom&#39;);insert into tb_test values(2,&#39;Cat&#39;);insert into tb_test values(3,&#39;Jerry&#39;); 优化后的方案为 ： 1insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;)，(3,&#39;Jerry&#39;); 在事务中进行数据插入。 12345start transaction;insert into tb_test values(1,&#39;Tom&#39;);insert into tb_test values(2,&#39;Cat&#39;);insert into tb_test values(3,&#39;Jerry&#39;);commit; 数据有序插入 12345insert into tb_test values(4,&#39;Tim&#39;);insert into tb_test values(1,&#39;Tom&#39;);insert into tb_test values(3,&#39;Jerry&#39;);insert into tb_test values(5,&#39;Rose&#39;);insert into tb_test values(2,&#39;Cat&#39;); 优化后 12345insert into tb_test values(1,&#39;Tom&#39;);insert into tb_test values(2,&#39;Cat&#39;);insert into tb_test values(3,&#39;Jerry&#39;);insert into tb_test values(4,&#39;Tim&#39;);insert into tb_test values(5,&#39;Rose&#39;); 5.3 优化order by语句5.3.1 环境准备12345678910111213141516171819202122CREATE TABLE &#96;emp&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;name&#96; varchar(100) NOT NULL, &#96;age&#96; int(3) NOT NULL, &#96;salary&#96; int(11) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;1&#39;,&#39;Tom&#39;,&#39;25&#39;,&#39;2300&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;2&#39;,&#39;Jerry&#39;,&#39;30&#39;,&#39;3500&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;3&#39;,&#39;Luci&#39;,&#39;25&#39;,&#39;2800&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;4&#39;,&#39;Jay&#39;,&#39;36&#39;,&#39;3500&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;5&#39;,&#39;Tom2&#39;,&#39;21&#39;,&#39;2200&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;6&#39;,&#39;Jerry2&#39;,&#39;31&#39;,&#39;3300&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;7&#39;,&#39;Luci2&#39;,&#39;26&#39;,&#39;2700&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;8&#39;,&#39;Jay2&#39;,&#39;33&#39;,&#39;3500&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;9&#39;,&#39;Tom3&#39;,&#39;23&#39;,&#39;2400&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;10&#39;,&#39;Jerry3&#39;,&#39;32&#39;,&#39;3100&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;11&#39;,&#39;Luci3&#39;,&#39;26&#39;,&#39;2900&#39;);insert into &#96;emp&#96; (&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;salary&#96;) values(&#39;12&#39;,&#39;Jay3&#39;,&#39;37&#39;,&#39;4500&#39;);create index idx_emp_age_salary on emp(age,salary); 5.3.2 两种排序方式1). 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 2). 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。 多字段排序 了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。 5.3.3 Filesort 的优化通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法： 1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。 2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。 MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。 可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。 5.4 优化group by 语句由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。 如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ： 123drop index idx_emp_age_salary on emp;explain select age,count(*) from emp group by age; 优化后 1explain select age,count(*) from emp group by age order by null; 从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order by null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。 创建索引 ： 1create index idx_emp_age_salary on emp(age,salary)； 5.5 优化嵌套查询Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。 示例 ，查找有角色的所有的用户信息 : 1explain select * from t_user where id in (select user_id from user_role ); 执行计划为 : 优化后 : 1explain select * from t_user u , user_role ur where u.id &#x3D; ur.user_id; 连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。 5.6 优化OR条件对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。 获取 emp 表中的所有的索引 ： 示例 ： 1explain select * from emp where id &#x3D; 1 or age &#x3D; 30; 建议使用 union 替换 or ： 我们来比较下重要指标，发现主要差别是 type 和 ref 这两项 type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： 1system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距 UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快 这两项的差距就说明了 UNION 要优于 OR 。 5.7 优化分页查询一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。 5.7.1 优化思路一在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。 5.7.2 优化思路二该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。 5.8 使用SQL提示SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 5.8.1 USE INDEX在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。 1create index idx_seller_name on tb_seller(name); 5.8.2 IGNORE INDEX如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。 1explain select * from tb_seller ignore index(idx_seller_name) where name &#x3D; &#39;小米科技&#39;; 5.8.3 FORCE INDEX为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 1create index idx_seller_address on tb_seller(address);","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wgy1993.gitee.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://wgy1993.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MySQL高级教程(一)","date":"2020-05-18T03:20:04.000Z","path":"archives/cd2a02be.html","text":"1. 索引1.1 索引概述MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。 1.2 索引优势劣势优势： 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。 劣势： 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。 1.3 索引结构索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引： BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。 HASH 索引：只有Memory引擎支持 ， 使用场景简单 。 R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。 Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。 MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持 索引 InnoDB引擎 MyISAM引擎 Memory引擎 BTREE索引 支持 支持 支持 HASH 索引 不支持 不支持 支持 R-tree 索引 不支持 支持 不支持 Full-text 5.6版本之后支持 支持 不支持 我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为索引。 1.3.1 BTREE 结构BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下： 树中每个节点最多包含m个孩子。 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。 若根节点不是叶子节点，则至少有两个孩子。 所有的叶子节点都在同一层。 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1 以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。 插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。 演变过程如下： 1). 插入前4个字母 C N G A 2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点 3). 插入E，K，Q不需要分裂 4). 插入M，中间元素M字母向上分裂到父节点G 5). 插入F，W，L，T不需要分裂 6). 插入Z，中间元素T向上分裂到父节点中 7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂 8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂 到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。 1.3.2 B+TREE 结构B+Tree为BTree的变种，B+Tree与BTree的区别为： n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。 B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。 所有的非叶子节点都可以看作是key的索引部分。 由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。 1.3.3 MySQL中的B+TreeMySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。 MySQL中的 B+Tree 索引结构示意图: 1.4 索引分类 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引 唯一索引 ：索引列的值必须唯一，但允许有空值 复合索引 ：即一个索引包含多个列 1.5 索引语法索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。 准备环境: 123456789101112131415161718192021222324252627create database demo_01 default charset&#x3D;utf8mb4;use demo_01;CREATE TABLE &#96;city&#96; ( &#96;city_id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;city_name&#96; varchar(50) NOT NULL, &#96;country_id&#96; int(11) NOT NULL, PRIMARY KEY (&#96;city_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;CREATE TABLE &#96;country&#96; ( &#96;country_id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;country_name&#96; varchar(100) NOT NULL, PRIMARY KEY (&#96;country_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(1,&#39;西安&#39;,1);insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(2,&#39;NewYork&#39;,2);insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(3,&#39;北京&#39;,1);insert into &#96;city&#96; (&#96;city_id&#96;, &#96;city_name&#96;, &#96;country_id&#96;) values(4,&#39;上海&#39;,1);insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(1,&#39;China&#39;);insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(2,&#39;America&#39;);insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(3,&#39;Japan&#39;);insert into &#96;country&#96; (&#96;country_id&#96;, &#96;country_name&#96;) values(4,&#39;UK&#39;); 1.5.1 创建索引语法 ： 12345CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type]ON tbl_name(index_col_name,...)index_col_name : column_name[(length)][ASC | DESC] 示例 ： 为city表中的city_name字段创建索引 ； 1.5.2 查看索引语法： 1show index from table_name; 示例： 查看city表中的索引信息； 1.5.3 删除索引语法 ： 1DROP INDEX index_name ON tbl_name; 示例 ： 想要删除city表上的索引idx_city_name，可以操作如下： 1.5.4 ALTER命令1234567891011121314151). alter table tb_name add primary key(column_list); 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL 2). alter table tb_name add unique index_name(column_list); 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次） 3). alter table tb_name add index index_name(column_list); 添加普通索引， 索引值可以出现多次。 4). alter table tb_name add fulltext index_name(column_list); 该语句指定了索引为FULLTEXT， 用于全文索引 1.6 索引设计原则索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。 12345678创建复合索引: CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ; 2. 视图2.1 视图概述视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 视图相对于普通的表的优势主要包括以下几项。 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 2.2 创建或者修改视图创建视图的语法为： 1234567CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 修改视图的语法为： 1234567ALTER [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 12345选项 : WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。 LOCAL ： 只要满足本视图的条件就可以更新。 CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值. 示例： 创建city_country_view视图 , 执行如下SQL : 123create or replace view city_country_view as select t.*,c.country_name from country c , city t where c.country_id &#x3D; t.country_id; 查询视图 : 2.3 查看视图从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。 同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。 如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： 2.4 删除视图语法 : 1DROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADE] 示例： 删除视图city_country_view : 1DROP VIEW city_country_view; 3. 存储过程和函数3.1 存储过程和函数概述存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程和函数的区别在于函数必须有返回值，而存储过程没有。 函数 ： 是一个有返回值的过程 ； 过程 ： 是一个没有返回值的函数 ； 3.2 创建存储过程1234CREATE PROCEDURE procedure_name ([proc_parameter[,...]])begin -- SQL语句end; 示例 ： 12345678delimiter $create procedure pro_test1()begin select &#39;Hello Mysql&#39; ;end$delimiter ; 知识小贴士 DELIMITER 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。 3.3 调用存储过程1call procedure_name() ; 3.4 查看存储过程12345678-- 查询db_name数据库中的所有的存储过程select name from mysql.proc where db&#x3D;&#39;db_name&#39;;-- 查询存储过程的状态信息show procedure status;-- 查询某个存储过程的定义show create procedure test.pro_test1 \\G; 3.5 删除存储过程1DROP PROCEDURE [IF EXISTS] sp_name ; 3.6 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 3.6.1 变量 DECLARE 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 1DECLARE var_name[,...] type [DEFAULT value] 示例 : 123456789delimiter $create procedure pro_test2() begin declare num int default 5; select num + 10; end$delimiter ; SET 直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： 1SET var_name &#x3D; expr [, var_name &#x3D; expr] ... 示例 : 12345678910DELIMITER $ CREATE PROCEDURE pro_test3()BEGIN DECLARE NAME VARCHAR(20); SET NAME &#x3D; &#39;MYSQL&#39;; SELECT NAME ;END$ DELIMITER ; 也可以通过select … into 方式进行赋值操作 : 12345678910DELIMITER $CREATE PROCEDURE pro_test5()BEGIN declare countnum int; select count(*) into countnum from city; select countnum;END$DELIMITER ; 3.6.2 if条件判断语法结构 : 1234567if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; 需求： 1234567根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ----------&gt; 身材高挑 170 - 180 ---------&gt; 标准身材 170 以下 ----------&gt; 一般身材 示例 : 12345678910111213141516171819delimiter $create procedure pro_test6()begin declare height int default 175; declare description varchar(50); if height &gt;&#x3D; 180 then set description &#x3D; &#39;身材高挑&#39;; elseif height &gt;&#x3D; 170 and height &lt; 180 then set description &#x3D; &#39;中等身材&#39;; else set description &#x3D; &#39;一般身材&#39;; end if; select description ;end$delimiter ; 调用结果为 : 3.6.3 传递参数语法格式 : 1234567create procedure procedure_name([in&#x2F;out&#x2F;inout] 参数名 参数类型)...IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认OUT: 该参数作为输出，也就是该参数可以作为返回值INOUT: 既可以作为输入参数，也可以作为输出参数 3.6.3.1 IN - 输入需求 : 1根据定义的身高变量，判定当前身高的所属的身材类型 示例 : 12345678910111213141516delimiter $create procedure pro_test5(in height int)begin declare description varchar(50) default &#39;&#39;; if height &gt;&#x3D; 180 then set description&#x3D;&#39;身材高挑&#39;; elseif height &gt;&#x3D; 170 and height &lt; 180 then set description&#x3D;&#39;标准身材&#39;; else set description&#x3D;&#39;一般身材&#39;; end if; select concat(&#39;身高&#39;, height , &#39;对应的身材类型为:&#39;,description);end$delimiter ; 3.6.3.2 OUT-输出 需求 : 1根据传入的身高变量，获取当前身高的所属的身材类型 示例: 12345678910create procedure pro_test5(in height int , out description varchar(100))begin if height &gt;&#x3D; 180 then set description&#x3D;&#39;身材高挑&#39;; elseif height &gt;&#x3D; 170 and height &lt; 180 then set description&#x3D;&#39;标准身材&#39;; else set description&#x3D;&#39;一般身材&#39;; end if;end$ 调用: 123call pro_test5(168, @description)$select @description$ 小知识 @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 @@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做系统变量 3.6.4 case结构语法结构 : 1234567891011121314151617181920212223方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE;方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 需求: 1给定一个月份, 然后计算出所在的季度 示例 : 123456789101112131415161718192021delimiter $create procedure pro_test9(month int)begin declare result varchar(20); case when month &gt;&#x3D; 1 and month &lt;&#x3D;3 then set result &#x3D; &#39;第一季度&#39;; when month &gt;&#x3D; 4 and month &lt;&#x3D;6 then set result &#x3D; &#39;第二季度&#39;; when month &gt;&#x3D; 7 and month &lt;&#x3D;9 then set result &#x3D; &#39;第三季度&#39;; when month &gt;&#x3D; 10 and month &lt;&#x3D;12 then set result &#x3D; &#39;第四季度&#39;; end case; select concat(&#39;您输入的月份为 :&#39;, month , &#39; , 该月份为 : &#39; , result) as content ; end$delimiter ; 3.6.5 while循环语法结构: 12345while search_condition do statement_list end while; 需求: 1计算从1加到n的值 示例 : 1234567891011121314delimiter $create procedure pro_test8(n int)begin declare total int default 0; declare num int default 1; while num&lt;&#x3D;n do set total &#x3D; total + num; set num &#x3D; num + 1; end while; select total;end$delimiter ; 3.6.6 repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 语法结构 : 1234567REPEAT statement_list UNTIL search_conditionEND REPEAT; 需求: 1计算从1加到n的值 示例 : 1234567891011121314151617delimiter $create procedure pro_test10(n int)begin declare total int default 0; repeat set total &#x3D; total + n; set n &#x3D; n - 1; until n&#x3D;0 end repeat; select total ; end$delimiter ; 3.6.7 loop语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下： 12345[begin_label:] LOOP statement_listEND LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 3.6.8 leave语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： 123456789101112131415161718192021delimiter $CREATE PROCEDURE pro_test11(n int)BEGIN declare total int default 0; ins: LOOP IF n &lt;&#x3D; 0 then leave ins; END IF; set total &#x3D; total + n; set n &#x3D; n - 1; END LOOP ins; select total;END$delimiter ; 3.6.9 游标/光标游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。 声明光标： 1DECLARE cursor_name CURSOR FOR select_statement ; OPEN 光标： 1OPEN cursor_name ; FETCH 光标： 1FETCH cursor_name INTO var_name [, var_name] ... CLOSE 光标： 1CLOSE cursor_name ; 示例 : 初始化脚本: 123456789create table emp( id int(11) not null auto_increment , name varchar(50) not null comment &#39;姓名&#39;, age int(11) comment &#39;年龄&#39;, salary int(11) comment &#39;薪水&#39;, primary key(&#96;id&#96;))engine&#x3D;innodb default charset&#x3D;utf8 ;insert into emp(id,name,age,salary) values(null,&#39;金毛狮王&#39;,55,3800),(null,&#39;白眉鹰王&#39;,60,4000),(null,&#39;青翼蝠王&#39;,38,2800),(null,&#39;紫衫龙王&#39;,42,1800); 12345678910111213141516171819202122232425262728-- 查询emp表中数据, 并逐行获取进行展示create procedure pro_test11()begin declare e_id int(11); declare e_name varchar(50); declare e_age int(11); declare e_salary int(11); declare emp_result cursor for select * from emp; open emp_result; fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#39;id&#x3D;&#39;,e_id , &#39;, name&#x3D;&#39;,e_name, &#39;, age&#x3D;&#39;, e_age, &#39;, 薪资为: &#39;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#39;id&#x3D;&#39;,e_id , &#39;, name&#x3D;&#39;,e_name, &#39;, age&#x3D;&#39;, e_age, &#39;, 薪资为: &#39;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#39;id&#x3D;&#39;,e_id , &#39;, name&#x3D;&#39;,e_name, &#39;, age&#x3D;&#39;, e_age, &#39;, 薪资为: &#39;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#39;id&#x3D;&#39;,e_id , &#39;, name&#x3D;&#39;,e_name, &#39;, age&#x3D;&#39;, e_age, &#39;, 薪资为: &#39;,e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat(&#39;id&#x3D;&#39;,e_id , &#39;, name&#x3D;&#39;,e_name, &#39;, age&#x3D;&#39;, e_age, &#39;, 薪资为: &#39;,e_salary); close emp_result;end$ 通过循环结构 , 获取游标中的数据 : 12345678910111213141516171819202122232425DELIMITER $create procedure pro_test12()begin DECLARE id int(11); DECLARE name varchar(50); DECLARE age int(11); DECLARE salary int(11); DECLARE has_data int default 1; DECLARE emp_result CURSOR FOR select * from emp; DECLARE EXIT HANDLER FOR NOT FOUND set has_data &#x3D; 0; open emp_result; repeat fetch emp_result into id , name , age , salary; select concat(&#39;id为&#39;,id, &#39;, name 为&#39; ,name , &#39;, age为 &#39; ,age , &#39;, 薪水为: &#39;, salary); until has_data &#x3D; 0 end repeat; close emp_result;end$DELIMITER ; 3.7 存储函数语法结构: 12345CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ...END; 案例 : 定义一个存储过程, 请求满足条件的总记录数 ; 12345678910111213delimiter $create function count_city(countryId int)returns intbegin declare cnum int ; select count(*) into cnum from city where country_id &#x3D; countryId; return cnum;end$delimiter ; 调用: 123select count_city(1);select count_city(2); 4. 触发器4.1 介绍触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 4.2 创建触发器语法结构 : 12345678910111213create trigger trigger_name before&#x2F;after insert&#x2F;update&#x2F;deleteon tbl_name [ for each row ] -- 行级触发器begin trigger_stmt ;end; 示例 : 需求 1通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ; 首先创建一张日志表 : 12345678create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment &#39;操作类型, insert&#x2F;update&#x2F;delete&#39;, operate_time datetime not null comment &#39;操作时间&#39;, operate_id int(11) not null comment &#39;操作表的ID&#39;, operate_params varchar(500) comment &#39;操作参数&#39;, primary key(&#96;id&#96;))engine&#x3D;innodb default charset&#x3D;utf8; 创建 insert 型触发器，完成插入数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_insert_triggerafter insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#39;insert&#39;,now(),new.id,concat(&#39;插入后(id:&#39;,new.id,&#39;, name:&#39;,new.name,&#39;, age:&#39;,new.age,&#39;, salary:&#39;,new.salary,&#39;)&#39;)); end $DELIMITER ; 创建 update 型触发器，完成更新数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_update_triggerafter update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#39;update&#39;,now(),new.id,concat(&#39;修改前(id:&#39;,old.id,&#39;, name:&#39;,old.name,&#39;, age:&#39;,old.age,&#39;, salary:&#39;,old.salary,&#39;) , 修改后(id&#39;,new.id, &#39;name:&#39;,new.name,&#39;, age:&#39;,new.age,&#39;, salary:&#39;,new.salary,&#39;)&#39;)); end $DELIMITER ; 创建delete 行的触发器 , 完成删除数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_delete_triggerafter delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,&#39;delete&#39;,now(),old.id,concat(&#39;删除前(id:&#39;,old.id,&#39;, name:&#39;,old.name,&#39;, age:&#39;,old.age,&#39;, salary:&#39;,old.salary,&#39;)&#39;)); end $DELIMITER ; 测试： 123456insert into emp(id,name,age,salary) values(null, &#39;光明左使&#39;,30,3500);insert into emp(id,name,age,salary) values(null, &#39;光明右使&#39;,33,3200);update emp set age &#x3D; 39 where id &#x3D; 3;delete from emp where id &#x3D; 5; 4.3 删除触发器语法结构 : 1drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 4.4 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 语法结构 ： 1show triggers;","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wgy1993.gitee.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://wgy1993.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"使用hexo+github搭建免费个人博客","date":"2020-05-15T11:40:37.000Z","path":"archives/52429b60.html","text":"前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi wgy1993! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置： 12$ git config --global user.name &quot;yourname&quot;&#x2F;&#x2F; 你的github用户名，非昵称$ git config --global user.email &quot;xxx@163.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱 具体这个配置是干嘛的我没仔细深究。 使用hexo写博客hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装1$ npm install -g hexo 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\\MyGitWorkSpace\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /e/MyGitWorkSpace/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了 浏览目录 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： 12$ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里： 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法： 1234deploy: type: git repository: git@github.com:wgy1993&#x2F;wgy1993.github.io.git branch: master 错误写法： 1234deploy: type: github repository: https:&#x2F;&#x2F;github.com&#x2F;wgy1993&#x2F;wgy1993.github.io.git branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件： 1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 保留README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 常用hexo命令常见命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写： 1234hexo n &#x3D;&#x3D; hexo newhexo g &#x3D;&#x3D; hexo generatehexo s &#x3D;&#x3D; hexo serverhexo d &#x3D;&#x3D; hexo deploy 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 写博客定位到我们的hexo根目录，执行命令： 1hexo new &#39;my-first-blog&#39; hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 那么hexo new page &#39;postName&#39;命令和hexo new &#39;postName&#39;有什么区别呢？ 1hexo new page &quot;my-second-blog&quot; 生成如下： 最终部署时生成：hexo\\public\\my-second-blog\\index.html，但是它不会作为文章出现在博文目录。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上``即可，例如： 12345678910111213# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； 最终效果：","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wgy1993.gitee.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://wgy1993.gitee.io/tags/GitHub/"}]},{"title":"Git","date":"2020-04-22T10:07:41.000Z","path":"archives/69c3279c.html","text":"1. Git 简介1.1 版本控制版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 本地版本控制系统：采用某种简单的数据库来记录文件的历次更新差异（RCS）； 集中化的版本控制系统（ CVCS）：有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 分布式版本控制系统（DVCS）：客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 Git 是一个分布式版本控制管理软件。 1.2 Git特点 直接记录快照，而非差异比较。Git 和其它版本控制系统的主要差别在于 Git 对待数据的方法: 其它大部分系统以文件变更列表的方式存储信息。这类系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。 Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个 快照流。 近乎所有操作都是本地执行 Git保证完整性 2. Git 使用交互流程 3. 安装和配置 Git 环境下载地址：https://git-scm.com/ 环境配置：Git安装bin目录加入系统patch中 4. 初始化配置12345678# 设置用户名git config --global user.name \"你的名字\"# 配置用户邮箱git config --global user.email \"你的常用邮箱\"# 设置 gitk 图形查看工具中文显示默认编码（防止乱码）git config --global gui.encoding utf-8# 查看配置列表项git config --list 5. 基本使用12345678910111213141516git init 初始化一个 Git 仓库git status 查看当前工作区、暂存区、本地仓库的状态git add 添加文件到暂存区git commit 文件提交暂存区到仓库区 示例：git commit -m &quot;日志说明&quot; --author&#x3D;&quot;操作者姓名 &lt;邮箱&gt;&quot; 执行 git commit 的时候，Git 会要求具有用户名和邮箱的参数选项,可以通过 git config 命令配置一下用户名和邮箱git log 查看提交历史gitk 图形查看提交历史工具 总结：操作 Git 的基本工作流程就是先修改文件，然后执行 git add 命令。git add 命令会把文件加入到暂存区，接着就可以执行 git commit 命令，将文件存入文档库，从而形成一次历史记录 5.1 添加/删除文件1234567891011121314151617# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 5.2 代码提交123456789101112131415# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 5.3 回退撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 5.4 分支管理默认在 git 的仓库中，会有个分支的原点：master 1234567891011121314151617181920# 列出所有本地分支git branch# 基于当前分支新建一个分支，但依然停留在当前分支git branch [branch-name]# 基于当前分支新建一个分支，并切换到该分支git checkout -b [branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支，交替和上一个分支进行切换git checkout -# 合并指定分支到当前分支git merge [branch]# 删除分支git branch -d [branch-name] 5.5 远程操作1234567891011121314151617181920# 下载一个远程仓库git clone [url]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force 本地已有仓库，需要提交到线上： 如果是 git init 出来的仓库，进行 push 提交的时候就不知道要往哪里 push。 所以，这里通过 remote 相关命令进行设置： 123456# 查看所有的远程仓库信息git remote show# 根据别名查看指定的远程仓库信息git remote show 远程仓库地址别名# 添加远程仓库信息git remote add 别名 远程仓库地址 通过上面的 git remote add 添加完远程仓库地址信息之后，还不能直接 git push，必须在每一次push 的时候加上 git push 仓库地址别名 master 就可以提交了。 如果想要省略 git push 后面需要指定的 仓库地址别名 master 可以通过下面的命令修改： 1git push --set-upstream wgy master 这样就可以直接使用 git pish 进行提交而不需要指定 wgy master 了 6. Git 工作流程：分支策略6.1 Git Flow 6.2 Github Collabrators这种方式公司团队项目使用居多 6.3 Github Flow这种方式开源项目使用居多 fork clone 到你的本地 在clone下来的项目中拉出一个新的分支 修改的时候最好是基于 master 拉出一个修改的分支，例如这个分支是用来添加某个功能的 在新分支上开发或者修改完成之后，提交到本地仓库，然后 push 推到自己的账户中 fork 过来的仓库 最后，在 Github 上你 fork 过来的仓库界面中找到 New Pull Request 发起提交请求 对方就会在仓库的 Pull Requests 中收到你发起的提交请求 然后双方就可以使用社会化交流方式进行沟通协作 例如 Code Review 代码审查 最后对方审查通过没有问题之后，选择 Merge Request 到此，一个完整的 Github 工作流结束 这种方式开源项目更多一些（大家都不认识） 7. Github Github 就是程序员的新浪微博它可以让你使用社交化的方式进行编程协作、 - 点赞 - 评论 - 转发 - etc.主要作用：可以免费在线托管你的仓库可以实现多人协作提供了一个可视化界面（Web Page）让你能直观清晰的了解你的项目源代码 7.1 基本使用 注册 登陆 创建远程仓库 通过 git clone 命令下载远程仓库到本地 git clone 会自动帮你把远程仓库下载到本地，不需要再去 git init 了 通过 clone 下来的仓库，git 有一个远程仓库地址列表，git 默认会把你 clone 的地址起一个别名：origin 然后你执行 push 的时候实际上就是将本地的版本提交到 origin 上 在本地进行操作，通过 git commit 形成历史记录 通过 git push 将本地仓库中的历史记录提交到远程仓库 7.2 Github PagesGithub Pages 提供了一个免费在线托管静态资源的服务，叫做：Github Pages。 使用方法如下： 在个人的 Github 账户中创建一个仓库 仓库名称必须为 个人账户名称.github.io 往该仓库根目录中提交一个 index.html 文件 然后就可以在地址栏输入 个人账户名称.github.io 地址，就可以看到 index.html 网页内容了 注意：上面创建的仓库名称必须是 个人账户名称.github.io ，否则无法访问","tags":[{"name":"项目管理","slug":"项目管理","permalink":"https://wgy1993.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"Git","slug":"Git","permalink":"https://wgy1993.gitee.io/tags/Git/"}]},{"title":"Node.js(二)","date":"2020-04-21T07:29:47.000Z","path":"archives/543e3a79.html","text":"1. Web开发概述传统的动态网站开发需要应用软件 PHP ： Apache + php模块 java ：Tomcat 、Weblogic Node.js : 不需要应用软件（可以自己实现） Node.js服务器模型与php服务器模型的区别 2. Node.js实现静态网站功能2.1 使用http模块初步实现服务器功能12345678910111213141516171819/* 初步实现服务器功能*/const http = require('http');// 创建服务器实例对象let server = http.createServer();// 绑定请求事件server.on('request', (req, res) =&gt; &#123; res.end('hello');&#125;);// 监听端口server.listen(3000);-----------------------------http.createServer((req, res) =&gt; &#123; res.end('ok');&#125;).listen(3000, '127.0.0.1', () =&gt; &#123; console.log('running...');&#125;); 2.2 实现静态服务器功能2.2.1 处理请求路径的分发123456789101112131415161718192021222324/* 处理请求路径的分发 1、req对象是Class: http.IncomingMessage的实例对象 2、res对象是Class: http.ServerResponse的实例对象*/const http = require('http');http.createServer((req, res) =&gt; &#123; // req.url可以获取URL中的路径（端口之后部分） // res.end(req.url); if (req.url.startsWith('/index')) &#123; // write向客户端响应内容,可以写多次 res.write('hello'); res.write('hi'); res.write('nihao'); // end方法用来完成响应，只能执行一次 res.end(); &#125; else if (req.url.startsWith('/about')) &#123; res.end('about'); &#125; else &#123; res.end('no content'); &#125;&#125;).listen(3000, '192.168.0.106', () =&gt; &#123; console.log('running...');&#125;); 2.2.2 响应完整的页面信息123456789101112131415161718192021222324252627282930313233343536/* 响应完整的页面信息*/const http = require('http');const path = require('path');const fs = require('fs');// 根据路径读取文件的内容，并且响应到浏览器端let readFile = (url, res) =&gt; &#123; fs.readFile(path.join(__dirname, 'www', url), 'utf8', (err, fileContent) =&gt; &#123; if (err) &#123; res.end('server error'); &#125; else &#123; res.end(fileContent); &#125; &#125;);&#125;http.createServer((req, res) =&gt; &#123; // 处理路径的分发 if (req.url.startsWith('/index')) &#123; readFile('index.html', res); &#125; else if (req.url.startsWith('/about')) &#123; readFile('about.html', res); &#125; else if (req.url.startsWith('/list')) &#123; readFile('list.html', res); &#125; else &#123; // 设置相应类型和编码 res.writeHead(200, &#123; 'Content-Type': 'text/plain; charset=utf8' &#125;); res.end('页面被狗狗叼走了'); &#125;&#125;).listen(3000, '192.168.0.106', () =&gt; &#123; console.log('running...');&#125;); 2.2.3 单独封装方法1234567891011121314151617181920212223242526272829303132333435363738394041424344const path = require('path');const fs = require('fs');const mime = require('./mime.json');exports.staticServer = (req, res, root) =&gt; &#123; fs.readFile(path.join(root, req.url), (err, fileContent) =&gt; &#123; if (err) &#123; // 没有找到对应文件 res.writeHead(404, &#123; 'Content-Type': 'text/plain; charset=utf8' &#125;); res.end('页面被狗狗叼走了'); &#125; else &#123; let dtype = 'text/html'; // 获取请求文件的后缀 let ext = path.extname(req.url); // 如果请求的文件后缀合理，就获取到标准的响应格式 if (mime[ext]) &#123; dtype = mime[ext]; &#125; // 如果响应的内容是文本，就设置成utf8编码 if (dtype.startsWith('text')) &#123; dtype += '; charset=utf8' &#125; // 设置响应头信息 res.writeHead(200, &#123; 'Content-Type': dtype &#125;); res.end(fileContent); &#125; &#125;);&#125;--------------------------------------------------------------const http = require('http');const ss = require('./06.js');const path = require('path');http.createServer((req, res) =&gt; &#123; // ss.staticServer(req,res,path.join(__dirname,'www')); ss.staticServer(req, res, path.join('C:\\\\Users\\\\www\\\\Desktop', 'test'));&#125;).listen(3000, () =&gt; &#123; console.log('running....');&#125;); 3. 参数传递与获取3.1 url核心模块1234567891011121314151617181920212223const url = require('url');// 1. parse方法的作用就是把URL字符串转化为对象let str = 'http://www.baidu.com/abc/qqq?flag=123&amp;keyword=java';let ret = url.parse(str, true);console.log(ret.query.keyword); -&gt;java// 2. format的作用就是把对象转化为标准的URL字符串let obj = &#123; protocol: 'http:', slashes: true, auth: null, host: 'www.baidu.com', port: null, hostname: 'www.baidu.com', hash: null, search: '?flag=123&amp;keyword=java', query: 'flag=123&amp;keyword=java', pathname: '/abc/qqq', path: '/abc/qqq?flag=123&amp;keyword=java', href: 'http://www.baidu.com/abc/qqq?flag=123&amp;keyword=java'&#125;;let ret1 = url.format(obj);console.log(ret1); -&gt;http://www.baidu.com/abc/qqq?flag=123&amp;keyword=java 3.2 get参数获取12345678910const http = require('http');const path = require('path');const url = require('url');http.createServer((req, res) =&gt; &#123; let obj = url.parse(req.url, true); res.end(obj.query.username + '=========' + obj.query.password);&#125;).listen(3000, () =&gt; &#123; console.log('running....');&#125;); 3.3 post参数获取1234567891011121314151617181920212223242526272829303132333435const querystring = require('querystring');const http = require('http');// parse方法的作用就是把字符串转成对象let param = 'username=lisi&amp;password=123';// let param = 'foo=bar&amp;abc=xyz&amp;abc=123';let obj = querystring.parse(param);console.log(obj); -&gt;[Object: null prototype] &#123; username: 'lisi', password: '123' &#125;// stringify的作用就是把对象转成字符串let obj1 = &#123; flag: '123', abc: ['hello', 'hi']&#125;;let str1 = querystring.stringify(obj1);console.log(str1); -&gt;flag=123&amp;abc=hello&amp;abc=hi----------------------------------------------------- http.createServer((req, res) =&gt; &#123; if (req.url.startsWith('/login')) &#123; let pdata = ''; req.on('data', (chunk) =&gt; &#123; // 每次获取一部分数据 pdata += chunk; &#125;); req.on('end', () =&gt; &#123; // 这里才能得到完整的数据 console.log(pdata); let obj = querystring.parse(pdata); res.end(obj.username + '-----' + obj.password); &#125;); &#125;&#125;).listen(3000, () =&gt; &#123; console.log('running...');&#125;); 3.4 案例：登录验证功能1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"http://localhost:3000/login\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 密码：&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 登录验证功能*/const http = require('http');const url = require('url');const querystring = require('querystring');const ss = require('./06.js');http.createServer((req, res) =&gt; &#123; // 启动静态资源服务 if (req.url.startsWith('/www')) &#123; ss.staticServer(req, res, __dirname); &#125; console.log(req.url); // 动态资源 if (req.url.startsWith('/login')) &#123; // get请求 if (req.method == 'GET') &#123; let param = url.parse(req.url, true).query; if (param.username == 'admin' &amp;&amp; param.password == '123') &#123; res.end('get success'); &#125; else &#123; res.end('get failure'); &#125; &#125; // post请求 if (req.method == 'POST') &#123; let pdata = ''; req.on('data', (chunk) =&gt; &#123; pdata += chunk; &#125;); req.on('end', () =&gt; &#123; let obj = querystring.parse(pdata); if (obj.username == 'admin' &amp;&amp; obj.password == '123') &#123; res.end('post success'); &#125; else &#123; res.end('post failure'); &#125; &#125;); &#125; &#125;&#125;).listen(3000, () =&gt; &#123; console.log('running....');&#125;); 4. 动态网站开发创建服务器实现动态网站效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 动态网站开发 成绩查询功能*/const http = require('http');const path = require('path');const fs = require('fs');const querystring = require('querystring');const scoreData = require('./scores.json');http.createServer((req, res) =&gt; &#123; // 路由（请求路径+请求方式） // 查询成绩的入口地址 /query if (req.url.startsWith('/query') &amp;&amp; req.method == 'GET') &#123; fs.readFile(path.join(__dirname, 'view', 'index.tpl'), 'utf8', (err, content) =&gt; &#123; if (err) &#123; res.writeHead(500, &#123; 'Content-Type': 'text/plain; charset=utf8' &#125;); res.end('服务器错误，请与管理员联系'); &#125; res.end(content); &#125;); &#125; else if (req.url.startsWith('/score') &amp;&amp; req.method == 'POST') &#123; // 获取成绩的结果 /score let pdata = ''; req.on('data', (chunk) =&gt; &#123; pdata += chunk; &#125;); req.on('end', () =&gt; &#123; let obj = querystring.parse(pdata); let result = scoreData[obj.code]; fs.readFile(path.join(__dirname, 'view', 'result.tpl'), 'utf8', (err, content) =&gt; &#123; if (err) &#123; res.writeHead(500, &#123; 'Content-Type': 'text/plain; charset=utf8' &#125;); res.end('服务器错误，请与管理员联系'); &#125; // 返回内容之前要进行数据渲染 content = content.replace('$$chinese$$', result.chinese); content = content.replace('$$math$$', result.math); content = content.replace('$$english$$', result.english); content = content.replace('$$summary$$', result.summary); res.end(content); &#125;); &#125;); &#125;&#125;).listen(3000, () =&gt; &#123; console.log('running....');&#125;); 1234567891011121314151617181920&#123; \"no123\": &#123; \"chinese\": \"100\", \"math\": \"140\", \"english\": \"149\", \"summary\": \"289\" &#125;, \"no124\": &#123; \"chinese\": \"120\", \"math\": \"120\", \"english\": \"119\", \"summary\": \"239\" &#125;, \"no125\": &#123; \"chinese\": \"130\", \"math\": \"110\", \"english\": \"139\", \"summary\": \"269\" &#125;&#125; 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;查询成绩&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"http://localhost:3000/score\" method=\"post\"&gt; 请输入考号：&lt;input type=\"text\" name=\"code\"&gt; &lt;input type=\"submit\" value=\"查询\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;成绩结果&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;语文：$$chinese$$&lt;/li&gt; &lt;li&gt;数学：$$math$$&lt;/li&gt; &lt;li&gt;外语：$$english$$&lt;/li&gt; &lt;li&gt;综合：$$summary$$&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5. 模板引擎模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成一个标准的HTML结构。 模板+数据—&gt;静态页面片段 流行的模板引擎: 5.1 artTemplate5.1.1 特性 性能卓越，执行速度通常是 Mustache 与 tmpl 的 20 多倍（性能测试） 支持运行时调试，可精确定位异常模板所在语句（演示） 对 NodeJS Express 友好支持 安全，默认对输出进行转义、在沙箱中运行编译后的代码（Node版本可以安全执行用户上传的模板） 支持include语句 可在浏览器端实现按路径加载模板（详情） 支持预编译，可将模板转换成为非常精简的 js 文件 模板语句简洁，无需前缀引用数据，有简洁版本与原生语法版本可选 支持所有流行的浏览器 5.1.2 安装1234567npm install art-template&#x2F;&#x2F; 使用var template &#x3D; require(&#39;art-template&#39;);var data &#x3D; &#123;list: [&quot;aui&quot;, &quot;test&quot;]&#125;;var html &#x3D; template(__dirname + &#39;&#x2F;index&#x2F;main&#39;, data); 5.1.3 快速上手5.1.3.1 编写模板使用一个type=&quot;text/html&quot;的script标签存放模板： 12345678&lt;script id&#x3D;&quot;test&quot; type&#x3D;&quot;text&#x2F;html&quot;&gt; &lt;h1&gt;&#123; &#123;title&#125; &#125;&lt;&#x2F;h1&gt; &lt;ul&gt; &#123; &#123;each list as value i&#125; &#125; &lt;li&gt;索引 &#123; &#123;i + 1&#125; &#125; ：&#123; &#123;value&#125; &#125;&lt;&#x2F;li&gt; &#123; &#123;&#x2F;each&#125; &#125; &lt;&#x2F;ul&gt;&lt;&#x2F;script&gt; 5.1.3.2 渲染模板12345678910var data &#x3D; &#123; title: &#39;标签&#39;, list: [&#39;文艺&#39;, &#39;博客&#39;, &#39;摄影&#39;, &#39;电影&#39;, &#39;民谣&#39;, &#39;旅行&#39;, &#39;吉他&#39;]&#125;;var html &#x3D; template(&#39;test&#39;, data);document.getElementById(&#39;content&#39;).innerHTML &#x3D; html;template的作用就是把模板和数据拼接到一块生成一个静态HTML片段，实际就是该方法的返回值 参数一：模板id 参数二：用来渲染的数据 5.1.4 模板语法有两个版本的模板语法可以选择。 5.1.4.1 简洁语法推荐使用，语法简单实用，利于读写。 1234567&#123; &#123;if admin&#125; &#125; &#123; &#123;include &#39;admin_content&#39;&#125; &#125; &#123; &#123;each list&#125; &#125; &lt;div&gt;&#123; &#123;$index&#125; &#125;. &#123; &#123;$value.user&#125; &#125;&lt;&#x2F;div&gt; &#123;&#123;&#x2F;each&#125;&#125;&#123; &#123;&#x2F;if&#125; &#125; 5.1.4.2 原生语法1234567&lt; % if (admin)&#123; % &gt; &lt; %include(&#39;admin_content&#39;)% &gt; &lt; %for (var i&#x3D;0;i&lt;list.length;i++) &#123; % &gt; &lt;div&gt;&lt; % &#x3D;i % &gt;. &lt; %&#x3D;list[i].user % &gt;&lt;&#x2F;div&gt; &lt; % &#125; % &gt;&lt; % &#125; % &gt; 5.1.5 方法5.1.5.1 template(id, data)根据 id 渲染模板。内部会根据document.getElementById(id)查找模板。 如果没有 data 参数，那么将返回一渲染函数。 123&#123; &#123;if user&#125; &#125; &lt;h2&gt;&#123; &#123;user.name&#125; &#125;&lt;&#x2F;h2&gt;&#123; &#123;&#x2F;if&#125; &#125; 1234567let template = require('art-template');let html = template(__dirname + '/mytpl.art', &#123; user: &#123; name: 'lisi' &#125;&#125;);console.log(html); 5.1.5.2 template.compile(source, options)将返回一个渲染函数。 123456let tpl = '&lt;ul&gt;&#123; &#123;each list as value&#125; &#125;&lt;li&gt;&#123; &#123;value&#125; &#125;&lt;/li&gt;&#123; &#123;/each&#125; &#125;&lt;/ul&gt;';let render = template.compile(tpl);let ret = render(&#123; list: ['apple', 'orange', 'banana']&#125;);console.log(ret); 5.1.5.3 template.render(source, options)将返回渲染结果。 12345let tpl = '&lt;ul&gt;&#123; &#123;each list&#125; &#125;&lt;li&gt;&#123; &#123;$index&#125; &#125;-------------&#123; &#123;$value&#125; &#125;&lt;/li&gt;&#123; &#123;/each&#125; &#125;&lt;/ul&gt;';let ret = template.render(tpl, &#123; list: ['apple', 'orange', 'banana', 'pineapple']&#125;);console.log(ret); 5.1.5.4 template.helper(name, callback)添加辅助方法。 5.1.5.5 template.config(name, value)更改引擎的默认配置。 字段 类型 默认值 说明 openTag String &#39;{ {&#39; 逻辑语法开始标签 closeTag String &quot;} }&quot; 逻辑语法结束标签 escape Boolean true 是否编码输出 HTML 字符 cache Boolean true 是否开启缓存（依赖 options 的 filename 字段） compress Boolean false 是否压缩 HTML 多余空白字符 6. Express基于Node.js平台，快速、开放、极简的 Web 开发框架 6.1 Express之HelloWorld12345678910111213141516var express = require('express');var app = express();// 绑定路由app.get('/', function (req, res) &#123; // 响应请求 res.send('Hello World!');&#125;);var server = app.listen(3000, \"localhost\", function () &#123; // 监听的域名或者IP var host = server.address().address; // 监听的端口 var port = server.address().port; console.log(\"Example app listening at http:// % s:% s\", host, port);&#125;); 6.2 初步实现服务器功能1234567891011121314151617181920const express = require('express');const app = express();----------------------------------- // 上面两行与下面一行代码等效const app = require('express')();app.get('/', (req, res) =&gt; &#123; res.send('ok');&#125;).listen(3000, () =&gt; &#123; console.log('running...');&#125;);----------------------------------let server = app.get('/',(req,res)=&gt;&#123; res.send('abc');&#125;);server.listen(3000,()=&gt;&#123; console.log('running...');&#125;); 6.3 托管静态文件1234567891011121314151617const express = require('express');const app = express();// 实现静态资源服务// use方法的第一个参数可以指定一个虚拟路径let server = app.use('/abc', express.static('public'));app.use('/nihao', express.static('hello'));server.listen(3000, () =&gt; &#123; console.log('running...');&#125;);----------------------------------- app.use('/abc',express.static('public'));app.use('/nihao',express.static('hello'));app.listen(3000,()=&gt;&#123; console.log('running...');&#125;); 6.4 路由根据请求路径和请求方式进行路径分发处理 1234567http的常用请求方式： post 添加 get 查询 put 更新 delete 删除 restful api (一种URL的格式) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const express = require('express');const app = express();const router = require('./myrouter.js');// 直接使用use分发可以处理所有的路由请求app.use((req, res) =&gt; &#123; res.send('ok');&#125;);------------------------------// all方法绑定的路由与请求方式无关app.all('/abc', (req, res) =&gt; &#123; res.end('test router');&#125;);------------------------------// 基本的路由处理app.get('/', (req, res) =&gt; &#123; res.send('get data');&#125;);app.post('/', (req, res) =&gt; &#123; res.send('post data');&#125;);app.put('/', (req, res) =&gt; &#123; res.send('put data');&#125;);app.delete('/', (req, res) =&gt; &#123; res.send('delete data');&#125;);----------------------------// route方法可以指定特定的请求方式app.route('/hello') .get((req, res) =&gt; &#123; res.send('get data'); &#125;).post((req, res) =&gt; &#123; res.send('post data');&#125;);app.use('/admin', router);app.listen(3000, () =&gt; &#123; console.log('running...');&#125;); myrouter.js 12345678910111213141516const express = require('express');const router = express.Router();router.get('/hi', (req, res) =&gt; &#123; res.send('hi router');&#125;);router.get('/hello', (req, res) =&gt; &#123; res.send('hello router');&#125;);router.post('/abc', (req, res) =&gt; &#123; res.send('abc router');&#125;);module.exports = router; 6.5 中间件就是处理过程中的一个环节（本质上就是一个函数） 1234567891011121314151617181920212223242526272829303132const express = require('express');const app = express();let total = 0;app.use((req, res, next) =&gt; &#123; console.log('有人访问'); // next方法的作用就是把请求传递到下一个中间件 next()&#125;);app.use('/user', (req, res, next) =&gt; &#123; // 记录访问时间 console.log(Date.now()); // next方法的作用就是把请求传递到下一个中间件 next()&#125;);app.use('/user', (req, res, next) =&gt; &#123; // 记录访问日志 console.log('访问了/user'); next()&#125;);app.use('/user', (req, res) =&gt; &#123; total++; console.log(total); res.send('result');&#125;);app.listen(3000, () =&gt; &#123; console.log('running...');&#125;); 6.5.1 中间件的挂载方式和执行流程1234567891011121314151617181920212223242526272829303132333435363738const express = require('express');const app = express();app.get('/abc', (req, res, next) =&gt; &#123; console.log(1); // next(); 走2 // 跳转到下一个路由3，不走2 next('route');&#125;, (req, res) =&gt; &#123; console.log(2); res.send('abc');&#125;);app.get('/abc', (req, res) =&gt; &#123; console.log(3); res.send('hello');&#125;);--------------------------------var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/example', [cb0, cb1, cb2]);app.listen(3000, () =&gt; &#123; console.log('running...');&#125;); 6.6 参数处理12345678910111213141516171819202122232425262728293031323334353637383940const express = require('express');const app = express();const bodyParser = require('body-parser')// 挂载内置中间件app.use(express.static('public'));// 挂载参数处理中间件（post）app.use(bodyParser.urlencoded(&#123;extended: false&#125;));// 处理json格式的参数app.use(bodyParser.json());// 处理get提交参数app.get('/login', (req, res) =&gt; &#123; let data = req.query; console.log(data); res.send('get data');&#125;);// 处理post提交参数app.post('/login', (req, res) =&gt; &#123; let data = req.body; // console.log(data); if (data.username == 'admin' &amp;&amp; data.password == '123') &#123; res.send('success'); &#125; else &#123; res.send('failure'); &#125;&#125;);app.put('/login', (req, res) =&gt; &#123; res.end('put data');&#125;);app.delete('/login', (req, res) =&gt; &#123; res.end('delete data');&#125;);app.listen(3000, () =&gt; &#123; console.log('running...');&#125;); 6.7 模板引擎整合12345678910111213141516171819202122232425const express = require('express');const path = require('path');const template = require('art-template');const app = express();// 设置模板的路径app.set('views', path.join(__dirname, 'views'));// 设置模板引擎app.set('view engine', 'art');// 使express兼容art-template模板引擎app.engine('art', require('express-art-template'));app.get('/list', (req, res) =&gt; &#123; let data = &#123; title: '水果', list: ['apple', 'orange', 'banana'] &#125; // 参数一：模板名称；参数二：渲染模板的数据 res.render('list', data);&#125;);app.listen(3000, () =&gt; &#123; console.log('running...');&#125;); list.art 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;模板&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div&gt;&#123; &#123;title&#125; &#125;&lt;&#x2F;div&gt; &lt;div&gt; &lt;ul&gt; &#123; &#123;each list&#125; &#125; &lt;li&gt;&#123; &#123;$value&#125; &#125;&lt;&#x2F;li&gt; &#123; &#123;&#x2F;each&#125; &#125; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 7. Mysql API7.1 封装操作数据库的通用api123456789101112131415161718192021const mysql = require('mysql');exports.base = (sql, data, callback) =&gt; &#123; // 创建数据库连接 const connection = mysql.createConnection(&#123; host: 'localhost', // 数据库所在的服务器的域名或者IP地址 user: 'root', // 登录数据库的账号 password: 'root', // 登录数据库的密码 database: 'book' // 数据库名称 &#125;); // 执行连接操作 connection.connect(); // 操作数据库(数据库操作也是异步的) connection.query(sql, data, function (error, results, fields) &#123; if (error) throw error; callback(results); &#125;); // 关闭数据库 connection.end();&#125;; 7.2 测试通用api12345678910111213141516171819202122232425262728293031323334353637const db = require('./db.js');// 插入操作let sql = 'insert into book set ?';let data = &#123; name: '笑傲江湖', author: '金庸', category: '文学', description: '武侠小说'&#125;db.base(sql, data, (result) =&gt; &#123; console.log(result);&#125;);--------------------------------------- // 更新操作let sql = 'update book set name=?,author=?,category=?,description=? where id=?';let data = ['天龙八部', '金庸', '文学', '武侠小说', 11];db.base(sql, data, (result) =&gt; &#123; console.log(result);&#125;);--------------------------------------- // 删除操作let sql = 'delete from book where id = ?';let data = [11];db.base(sql, data, (result) =&gt; &#123; console.log(result);&#125;);--------------------------------------- // 查询操作let sql = 'select * from book where id = ?';let data = [8];db.base(sql, data, (result) =&gt; &#123; console.log(result[0].name);&#125;); 8. 后台接口开发8.1 json接口1234567// 指定api路径 allBooks (json接口)app.get('/allBooks', (req, res) =&gt; &#123; let sql = 'select * from book'; db.base(sql, null, (result) =&gt; &#123; res.json(result); &#125;);&#125;); 8.2 jsonp接口123456789// 修改jsonp回调函数传递参数的keyapp.set('jsonp callback name', 'cb');// 指定api路径 allBooks （jsonp接口）app.get('/allBooks', (req, res) =&gt; &#123; let sql = 'select * from book'; db.base(sql, null, (result) =&gt; &#123; res.jsonp(result); &#125;);&#125;); 8.3 restful接口1234567891011121314151617181920212223242526272829303132333435363738394041/* restful api 是从URL的格式来表述的 get http://localhost:3000/books get http://localhost:3000/books/book post http://localhost:3000/books/book get http://localhost:3000/books/book/1 put http://localhost:3000/books/book delete http://localhost:3000/books/book/2 传统的URL风格 http://localhost:3000/ http://localhost:3000/toAddBook http://localhost:3000/addBook http://localhost:3000/toEditBook?id=1 http://localhost:3000/editBook http://localhost:3000/deleteBook?id=2*/const express = require('express');const db = require('./db.js');const app = express();app.get('/books', (req, res) =&gt; &#123; let sql = 'select * from book'; db.base(sql, null, (result) =&gt; &#123; res.json(result); &#125;);&#125;);// http://localhost:3000/books/book/1app.get('/books/book/:id', (req, res) =&gt; &#123; let id = req.params.id; let sql = 'select * from book where id=?'; let data = [id]; db.base(sql, data, (result) =&gt; &#123; res.json(result[0]); &#125;);&#125;);app.listen(3000, () =&gt; &#123; console.log('running...');&#125;); 9. 从服务器主动发送请求12345678910111213141516171819202122232425262728/* 从服务器主动发送请求 http.request(options[, callback])*/const http = require('http');const path = require('path');const fs = require('fs');let options = &#123; hostname: 'www.baidu.com', port: 80&#125;let req = http.request(options, (res) =&gt; &#123; let info = ''; res.on('data', (chunk) =&gt; &#123; info += chunk; &#125;); res.on('end', () =&gt; &#123; fs.writeFile(path.join(__dirname, 'baidu.html'), info, (err) =&gt; &#123; console.log('已经获取到百度主页的内容'); &#125;); &#125;);&#125;);req.end(); 9.1 查询数据123456789101112131415161718192021const http = require('http');let options = &#123; protocol: 'http:', hostname: 'localhost', port: 3000, path: '/books'&#125;let req = http.request(options, (res) =&gt; &#123; let info = ''; res.on('data', (chunk) =&gt; &#123; info += chunk; &#125;); res.on('end', () =&gt; &#123; console.log(info); &#125;);&#125;);req.end(); 9.2 添加数据123456789101112131415161718192021222324252627282930313233const http = require('http');const querystring = require('querystring');let options = &#123; protocol: 'http:', hostname: 'localhost', port: 3000, path: '/books/book', method: 'post', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', &#125;&#125;let req = http.request(options, (res) =&gt; &#123; let info = ''; res.on('data', (chunk) =&gt; &#123; info += chunk; &#125;); res.on('end', () =&gt; &#123; console.log(info); &#125;);&#125;);let data = querystring.stringify(&#123; name: 'adafa', author: 'asdfa', category: 'afdasf', description: 'adsfa'&#125;);req.write(data);req.end(); 9.3 根据id去查询数据1234567891011121314151617181920212223const http = require('http');const querystring = require('querystring');let options = &#123; protocol: 'http:', hostname: 'localhost', port: 3000, path: '/books/book/2', method: 'get'&#125;let req = http.request(options, (res) =&gt; &#123; let info = ''; res.on('data', (chunk) =&gt; &#123; info += chunk; &#125;); res.on('end', () =&gt; &#123; console.log(info); &#125;);&#125;);req.end(); 9.4 编辑数据12345678910111213141516171819202122232425262728293031323334const http = require('http');const querystring = require('querystring');let options = &#123; protocol: 'http:', hostname: 'localhost', port: 3000, path: '/books/book', method: 'put', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', &#125;&#125;let req = http.request(options, (res) =&gt; &#123; let info = ''; res.on('data', (chunk) =&gt; &#123; info += chunk; &#125;); res.on('end', () =&gt; &#123; console.log(info); &#125;);&#125;);let data = querystring.stringify(&#123; id: 34, name: 'ddddddddd', author: 'sssssssss', category: 'eeeeeeeee', description: 'gggggggg'&#125;);req.write(data);req.end(); 9.5 删除数据1234567891011121314151617181920212223const http = require('http');const querystring = require('querystring');let options = &#123; protocol: 'http:', hostname: 'localhost', port: 3000, path: '/books/book/34', method: 'delete'&#125;let req = http.request(options, (res) =&gt; &#123; let info = ''; res.on('data', (chunk) =&gt; &#123; info += chunk; &#125;); res.on('end', () =&gt; &#123; console.log(info); &#125;);&#125;);req.end(); 10. 调用第三方接口123456789101112131415161718192021222324const http = require('http');const querystring = require('querystring');let cityCode = '101010300';let options = &#123; protocol: 'http:', hostname: 'www.weather.com.cn', port: 80, path: '/data/sk/' + cityCode + '.html', method: 'get'&#125;let req = http.request(options, (res) =&gt; &#123; let info = ''; res.on('data', (chunk) =&gt; &#123; info += chunk; &#125;); res.on('end', () =&gt; &#123; console.log(info); &#125;);&#125;);req.end();","tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://wgy1993.gitee.io/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"Node.js","slug":"Node-js","permalink":"https://wgy1993.gitee.io/tags/Node-js/"},{"name":"artTemplate","slug":"artTemplate","permalink":"https://wgy1993.gitee.io/tags/artTemplate/"},{"name":"Express","slug":"Express","permalink":"https://wgy1993.gitee.io/tags/Express/"}]},{"title":"less","date":"2020-04-19T13:43:34.000Z","path":"archives/d3b694df.html","text":"1. CSS预处理器CSS 预处理器是一种语言，用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，并且你可以在CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让你的 CSS 更简洁，适应性更强，代码更直观等诸多好处。 常见的CSS预处理器有：LESS、SASS、Stylus等 2. LESSLESS 是动态的样式表语言，通过简洁明了的语法定义，使编写 CSS 的工作变得非常简单，本质上，LESS 包含一套自定义的语法及一个解析器。 2.1 安装1、安装Nodejs环境 Node Package Manager (验证 node -v npm -v) 2、打开控制台（cmd），执行npm install -g less (验证 lessc -v) 3、命令行编译 lessc path/xxx.less path/xxx.css 2.2 编译浏览器只能识别CSS，LESS只是用来提升CSS可维护性的一个工具，所最终需要将LESS编译成CSS，然而通过命令行编译效率比较低下，一般都会借助于编辑器来完成编译，以sublime_text为例，sublime_text默认并不支持LESS的编译操作，需要安装插件实现。 1、执行npm install -g less-plugin-clean-css（使用sublime_text才用） 2、ctrl+shit+p打开命令面板 3、输入install package然后回车 4、安装 LESS、lessc、Less2Css三个插件 5、alt+s快捷键即可实现编译 2.3 语法2.3.1 变量格式：@变量名: 值，定义完成后可以重复使用 2.3.2 混合我们可以像使用函数一样来使用CSS 2.3.3 嵌套嵌套可以非常方便的管理我们的CSS层级关系","tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://wgy1993.gitee.io/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"less","slug":"less","permalink":"https://wgy1993.gitee.io/tags/less/"},{"name":"预处理器","slug":"预处理器","permalink":"https://wgy1993.gitee.io/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"}]},{"title":"ECMAScript6","date":"2020-04-19T10:22:50.000Z","path":"archives/fa865a02.html","text":"1. ECMAScript 6ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。 Ecmascript 是 JavaScript 语言的标注规范。 JavaScript 是 Ecmascript 规范的具体实现，具体实现取决于各大浏览器厂商的支持进度。 Ecmascript 6 也被称作 Ecmascript 2015。 各大浏览器厂商对于最新的 Ecmascript 6 标准支持可以参照：http://kangax.github.io/compat-table/es6/。 对于不支持 ES6 的环境，可以使用一些编译转码工具做转换处理再使用，例如 babel。 1.1 变量声明let与constlet： let 类似于 var，用来声明变量 通过 let 声明的变量不同于 var，只在 let 命令所在的代码块内有效（块级作用域） let 声明的变量不存在变量提升 let不允许在相同作用域内，重复声明同一个变量 12345678910111213141516171819202122232425262728293031323334353637// 1. let声明的变量不存在预解析console.log(flag);// var flag = 123; -&gt;打印123let flag = 456; // 打印undefined------------------------// 2. let声明的变量不允许重复（在同一个作用域内）let flag = 123;// let flag = 456;-&gt;已声明，不允许重复--------------------------// 3. ES6引入了块级作用域// 块内部定义的变量，在外部是不可以访问的if (true) &#123; // var flag = 123;-&gt;打印123 let flag = 123;&#125;&#123; // 这里是块级作用域 let flag = 111; console.log(flag);// 打印111&#125;console.log(flag);// 打印undefinedfor (let i = 0; i &lt; 3; i++) &#123; // for循环括号中声明的变量只能在循环体中使用 console.log(i);&#125;console.log(i);// 打印undefined--------------------------------------- // 4. 在块级作用域内部，变量只能先声明再使用if (true) &#123; console.log(flag);// 打印undefined let flag = 123;&#125; const： const声明一个只读的常量。一旦声明，常量的值就不能改变 const 声明必须初始化 const的作用域与let命令相同：只在声明所在的块级作用域内有效 const命令声明的常量也是不提升，必须先声明后使用 const声明的常量，也与let一样不可重复声明 12345678// const用来声明常量// 1. const声明的常量不允许重新赋值const n = 1;// n = 2;--------------------------------// 2. const声明的常量必须初始化// const abc; 1.2 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 1.2.1 数组解构1234let [a, b, c] = [1, 2, 3]; -&gt;1 2 3let [a, b, c] = [, 123,]; -&gt;undefined 123 undefinedlet [a = 111, b, c] = [, 123,]; -&gt;111 123 undefinedconsole.log(a, b, c); 1.2.2 对象解构123456789101112131415// 1. 赋值与顺序无关let &#123;foo, bar&#125; = &#123;foo: 'hello', bar: 'hi'&#125;; -&gt;hello hilet &#123;foo, bar&#125; = &#123;bar: 'hi', foo: 'hello'&#125;; -&gt;hello hiconsole.log(foo, bar);-------------------------------------// 2. 对象属性别名(如果有了别名，那么原来的名字就无效了)let &#123;foo: abc, bar&#125; = &#123;bar: 'hi', foo: 'nihao'&#125;; -&gt;nihao hi// console.log(foo, bar); -&gt;foo未定义console.log(abc, bar);--------------------------------------// 3. 对象的解构赋值指定默认值let &#123;foo: abc = 'hello', bar&#125; = &#123;bar: 'hi'&#125;; -&gt;hello hiconsole.log(abc, bar); 1.2.3 函数参数解构12345function f (p1, &#123; p2 = 'aa', p3 = 'bb' &#125;) &#123; console.log(p1, p2, p3)&#125;f('p1', &#123; p2: 'p2' &#125;) -&gt;p1 p2 bb 1.2.4 字符串解构12345678let [a, b, c, d, e, length] = \"hello\";console.log(a, b, c, d, e); -&gt;h e l l oconsole.log(length); -&gt;undefinedconsole.log(\"hello\".length); -&gt;5let &#123;length&#125; = \"hi\";console.log(length); -&gt;2 1.3 字符串实用方法： 123456789includes(String)：返回布尔值，判断字符串中是否包含指定的字串。参数一：匹配的字串；参数二：从第几个开始匹配startsWith(String)：返回布尔值，判断字符串是否以特定的字串开始。endsWith(String)：返回布尔值，判断字符串是否以特定的字串结束。console.log('hello world'.includes('world',7)); -&gt;falselet url = 'admin/index.php';console.log(url.startsWith('admin')); -&gt;trueconsole.log(url.endsWith('phph')); -&gt;false 模板字符串： 12345678910111213141516171819202122232425// 普通拼接let obj = &#123; username: 'lisi', age: '12', gender: 'male'&#125;let tag = '&lt;div&gt;&lt;span&gt;' + obj.username + '&lt;/span&gt;&lt;span&gt;' + obj.age + '&lt;/span&gt;&lt;span&gt;' + obj.gender + '&lt;/span&gt;&lt;/div&gt;';console.log(tag);------------------------------------------------------------- // 反引号表示模板，模板中的内容可以有格式，通过$&#123;&#125;方式填充数据let fn = function (info) &#123; return info;&#125;let tpl = ` &lt;div&gt; &lt;span&gt;$&#123;obj.username&#125;&lt;/span&gt; &lt;span&gt;$&#123;obj.age&#125;&lt;/span&gt; &lt;span&gt;$&#123;obj.gender&#125;&lt;/span&gt; &lt;span&gt;$&#123;1 + 1&#125;&lt;/span&gt; &lt;span&gt;$&#123;fn('nihao')&#125;&lt;/span&gt; &lt;/div&gt;`;console.log(tpl); 模板字符串（template string）是增强版的字符串，用反引号（`）标识 它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中 模板字符串中嵌入变量，需要将变量名写在 ${} 之中 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性 大括号内部还可以调用函数 1.4 数组方法： 123456789Array.from() 将一个伪数组转为一个真正的数组 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合， 以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。Array.of() Array.of方法用于将一组值，转换为数组 这个方法的主要目的，是弥补数组构造函数Array()的不足。 因为参数个数的不同，会导致Array()的行为有差异。find() 查找数组中某个元素findIndex() 查找数组中某个元素的索引下标includes() 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似 实例方法： ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组.可以用 for...of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。 1234567891011121314151617181920212223242526272829303132333435const arr = [ &#123;foo: 'a', name: 'aaa'&#125;, &#123;foo: 'b', name: 'bbb'&#125;, &#123;foo: 'c', name: 'ccc'&#125;,];var item = arr.find(function (item, index) &#123; return item.foo === 'b'&#125;);var item = arr.find(i =&gt; i.foo === 'b');var index = arr.findIndex(function (item, index) &#123; return item.foo === 'b'&#125;);------------------------------------------------------------------let arr = ['a', 'b', 'c'];for (let index of arr.keys()) &#123; console.log(index)&#125;// 不支持for (let item of arr.values()) &#123; console.log(item)&#125;// 遍历数组for (let [index, item] of arr.entries()) &#123; console.log(index, item)&#125;// 是否包含某个元素console.log(arr.includes('d')); 1.5 函数的扩展1.5.1 参数默认值1234567891011121314151617181920function foo(param) &#123; let p = param || 'hello'; console.log(p); -&gt;hello&#125;foo('hi'); -&gt;hifunction foo(param = 'nihao') &#123; console.log(param); -&gt;nihao&#125;foo('hello kitty'); -&gt;hello kitty------------------------------------------function foo(uname = 'lisi', age = 12) &#123; console.log(uname, age); -&gt;lisi 12&#125;foo('zhangsan', 13); -&gt;zhangsan 13foo(); -&gt;lisi 12 1.5.2 参数解构赋值123456function foo(&#123;uname &#x3D; &#39;lisi&#39;, age &#x3D; 13&#125; &#x3D; &#123;&#125;) &#123; console.log(uname, age);&#125;foo(); -&gt;lisi 13foo(&#123;uname: &#39;zhangsan&#39;, age: 15&#125;); -&gt;zhangsan 15 1.5.3 rest 参数（剩余参数）1234567function foo(a, b, ...param) &#123; console.log(a); console.log(b); console.log(param);&#125;foo(1, 2, 3, 4, 5); -&gt;1 2 [3,4,5] 1.5.4 扩展运算符…12345678910111213function foo(a, b, c, d, e, f, g) &#123; console.log(a + b + c + d + e + f + g);&#125;let arr = [1, 2, 3, 4, 5, 6, 7];foo(...arr);----------------------------------------------- // 合并数组let arr1 = [1, 2, 3];let arr2 = [4, 5, 6];let arr3 = [...arr1, ...arr2];console.log(arr3); -&gt;[1,2,3,4,5,6] 1.5.5 箭头函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var f = v =&gt; v上面的箭头函数等同于：var f = function(v) &#123; return v&#125;-------------------------------------------// 多个参数必须用小括号包住let foo = (a, b) =&gt; &#123; let c = 1; console.log(a + b + c);&#125;;foo(1, 2);let arr = [123, 456, 789];arr.forEach(function (element, index) &#123; console.log(element, index);&#125;);arr.forEach((element, index) =&gt; &#123; console.log(element, index);&#125;);--------------------------------------------------// 箭头函数的注意事项：// 1、箭头函数中this取决于函数的定义，而不是调用function foo() &#123; // 使用call调用foo时，这里的this其实就是call的第一个参数 // console.log(this); setTimeout(() =&gt; &#123; console.log(this.num); &#125;, 100);&#125;foo.call(&#123;num: 1&#125;);--------------------------------------------------// 2、箭头函数不可以newlet foo = () =&gt; &#123; this.num = 123;&#125;;// new foo();--------------------------------------------------// 3、箭头函数不可以使用arguments获取参数列表，可以使用rest参数代替let foo = (a, b) =&gt; &#123; // console.log(a,b); console.log(arguments);//这种方式获取不到实参列表&#125;foo(123, 456);let foo = (...param) =&gt; &#123; console.log(param);&#125;foo(123, 456); 1.6 类与继承123456789101112131415161718192021222324252627282930313233343536373839class Animal &#123; // 静态方法(静态方法只能通过类名调用，不可以使用实例对象调用) static showInfo() &#123; console.log('hi'); &#125; // 构造函数 constructor(name) &#123; this.name = name; &#125; showName() &#123; console.log(this.name); &#125;&#125;let a = new Animal('spike');a.showName();// a.showInfo();Animal.showInfo();------------------------------------------------------------// 类的继承extendsclass Dog extends Animal &#123; constructor(name, color) &#123; super(name);//super用来调用父类 this.color = color; &#125; showColor() &#123; console.log(this.color); &#125;&#125;let d = new Dog('doudou', 'yellow');d.showName();d.showColor();// d.showInfo();Dog.showInfo(); 1.7 对象属性的简洁表示法： 123456789101112131415161718192021var foo = 'bar';var baz = &#123;foo&#125;;baz &#123;foo: \"bar\"&#125;等同于var baz = &#123;foo: foo&#125;----------------------------------------------------------- 除了属性简写，方法也可以简写:var o = &#123; method() &#123; return \"Hello!\" &#125;&#125;等同于var o = &#123; method: function() &#123; return \"Hello!\" &#125;&#125; 2. Babel第一：在项目根目录下创建一个 .babelrc 文件，写入以下内容： 1234&#123; \"presets\": [ ]&#125; 第二：安装对应的转码规则： 1234567891011# ES2015转码规则npm install --save-dev babel-preset-es2015# react转码规则npm install --save-dev babel-preset-react# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个npm install --save-dev babel-preset-stage-0npm install --save-dev babel-preset-stage-1npm install --save-dev babel-preset-stage-2npm install --save-dev babel-preset-stage-3 第三：将 .babelrc 文件中修改为以下内容： 12345&#123; \"presets\": [ \"es2015\" ]&#125; 第四步（从第四步开始，前三部必不可少）： babel-cli：命令行转码 babel-node：babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境 babel-register：实时转码，所以只适合在开发环境使用 babel-core：如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块 babel-cli： 一种使用方式就是全局安装：npm install -g babel-cli（可以通过 npm root -g 查看全局包安装目录），只要全局安装了 babel-cli，则会在命令行中多出一个命令：babel。 这里如果使用全局安装的 babel-cli 进行转码是没有问题的，但是问题是如果一旦项目给了别人，别人不知道你使用了这个转码工具，所以解决方式就是将 babel-cli 安装到本地项目中： 1npm install --save-dev babel-cli 这种第三方命令行工具如果安装到本地项目，会在 node_modules 中生成一个目录：.bin，然后第三方命令行工具会将对应的可执行文件放到该目录中。这样的话，就可以直接在本地项目中使用该第三方命令行工具了。 对于如何使用，则可以通过配置 package.json 文件中的 scripts 字段来配置使用： 123456789101112&#123; \"name\": \"babel-demo\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"babel demo1.js\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.22.2\", \"babel-preset-es2015\": \"^6.22.0\", \"babel-preset-react\": \"^6.22.0\" &#125;&#125; babel-register（适合开发阶段，实时编码转换）: 第一：安装 babel-register 1npm install --save-dev babel-register 第二：添加一个傀儡文件(main.js)： 12require('babel-register')require('你的核心功能代码入口文件模块') 第三：使用 node 执行 main.js，而不是你的入口文件。","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://wgy1993.gitee.io/tags/ECMAScript6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://wgy1993.gitee.io/tags/JavaScript/"},{"name":"前端技术","slug":"前端技术","permalink":"https://wgy1993.gitee.io/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"Node.js(一)","date":"2020-04-19T07:08:49.000Z","path":"archives/fb0fa11b.html","text":"1. 初识Node.jsNode.js 是一种建立在Google Chrome’s v8 engine上的 non-blocking (非阻塞）, event-driven （基于事件的）I/O平台。 Node.js平台使用的开发语言是JavaScript，平台提供了操作系统低层的API，方便做服务器端编程，具体包括文件操作、进程操作、通信操作等系统模块 2. Node.js可以用来做什么？ 具有复杂逻辑的动态网站 WebSocket服务器 命令行工具 带有图形界面的本地应用程序 …… 3. Node.js开发环境准备1、普通安装方式官方网站 2、多版本安装方式 12345678910112.1 卸载已有的Node.js2.2 下载[nvm](https:&#x2F;&#x2F;github.com&#x2F;coreybutler&#x2F;nvm-windows)2.3 在C盘创建目录dev2.4 在dev目中中创建两个子目录nvm和nodejs2.5 并且把nvm包解压进去nvm目录中2.6 在install.cmd文件上面右键选择【以管理员身份运行】2.7 打开的cmd窗口直接回车会生成一个settings.txt文件，修改文件中配置信息2.8 配置nvm和Node.js环境变量 2.8.1 NVM_HOME:C:\\dev\\nvm 2.8.2 NVM_SYMLINK:C:\\dev\\nodejs2.9 把配置好的两个环境变量加到Path中%NVM_HOME%;%NVM_SYMLINK%; 4. nvm常用的命令 nvm list 查看当前安装的Node.js所有版本 nvm install 版本号 安装指定版本的Node.js nvm uninstall 版本号 卸载指定版本的Node.js nvm use 版本号 选择指定版本的Node.js 5. Node.js之HelloWorld5.1 命令行方式REPLREPL read-eval-print-loop 读取代码-执行-打印结果-循环这个过程 在REPL环境中，_表示最后一次执行结果; .exit 可以退出REPL环境 5.2 运行文件方式123456789101112131415/* 初识Node.js*/console.log('hello tom and jerry');function sum(n) &#123; var result = 0; for (var i = 0; i &lt;= n; i++) &#123; result += i; &#125; return result;&#125;var ret = sum(100);console.log(ret); 6. 全局对象概览1234567891011121314151617181920212223242526/* 全局成员概述*/// 1. 包含文件名称的全路径console.log(__filename);// 2. 文件的路径（不包含文件名称）console.log(__dirname);// 3. 定时函数，用法与浏览器中的定时函数类似var timer = setTimeout(function () &#123; console.log(123);&#125;, 1000);setTimeout(function () &#123; clearTimeout(timer);&#125;, 2000);// 4. 在Node.js中没有window对象，但是有一个类似的对象global，访问全局成员的时候可以省略globalglobal.console.log(123456);// 5. argv是一个数组，默认情况下，前两项数据分别是：Node.js环境的路径、当前执行的js文件的全路径// 从第三个参数开始表示命令行参数console.log(process.argv);// 6. 打印当前系统的架构（64位或者32位）console.log(process.arch); 7. 模块化开发7.1 模块化规范与实现12345678910111213141516传统非模块化开发有如下的缺点：1、命名冲突2、文件依赖前端标准的模块化规范：1、AMD - requirejs2、CMD - seajs服务器端的模块化规范：1、CommonJS - Node.js模块化相关的规则：1、如何定义模块：一个js文件就是一个模块，模块内部的成员都是相互独立2、模块成员的导出和引入模块成员的导出最终以module.exports为准 7.2 模块导出与引入7.2.1 导出方式一：03.js 123456var sum = function(a,b)&#123; return parseInt(a) + parseInt(b);&#125;// 导出模块成员exports.sum = sum; 04.js 12345//引入模块var module = require('./03.js');var ret = module.sum(12,13);console.log(ret); 7.2.2 导出方式二：03.js 123456var sum = function(a,b)&#123; return parseInt(a) + parseInt(b);&#125;// 导出模块成员module.exports = sum; 04.js 12345//引入模块var module = require('./03.js');var ret = module(12,13);console.log(ret); 7.2.3 两种导出方式区别如果要导出单个的成员或者比较少的成员，一般我们使用exports导出；如果要导出的成员比较多，一般我们使用module.exports的方式。 这两种方式不能同时使用，exports与module的关系：module.exports = exports = {}; 7.3 模块导出机制分析05.js 1234567891011121314151617181920212223242526/* 四则运算-成员导出方式分析*/var sum = function (a, b) &#123; return parseInt(a) + parseInt(b);&#125;var subtract = function (a, b) &#123; return parseInt(a) - parseInt(b);&#125;var multiply = function (a, b) &#123; return parseInt(a) * parseInt(b);&#125;var divide = function (a, b) &#123; return parseInt(a) / parseInt(b);&#125;// 导出成员// exports.sum = sum;// exports.subtract = subtract;module.exports = &#123; sum: sum, subtract: subtract, multiply: multiply, divide: divide&#125; 06.js 12345678/* 测试导出*/var m = require('./05.js');var ret = m.sum(1, 2);var ret1 = m.subtract(1, 2);console.log(ret, ret1); 7.4 模块成员导出：global07.js 12var flag = 123;global.flag = flag; 08.js 12require('./07.js');console.log(global.flag); 7.5 模块加载规则已经加载的模块会缓存 模块文件的后缀3种情况：.js .json .node 上述三种模块的加载优先级(不加文件后缀时的优先级)：.js -&gt; .json -&gt; .node data.json 1234&#123; \"username\":\"张三\", \"age\":\"12\"&#125; data.js 123exports.showInfo = function()&#123; console.log('nihao');&#125; 08.js 12var m = require('./data');var ret = m.showInfo(); 7.6 模块分类 自定义模块 系统核心模块 fs 文件操作 http 网络操作 path 路径操作 querystring 查询参数解析 url url解析 …… 8. Buffer基本操作 Buffer对象是Node处理二进制数据的一个接口。它是Node原生提供的全局对象，可以直接使用，不需要require(‘buffer’)。Buffer本质上就是字节数组。 8.1 实例化 Buffer.from(array) Buffer.from(string) Buffer.alloc(size) 123456789let buf = new Buffer(5);//不推荐let buf = Buffer.alloc(5);console.log(buf); -&gt;&lt;Buffer 00 00 00 00 00&gt;let buf = Buffer.from('hello', 'utf8');console.log(buf); -&gt;&lt;Buffer 68 65 6c 6c 6f&gt;let buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);console.log(buf.toString()); -&gt;buffer 8.2 功能方法 Buffer.isEncoding() 判断是否支持该编码 Buffer.isBuffer() 判断是否为Buffer Buffer.byteLength() 返回指定编码的字节长度，默认utf8 Buffer.concat() 将一组Buffer对象合并为一个Buffer对象 123456789101112131415161718192021console.log(Buffer.isEncoding('utf8')); -&gt;trueconsole.log(Buffer.isEncoding('gbk')); -&gt;falselet buf = Buffer.from('hello');console.log(Buffer.isBuffer(buf)); -&gt;trueconsole.log(Buffer.isBuffer(&#123;&#125;)); -&gt;falselet buf = Buffer.from('中国', 'ascii');console.log(Buffer.byteLength(buf)); -&gt;2console.log(buf.toString());let buf1 = Buffer.alloc(3);let buf2 = Buffer.alloc(5);let buf3 = Buffer.concat([buf1, buf2]);console.log(Buffer.byteLength(buf3)); -&gt;8let buf1 = Buffer.from('tom');let buf2 = Buffer.from('jerry');let buf3 = Buffer.concat([buf1, buf2]);console.log(Buffer.byteLength(buf3)); -&gt;8console.log(buf3.toString()); -&gt;tomjerry 8.3 实例方法 write() 向buffer对象中写入内容 slice() 截取新的buffer对象 toString() 把buf对象转成字符串 toJson() 把buf对象转成json形式的字符串 1234567891011121314let buf = Buffer.alloc(5);buf.write('hello', 2, 2);console.log(buf); -&gt;&lt;Buffer 00 00 68 65 00&gt; 空格空格he空格let buf = Buffer.from('hello');let buf1 = buf.slice(2, 3);console.log(buf === buf1);//falseconsole.log(buf1.toString()); -&gt;l// toJSON方法不需要显式调用，当JSON.stringify方法调用的时候会自动调用toJSON方法const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]); -&gt;&#123;\"type\":\"Buffer\",\"data\":[1,2,3,4,5]&#125;const buf = Buffer.from('hello'); -&gt;&#123;\"type\":\"Buffer\",\"data\":[104,101,108,108,111]&#125;const json = JSON.stringify(buf);console.log(json); 9. 核心模块API9.1 路径操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//引入path模块const path = require('path');// 1. 获取路径的最后一部分console.log(path.basename('/foo/bar/baz/asdf/quux.html')); -&gt;quux.htmlconsole.log(path.basename('/foo/bar/baz/asdf/quux.html', '.html')); -&gt;quux// 2. 获取路径console.log(__dirname);-&gt;D:\\02-codeconsole.log(path.dirname('/abc/qqq/www/abc')); -&gt;/abc/qqq/www// 3. 获取扩展名称console.log(path.extname('index.html')); -&gt;.html// 4. 路径的格式化处理// path.format() obj-&gt;string// path.parse() string-&gt;objlet obj = path.parse(__filename);console.log(obj.base);/*&#123; root: 'D:\\\\', 文件的跟路径 dir: 'D:\\\\02-code',文件的全路径 base: '02.js',文件的名称 ext: '.js',扩展名 name: '02' 文件名称&#125;*/let objpath = &#123; root: 'd:\\\\', dir: 'd:\\\\qqq\\\\www', base: 'abc.txt', ext: '.txt', name: 'abc'&#125;;let strpath = path.format(objpath);console.log(strpath); -&gt;d:\\qqq\\www\\abc.txt// 5. 判断是否为绝对路径console.log(path.isAbsolute('/foo/bar')); -&gt;trueconsole.log(path.isAbsolute('C:/foo/..')); -&gt;true// 6. 拼接路径（..表示上层路径；.表示当前路径）,在连接路径的时候会格式化路径console.log(path.join('/foo', 'bar', 'baz/asdf', 'quux', '../../')); -&gt;\\foo\\bar\\baz\\// 7. 规范化路径console.log(path.normalize('/foo/bar//baz/asdf/quux/..')); -&gt;\\foo\\bar\\baz\\asdfconsole.log(path.normalize('C:\\\\temp\\\\\\\\foo\\\\bar\\\\..\\\\')); -&gt;C:\\temp\\foo\\// 8. 计算相对路径console.log(path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')); -&gt;..\\..\\impl\\bbbconsole.log(path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')); -&gt;..\\..\\impl\\bbb// 9. 解析路径console.log(path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')); -&gt;D:\\02-code\\wwwroot\\static_files\\gif\\image.gif// 10. 两个特殊属性console.log(path.delimiter);//环境变量分隔符(windows中使用; linux中使用:) -&gt;;console.log(path.sep);//表示路径分隔符（windows是\\ Linux是/）-&gt;\\ 9.2 文件操作9.2.1 文件信息获取123456789101112131415161718192021222324252627const fs = require('fs');console.log(1);fs.stat('./data.txt', (err, stat) =&gt; &#123; // 一般回调函数的第一个参数是错误对象，如果err为null,表示没有错误，否则表示报错了 if (err) return; if (stat.isFile()) &#123; console.log('文件'); &#125; else if (stat.isDirectory()) &#123; console.log('目录'); &#125; console.log(stat); /* atime 文件访问时间 ctime 文件的状态信息发生变化的时间（比如文件的权限） mtime 文件数据发生变化的时间 birthtime 文件创建的时间 */ console.log(2);&#125;);console.log(3);----------------------------------------------------// 同步操作console.log(1);let ret = fs.statSync('./data.txt');console.log(ret);console.log(2); 9.2.2 读文件操作1234567891011121314151617181920const fs = require('fs');const path = require('path');let strpath = path.join(__dirname, 'data.txt');fs.readFile(strpath, (err, data) =&gt; &#123; if (err) return; console.log(data.toString());&#125;);// 如果有第二个参数并且是编码，那么回调函数获取到的数据就是字符串// 如果没有第二个参数，那么得到的就是Buffer实例对象fs.readFile(strpath, 'utf8', (err, data) =&gt; &#123; if (err) return; // console.log(data.toString()); console.log(data);&#125;);// 同步操作let ret = fs.readFileSync(strpath, 'utf8');console.log(ret); 9.2.3 写文件操作123456789101112131415161718192021222324252627282930313233343536373839404142434445const fs = require('fs');const path = require('path');let strpath = path.join(__dirname,'data.txt');fs.writeFile(strpath,'hello nihao','utf8',(err)=&gt;&#123; if(!err)&#123; console.log('文件写入成功'); &#125;&#125;);let buf = Buffer.from('hi');fs.writeFile(strpath, buf, 'utf8', (err) =&gt; &#123; if (!err) &#123; console.log('文件写入成功'); &#125;&#125;);// 同步操作fs.writeFileSync(strpath,'tom and jerry');----------------------------------------------------------// 大文件操作（流式操作）const path = require('path');const fs = require('fs');let spath = path.join(__dirname,'../03-source','file.zip');let dpath = path.join('C:\\\\Users\\\\www\\\\Desktop','file.zip');let readStream = fs.createReadStream(spath);let writeStream = fs.createWriteStream(dpath);// 基于事件的处理方式let num = 1;readStream.on('data',(chunk)=&gt;&#123; num++; writeStream.write(chunk);&#125;);readStream.on('end',()=&gt;&#123; console.log('文件处理完成'+num);&#125;);// pipe的作用直接把输入流和输出流// readStream.pipe(writeStream);fs.createReadStream(spath).pipe(fs.createWriteStream(dpath)); 9.2.4 目录操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* 目录操作 1、创建目录 fs.mkdir(path[, mode], callback) fs.mkdirSync(path[, mode]) 2、读取目录 fs.readdir(path[, options], callback) fs.readdirSync(path[, options]) 3、删除目录 fs.rmdir(path, callback) fs.rmdirSync(path)*/const path = require('path');const fs = require('fs');// 1. 创建目录fs.mkdir(path.join(__dirname,'abc'),(err)=&gt;&#123; console.log(err);&#125;);fs.mkdirSync(path.join(__dirname,'hello'));--------------------------------// 2. 读取目录fs.readdir(__dirname,(err,files)=&gt;&#123; files.forEach((item,index)=&gt;&#123; fs.stat(path.join(__dirname,item),(err,stat)=&gt;&#123; if(stat.isFile())&#123; console.log(item,'文件'); &#125;else if(stat.isDirectory())&#123; console.log(item,'目录'); &#125; &#125;); &#125;);&#125;);let files = fs.readdirSync(__dirname);files.forEach((item,index)=&gt;&#123; fs.stat(path.join(__dirname,item),(err,stat)=&gt;&#123; if(stat.isFile())&#123; console.log(item,'文件'); &#125;else if(stat.isDirectory())&#123; console.log(item,'目录'); &#125; &#125;);&#125;);------------------------------// 3. 删除目录fs.rmdir(path.join(__dirname, 'abc'), (err) =&gt; &#123; console.log(err);&#125;);fs.rmdirSync(path.join(__dirname,'qqq')); 10. 包多个模块可以形成包，不过要满足特定的规则才能形成规范的包 10.1 npmNPM （node.js package management）全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具。官方网站 10.2 npm包安装方式 本地安装 本地安装的包在当前目录下的node_modules里面，本地安装的包一般用于实际的开发工作 全局安装-g 全局安装的包位于Node.js环境的node_modules目录下，全局安装的包一般用于命令行工具 10.3 解决npm安装包被墙的问题10.3.1 –registry1npm config set registry=https//registry.npm.taobao.org 10.3.2 cnpm淘宝NPM镜像,与官方NPM的同步频率目前为10分钟一次官网: http://npm.taobao.org/ 12npm install -g cnpm –registry=https//registry.npm.taobao.org 使用cnpm安装包: cnpm install 包名 10.3.3 nrm作用：修改镜像源 项目地址：https://www.npmjs.com/package/nrm 12345安装：npm install -g nrm使用nrm ls 查看当前所有可用的镜像源地址以及当前所使用的镜像源地址。使用nrm use npm 或 nrm use taobao 切换不同的镜像源地址； 10.4 npm常用命令1234567891011开发环境（平时开发使用的环境）生产环境（项目部署上线之后的服务器环境）--save 向生产环境添加依赖 dependencies--save-dev 向开发环境添加依赖 DevDependencies npm install --production 只会安装生产的依赖包（去掉--production安装所有的依赖包）npm cache clean -f 清除缓存npm config set proxy http:&#x2F;&#x2F;127.0.0.1:61235&#x2F; 设置代理 10.4.1 安装包123456// 1. 如果没有指定版本号，那么安装最新版本npm install -g 包名称 (全局安装)npm install 包名称 (本地安装)// 2. 安装包的时候可以指定版本npm install -g 包名称@版本号 10.4.2 更新包123&#x2F;&#x2F; 更新到最新版本npm update -g 包名&#x2F;&#x2F;注：更新包update不一定生效，可用install重新安装最新版 10.4.3 卸载包1npm uninstall -g 包名 10.5 yarn基本使用类比npm基本使用 yrm：yarn地址管理工具，类似nrm 1234567891011121314151617181920212223242526272829安装yarn工具：npm install -g yarn1、初始化包 npm init yarn init2、安装包 npm install xxx --save yarn add xxx3、移除包 npm uninstall xxx yarn remove xxx4、更新包 npm update xxx yarn upgrade xxx5、安装开发依赖的包 npm install xxx --save-dev yarn add xxx --dev6、全局安装 npm install -g xxx yarn global add xxx7、设置下载镜像的地址 npm config set registry url yarn config set registry url8、安装所有依赖 npm install yarn install9、执行包 npm run yarn run 11. 自定义包11.1 包的规范 package.json必须在包的顶层目录下 二进制文件应该在bin目录下 JavaScript代码应该在lib目录下 文档应该在doc目录下 单元测试应该在test目录下 11.2 package.json字段分析 name：包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格 description：包的简要说明 version：符合语义化版本识别规范的版本字符串 keywords：关键字数组，通常用于搜索 maintainers：维护者数组，每个元素要包含name、email（可选）、web（可选）字段 contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者数组的第一- 个元素 bugs：提交bug的地址，可以是网站或者电子邮件地址 licenses：许可证数组，每个元素要包含type（许可证名称）和url（链接到许可证文本的- 地址）字段 repositories：仓库托管地址数组，每个元素要包含type（仓库类型，如git）、url（仓- 库的地址）和path（相对于仓库的路径，可选）字段 dependencies：生产环境包的依赖，一个关联数组，由包的名称和版本号组成 devDependencies：开发环境包的依赖，一个关联数组，由包的名称和版本号组成 11.3 自定义包案例1234567891011121314&#123; \"name\": \"hello\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"node index.js\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123;&#125;, \"devDependencies\": &#123;&#125;&#125;","tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://wgy1993.gitee.io/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"Node.js","slug":"Node-js","permalink":"https://wgy1993.gitee.io/tags/Node-js/"},{"name":"NPM","slug":"NPM","permalink":"https://wgy1993.gitee.io/tags/NPM/"}]},{"title":"Vue(二)","date":"2020-04-08T06:38:06.000Z","path":"archives/a5e3c20a.html","text":"1. 生命周期什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已；生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, methods: &#123; show() &#123; console.log('执行了show方法') &#125; &#125;, beforeCreate() &#123; // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 // console.log(this.msg) // this.show() // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 &#125;, created() &#123; // 这是遇到的第二个生命周期函数 // console.log(this.msg) // this.show() // 在 created 中，data 和 methods 都已经被初始化好了！ // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 &#125;, beforeMount() &#123; // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中 // console.log(document.getElementById('h3').innerText) // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted() &#123; // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 // console.log(document.getElementById('h3').innerText) // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时， // 如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 &#125;, // 接下来的是运行中的两个事件 beforeUpdate() &#123; // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了】 /* console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) */ //得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的， // 页面尚未和最新的数据保持同步 &#125;, updated() &#123; console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 &#125; &#125;);&lt;/script&gt; 2. vue-resource 实现 get, post, jsonp请求2.1 引用直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 12345678910&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;!-- 注意：vue-resource 依赖于 Vue，所以先后顺序要注意 --&gt; &lt;!-- this.$http.jsonp --&gt; &lt;script src=\"./lib/vue-resource-1.3.4.js\"&gt;&lt;/script&gt;&lt;/head&gt; 2.2 发起get请求1234567getInfo() &#123; // 发起get请求 // 当发起get请求之后， 通过 .then 来设置成功的回调函数 this.$http.get('http://vue.studyit.io/api/getlunbo').then(function (result) &#123; // 通过 result.body 拿到服务器返回的成功的数据 console.log(result.body) &#125;)&#125; 2.3 发送post请求12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 2.4 发送JSONP请求12345jsonpInfo() &#123; // 发起JSONP 请求 this.$http.jsonp('http://vue.studyit.io/api/jsonp').then(result =&gt; &#123; console.log(result.body) &#125;)&#125; 2.5 全局配置请求路径如果我们通过全局配置了请求的数据接口根域名，则在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 / ，否则不会启用根路径做拼接； 1234567891011121314151617&lt;script&gt; Vue.http.options.root = 'http://vue.studyit.io/'; // 全局启用 emulateJSON 选项 Vue.http.options.emulateJSON = true; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', methods: &#123; getAllList() &#123; this.$http.get('api/getprodlist').then(result =&gt; &#123; &#125;) &#125; &#125; &#125;);&lt;/script&gt; 3. 动画动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 3.1 不使用动画12345678910111213141516&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toggle\" @click=\"flag=!flag\"&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;h3 v-if=\"flag\"&gt;这是一个H3&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 3.2 使用过渡类名实现动画123456789101112131415161718192021222324252627282930313233343536373839&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toggle\" @click=\"flag=!flag\"&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;!-- 1. 使用 transition 元素，把 需要被动画控制的元素，包裹起来 --&gt; &lt;!-- transition 元素，是 Vue 官方提供的 --&gt; &lt;transition&gt; &lt;h3 v-if=\"flag\"&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt;&lt;!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 --&gt;&lt;style&gt; /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */ /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */ .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; /* v-enter-active 【入场动画的时间段】 */ /* v-leave-active 【离场动画的时间段】 */ .v-enter-active, .v-leave-active &#123; transition: all 0.8s ease; &#125;&lt;/style&gt; 3.3 修改v-前缀123456789101112131415161718192021222324252627282930313233&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toggle2\" @click=\"flag2=!flag2\"&gt; &lt;transition name=\"my\"&gt; &lt;h6 v-if=\"flag2\"&gt;这是一个H6&lt;/h6&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag2: false &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt;&lt;!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 --&gt;&lt;style&gt; .my-enter, .my-leave-to &#123; opacity: 0; transform: translateY(70px); &#125; .my-enter-active, .my-leave-active &#123; transition: all 0.8s ease; &#125;&lt;/style&gt; 3.4 使用第三方 CSS 动画库1、导入动画类库 1&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;.&#x2F;lib&#x2F;animate.css&quot;&gt; 2、定义 transition 及属性 1234567&lt;!-- 使用 :duration=\"&#123; enter: 200, leave: 400 &#125;\" 来分别设置 入场的时长 和 离场的时长 --&gt;&lt;transition enter-active-class=\"bounceIn\" leave-active-class=\"bounceOut\" :duration=\"&#123; enter: 200, leave: 400 &#125;\"&gt; &lt;h3 v-if=\"flag\" class=\"animated\"&gt;这是一个H3&lt;/h3&gt;&lt;/transition&gt; 3.5 使用动画钩子函数1、定义 transition 组件以及三个钩子函数： 12345678910&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"快到碗里来\" @click=\"flag=!flag\"&gt; &lt;!-- 1. 使用 transition 元素把 小球包裹起来 --&gt; &lt;transition @before-enter=\"beforeEnter\" @enter=\"enter\" @after-enter=\"afterEnter\"&gt; &lt;div class=\"ball\" v-show=\"flag\"&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt; 定义三个 methods 钩子方法： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; isshow: false &#125;, methods: &#123; // 注意： 动画钩子函数的第一个参数：el，表示要执行动画的那个DOM元素，是个原生的JS DOM对象 // 大家可以认为 ， el 是通过 document.getElementById('') 方式获取到的原生JS DOM对象 beforeEnter(el) &#123; // beforeEnter 表示动画入场之前，此时，动画尚未开始，可以在 beforeEnter 中，设置元素开始动画之前的起始样式 // 设置小球开始动画之前的，起始位置 el.style.transform = \"translate(0, 0)\" &#125;, enter(el, done) &#123; // 这句话，没有实际的作用，但是，如果不写，出不来动画效果； // 可以认为 el.offsetWidth 会强制动画刷新 el.offsetWidth; // enter 表示动画 开始之后的样式，这里，可以设置小球完成动画之后的，结束状态 el.style.transform = \"translate(150px, 450px)\"; el.style.transition = 'all 1s ease'; // 这里的 done， 起始就是 afterEnter 这个函数，也就是说：done 是 afterEnter 函数的引用 done() &#125;, afterEnter(el) &#123; // 动画完成之后，会调用 afterEnter // console.log('ok') this.flag = !this.flag &#125; &#125; &#125;);&lt;/script&gt; 定义样式： 123456.ball &#123; width: 15px; height: 15px; border-radius: 50%; background-color: red;&#125; 3.6 列表动画1234567891011&lt;!-- &lt;ul&gt; --&gt;&lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt;&lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 --&gt;&lt;!-- 给 transition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 --&gt;&lt;!-- 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 --&gt;&lt;transition-group appear tag=\"ul\"&gt; &lt;li v-for=\"(item, i) in list\" :key=\"item.id\" @click=\"del(i)\"&gt; &#123; &#123;item.id&#125; &#125; --- &#123; &#123;item.name&#125; &#125; &lt;/li&gt;&lt;/transition-group&gt;&lt;!-- &lt;/ul&gt; --&gt; &lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; &#125; li:hover &#123; background-color: hotpink; transition: all 0.8s ease; &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateY(80px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.6s ease; &#125; /* 下面的 .v-move 和 .v-leave-active 配合使用，能够实现列表后续的元素，渐渐地漂上来的效果 */ .v-move &#123; transition: all 0.6s ease; &#125; .v-leave-active &#123; position: absolute; &#125;&lt;/style&gt; 4. 组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 4.1 组件定义的三种方式：1、使用 Vue.extend 配合 Vue.component 方法 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;!-- 如果要使用组件，直接，把组件的名称，以 HTML 标签的形式，引入到页面中，即可 --&gt; &lt;mycom1&gt;&lt;/mycom1&gt;&lt;/div&gt;&lt;script&gt; // 1.1 使用 Vue.extend 来创建全局的Vue组件 // var com1 = Vue.extend(&#123; // template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;' // 通过 template 属性，指定了组件要展示的HTML结构 // &#125;) // 1.2 使用 Vue.component('组件的名称', 创建出来的组件模板对象) // Vue.component('myCom1', com1) // 如果使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命名，则在引用组件的时候，需要把 大写的驼峰改为小写的字母，同时，两个单词之前，使用 - 链接； // 如果不使用驼峰,则直接拿名称来使用即可; // Vue.component('mycom1', com1) // Vue.component 第一个参数:组件的名称,将来在引用组件的时候,就是一个 标签形式 来引入 它的 // 第二个参数: Vue.extend 创建的组件 ,其中 template 就是组件将来要展示的HTML内容 Vue.component('mycom1', Vue.extend(&#123; template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;' &#125;)); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 2、直接使用 Vue.component 方法 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;!-- 还是使用 标签形式,引入自己的组件 --&gt; &lt;mycom2&gt;&lt;/mycom2&gt;&lt;/div&gt;&lt;script&gt; // 注意:不论是哪种方式创建出来的组件,组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素 Vue.component('mycom2', &#123; template: '&lt;div&gt;&lt;h3&gt;这是直接使用 Vue.component 创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 3、引用template标签 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;mycom3&gt;&lt;/mycom3&gt;&lt;/div&gt;&lt;!-- 在被控制的 #app 外面,使用 template 元素,定义组件的HTML模板结构 --&gt;&lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h1&gt;这是通过 template 元素,在外部定义的组件结构,这个方式,有代码的只能提示和高亮&lt;/h1&gt; &lt;h4&gt;好用,不错!&lt;/h4&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('mycom3', &#123; template: '#tmpl' &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 4.2 私有组件12345678910111213141516171819202122&lt;div id=\"app2\"&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;&lt;template id=\"tmpl2\"&gt; &lt;h1&gt;这是私有的 login 组件&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; var vm2 = new Vue(&#123; el: '#app2', data: &#123;&#125;, methods: &#123;&#125;, filters: &#123;&#125;, directives: &#123;&#125;, components: &#123; // 定义实例内部私有组件的 login: &#123; template: '#tmpl2' &#125; &#125; &#125;)&lt;/script&gt; 4.3 组件中展示数据和响应事件12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;mycom1&gt;&lt;/mycom1&gt;&lt;/div&gt;&lt;script&gt; // 1. 组件可以有自己的 data 数据 // 2. 组件的 data 和 实例的 data 有点不一样,实例中的 data 可以为一个对象,但是 组件中的 data 必须是一个方法 // 3. 组件中的 data 除了必须为一个方法之外,这个方法内部,还必须返回一个对象才行; // 4. 组件中 的data 数据,使用方式,和实例中的 data 使用方式完全一样!!! Vue.component('mycom1', &#123; template: '&lt;h1&gt;这是全局组件 --- &#123; &#123;msg&#125; &#125;&lt;/h1&gt;', data: function () &#123; return &#123; msg: '这是组件的中data定义的数据' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 5. 组件切换5.1 flag标识符结合v-if和v-else12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;a href=\"\" @click.prevent=\"flag=true\"&gt;登录&lt;/a&gt; &lt;a href=\"\" @click.prevent=\"flag=false\"&gt;注册&lt;/a&gt; &lt;login v-if=\"flag\"&gt;&lt;/login&gt; &lt;register v-else=\"flag\"&gt;&lt;/register&gt;&lt;/div&gt;&lt;script&gt; Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;' &#125;); Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;' &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 5.2 使用Vue提供的compoent12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt; &lt;a href=\"\" @click.prevent=\"comName='login'\"&gt;登录&lt;/a&gt; &lt;a href=\"\" @click.prevent=\"comName='register'\"&gt;注册&lt;/a&gt; &lt;!-- Vue提供了 component ,来展示对应名称的组件 --&gt; &lt;!-- component 是一个占位符, :is 属性,可以用来指定要展示的组件的名称 --&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt; // 组件名称是 字符串 Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;' &#125;) Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 5.3 切换动画123456789101112131415161718&lt;!-- 通过 mode 属性,设置组件切换时候的 模式 --&gt;&lt;transition mode=\"out-in\"&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt;&lt;/transition&gt;&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.5s ease; &#125;&lt;/style&gt; 6. 组件传值6.1 父组件向子组件传值1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"app\"&gt; &lt;!-- 父组件，可以在引用子组件的时候， 通过 属性绑定（v-bind:） 的形式, 把 需要传递给 子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 --&gt; &lt;com1 v-bind:parentmsg=\"msg\"&gt;&lt;/com1&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123 啊-父组件中的数据' &#125;, methods: &#123;&#125;, components: &#123; // 结论：经过演示，发现，子组件中，默认无法访问到 父组件中的 data 上的数据 和 methods 中的方法 com1: &#123; data() &#123; // 注意： 子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的， // 比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上； // data 上的数据，都是可读可写的； return &#123; title: '123', content: 'qqq' &#125; &#125;, template: '&lt;h1 @click=\"change\"&gt;这是子组件 --- &#123; &#123; parentmsg &#125; &#125;&lt;/h1&gt;', // 注意： 组件中的 所有 props 中的数据，都是通过 父组件传递给子组件的 // props 中的数据，都是只读的，无法重新赋值 props: ['parentmsg'], // 把父组件传递过来的 parentmsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据 methods: &#123; change() &#123; this.parentmsg = '被修改了' &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 6.2 父组件向子组件传递方法子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=\"app\"&gt; &lt;!-- 父组件向子组件传递方法，使用的是事件绑定机制；v-on, 当我们自定义了 一个事件属性之后， 那么，子组件就能够，通过某些方式，来调用传递进去的这个方法了 --&gt; &lt;com2 @func=\"show\"&gt;&lt;/com2&gt;&lt;/div&gt;&lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;input type=\"button\" value=\"这是子组件中的按钮 - 点击它，触发 父组件传递过来的 func 方法\" @click=\"myclick\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 定义了一个字面量类型的 组件模板对象 var com2 = &#123; template: '#tmpl', // 通过指定了一个 Id, 表示说，要去加载 这个指定Id的 template 元素中的内容，当作组件的HTML结构 data() &#123; return &#123; sonmsg: &#123;name: '小头儿子', age: 6&#125; &#125; &#125;, methods: &#123; myclick() &#123; // 当点击子组件的按钮的时候，如何 拿到父组件传递过来的 func 方法，并调用这个方法？？？ // emit 英文原意： 是触发，调用、发射的意思 // this.$emit('func123', 123, 456) this.$emit('func', this.sonmsg) &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; datamsgFormSon: null &#125;, methods: &#123; show(data) &#123; // console.log('调用了父组件身上的 show 方法: --- ' + data) this.datamsgFormSon = data &#125; &#125;, components: &#123; com2 &#125; &#125;);&lt;/script&gt; 7. 使用ref获取DOM元素和组件引用1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"获取元素\" @click=\"getElement\" ref=\"mybtn\"&gt; &lt;h3 id=\"myh3\" ref=\"myh3\"&gt;哈哈哈， 今天天气太好了！！！&lt;/h3&gt; &lt;hr&gt; &lt;login ref=\"mylogin\"&gt;&lt;/login&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;', data() &#123; return &#123; msg: 'son msg' &#125; &#125;, methods: &#123; show() &#123; console.log('调用了子组件的方法') &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; console.log(document.getElementById('myh3').innerText); // ref 是 英文单词 【reference】 值类型 和 引用类型 referenceError console.log(this.$refs.myh3.innerText); console.log(this.$refs.mylogin.msg); this.$refs.mylogin.show(); &#125; &#125;, components: &#123; login &#125; &#125;);&lt;/script&gt; 8. 路由后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 8.1 在 vue 中使用 vue-router8.1.1 导入 vue-router 组件类库123&lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;!-- 1. 安装 vue-router 路由模块 --&gt;&lt;script src=\"./lib/vue-router-3.0.1.js\"&gt;&lt;/script&gt; 8.1.2 创建组件的模板对象12345678// 组件的模板对象var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;;var register = &#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;; 8.1.3 创建一个路由对象当 导入 vue-router 包之后，在 window 全局对象中，就有了一个 路由的构造函数，叫做 VueRouter 123456789101112131415// 在 new 路由对象的时候，可以为 构造函数，传递一个配置对象var routerObj = new VueRouter(&#123; // route // 这个配置对象中的 route 表示 【路由匹配规则】 的意思 routes: [ // 路由匹配规则 // 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性： // 属性1 是 path， 表示监听 哪个路由链接地址； // 属性2 是 component， 表示，如果 路由是前面匹配到的 path ，则展示 component 属性对应的那个组件 // 注意： component 的属性值，必须是一个 组件的模板对象， 不能是 组件的引用名称； // &#123; path: '/', component: login &#125;, &#123; path: '/', redirect: '/login' &#125;, // 这里的 redirect 和 Node 中的 redirect 完全是两码事 &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ], linkActiveClass: 'myactive'&#125;); 8.1.4 创建 Vue 实例，得到 ViewModel1234567// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件&#125;); 8.1.5 使用 router-link 组件来导航123456&lt;!-- &lt;a href=\"#/login\"&gt;登录&lt;/a&gt; --&gt;&lt;!-- &lt;a href=\"#/register\"&gt;注册&lt;/a&gt; --&gt;&lt;!-- router-link 默认渲染为一个a 标签 --&gt;&lt;router-link to=\"/login\" tag=\"span\"&gt;登录&lt;/router-link&gt;&lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; 8.1.6 使用 router-view 组件来显示匹配到的组件123&lt;!-- 这是 vue-router 提供的元素，专门用来 当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 --&gt;&lt;!-- 所以： 我们可以把 router-view 认为是一个占位符 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 8.2 使用tag属性指定router-link渲染的标签类型12&lt;!-- router-link 默认渲染为一个a 标签 --&gt;&lt;router-link to=\"/login\" tag=\"span\"&gt;登录&lt;/router-link&gt; 8.3 设置路由重定向redirect123routes: [ // 路由匹配规则 &#123; path: '/', redirect: '/login' &#125; // 这里的 redirect 和 Node 中的 redirect 完全是两码事] 8.4 设置路由高亮router-link-active123456789101112131415161718&lt;style&gt; .router-link-active, .myactive &#123; color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; &#125;&lt;/style&gt;var routerObj = new VueRouter(&#123; routes: [ // 路由匹配规则 &#123; path: '/register', component: register &#125; ], linkActiveClass: 'myactive'&#125;); 8.5 设置路由切换动效12345678910111213141516&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(140px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.5s ease; &#125;&lt;/style&gt;&lt;transition mode=\"out-in\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 9. 在路由规则中定义参数9.1 通过 this.$route.query来获取路由中的参数123456789101112131415&lt;!-- 如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 --&gt;&lt;router-link to=\"/login?id=10&amp;name=zs\"&gt;登录&lt;/router-link&gt;var login = &#123; template: '&lt;h1&gt;登录 --- &#123; &#123; $route.query.id &#125; &#125; --- &#123; &#123; $route.query.name &#125; &#125;&lt;/h1&gt;', data() &#123; return &#123; msg: '123' &#125; &#125;, created() &#123; // 组件的生命周期钩子函数 // console.log(this.$route) console.log(this.$route.query.id) &#125;&#125;; 9.2 通过 this.$route.params来获取路由中的参数12345678910111213141516171819202122232425&lt;!-- 如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 --&gt;&lt;router-link to=\"/login/12/ls\"&gt;登录&lt;/router-link&gt;var login = &#123; template: '&lt;h1&gt;登录 --- &#123; &#123; $route.params.id &#125; &#125; --- &#123; &#123; $route.params.name &#125; &#125;&lt;/h1&gt;', data() &#123; return &#123; msg: '123' &#125; &#125;, created() &#123; // 组件的生命周期钩子函数 console.log(this.$route.params.id) &#125;&#125;;var register = &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;'&#125;;var router = new VueRouter(&#123; routes: [ &#123;path: '/login/:id/:name', component: login&#125;, &#123;path: '/register', component: register&#125; ]&#125;); 10. 路由嵌套10.1 定义组件12345678910111213141516171819202122232425&lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to=\"/account/login\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/account/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 组件的模板对象 var account = &#123; template: '#tmpl' &#125;; var login = &#123; template: '&lt;h3&gt;登录&lt;/h3&gt;' &#125;; var register = &#123; template: '&lt;h3&gt;注册&lt;/h3&gt;' &#125;;&lt;/script&gt; 10.2 定义router123456789101112131415161718192021var router = new VueRouter(&#123; routes: [ &#123; path: '/account', component: account, // 使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ， // 否则永远以根路径开始请求，这样不方便我们用户去理解URL地址 children: [ &#123;path: 'login', component: login&#125;, &#123;path: 'register', component: register&#125; ] &#125; // &#123; path: '/account/login', component: login &#125;, // &#123; path: '/account/register', component: register &#125; ]&#125;);&lt;div id=\"app\"&gt; &lt;router-link to=\"/account\"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 11. 命名视图实现经典布局1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=\"container\"&gt; &lt;router-view name=\"left\"&gt;&lt;/router-view&gt; &lt;router-view name=\"main\"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var header = &#123; template: '&lt;h1 class=\"header\"&gt;Header头部区域&lt;/h1&gt;' &#125;; var leftBox = &#123; template: '&lt;h1 class=\"left\"&gt;Left侧边栏区域&lt;/h1&gt;' &#125;; var mainBox = &#123; template: '&lt;h1 class=\"main\"&gt;mainBox主体区域&lt;/h1&gt;' &#125;; // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; 'default': header, 'left': leftBox, 'main': mainBox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;);&lt;/script&gt; 12. 监听12.1 methods keyup事件监听12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt; &lt;!-- 分析： --&gt; &lt;!-- 1. 我们要监听到 文本框数据的改变，这样才能知道 什么时候去拼接 出一个 fullname --&gt; &lt;!-- 2. 如何监听到 文本框的数据改变呢？？？ --&gt; &lt;input type=\"text\" v-model=\"firstname\" @keyup=\"getFullname\"&gt; + &lt;input type=\"text\" v-model=\"lastname\" @keyup=\"getFullname\"&gt; = &lt;input type=\"text\" v-model=\"fullname\"&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstname: '', lastname: '', fullname: '' &#125;, methods: &#123; getFullname() &#123; this.fullname = this.firstname + '-' + this.lastname &#125; &#125; &#125;);&lt;/script&gt; 12.2 watch监听123456789101112131415161718192021222324252627282930&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstname\"&gt; + &lt;input type=\"text\" v-model=\"lastname\"&gt; = &lt;input type=\"text\" v-model=\"fullname\"&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstname: '', lastname: '', fullname: '' &#125;, methods: &#123;&#125;, watch: &#123; // 使用这个 属性，可以监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数 'firstname': function (newVal, oldVal) &#123;// 第一个参数是新数据，第二个参数是旧数据 // console.log('监视到了 firstname 的变化') // this.fullname = this.firstname + '-' + this.lastname this.fullname = newVal + '-' + this.lastname &#125;, 'lastname': function (newVal) &#123; this.fullname = this.firstname + '-' + newVal &#125; &#125; &#125;);&lt;/script&gt; 12.3 监视路由地址的改变1234567891011121314151617181920212223242526272829// 3. 创建一个路由对象var router = new VueRouter(&#123; routes: [ // 路由规则数组 &#123;path: '/', redirect: '/login'&#125;, &#123;path: '/login', component: login&#125;, &#123;path: '/register', component: register&#125; ], linkActiveClass: 'myactive' // 和激活相关的类&#125;)// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, // router: router router, watch: &#123; // this.$route.path '$route.path': function (newVal, oldVal) &#123; // console.log(newVal + ' --- ' + oldVal) if (newVal === '/login') &#123; console.log('欢迎进入登录页面') &#125; else if (newVal === '/register') &#123; console.log('欢迎进入注册页面') &#125; &#125; &#125;&#125;); 12.4 computed-计算属性的使用12345678910111213141516171819202122232425262728293031323334353637&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstname\"&gt; + &lt;input type=\"text\" v-model=\"middlename\"&gt; + &lt;input type=\"text\" v-model=\"lastname\"&gt; = &lt;input type=\"text\" v-model=\"fullname\"&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstname: '', lastname: '', middlename: '' &#125;, methods: &#123;&#125;, computed: &#123; // 在 computed 中，可以定义一些 属性，这些属性，叫做 【计算属性】， 计算属性的， // 本质，就是 一个方法，只不过，我们在使用 这些计算属性的时候，是把 它们的 名称， // 直接当作 属性来使用的；并不会把 计算属性，当作方法去调用； // 注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它 当作 普通 属性去使用就好了； // 注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化， // 就会 立即重新计算 这个 计算属性的值 // 注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所以来的任何数据， // 都没有发生过变化，则，不会重新对 计算属性求值； 'fullname': function () &#123; console.log('ok') return this.firstname + '-' + this.middlename + '-' + this.lastname &#125; &#125; &#125;);&lt;/script&gt; 12.5 watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； 13. 使用render函数渲染组件在页面中渲染基本的组件 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;p&gt;33333&lt;/p&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: '&lt;h1&gt;这是登录组件&lt;/h1&gt;' &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; login &#125; &#125;);&lt;/script&gt; 在页面中使用render函数渲染组件 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;p&gt;444444&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: '&lt;h1&gt;这是登录组件&lt;/h1&gt;' &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, render: function (createElements) &#123; // createElements 是一个 方法，调用它，能够把 指定的 组件模板，渲染为 html 结构 return createElements(login) // 注意：这里 return 的结果，会 替换页面中 el 指定的那个 容器 &#125; &#125;);&lt;/script&gt; 14. Vuexvuex 是 Vue 配套的公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，方便 整个程序中的任何组件直接获取或修改我们的公共数据 14.1 安装在 Vue 之后引入 vuex 会进行自动安装 12&lt;script src=\"/path/to/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"/path/to/vuex.js\"&gt;&lt;/script&gt; NPM 1npm install vuex --save Yarn 1yarn add vuex 在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex： 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 当使用全局 script 标签引用 Vuex 时，不需要以上安装过程。 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 14.2 最简单的 Store安装Vuex 之后，让我们来创建一个 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation： 123456789101112131415import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 现在，你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更： 123store.commit('increment')console.log(store.state.count) // -&gt; 1 为了在 Vue 组件中访问 this.$store property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 store 选项的方式“注入”该 store 的机制： 1234new Vue(&#123; el: '#app', store: store,&#125;) 14.3 案例main.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 入口文件import Vue from 'vue'// 配置vuex的步骤// 1. 运行 cnpm i vuex -S// 2. 导入包import Vuex from 'vuex'import App from './App.vue'// 3. 注册vuex到vue中Vue.use(Vuex)// 4. new Vuex.Store() 实例，得到一个 数据仓储对象var store = new Vuex.Store(&#123; state: &#123; // 大家可以把 state 想象成 组件中的 data ,专门用来存储数据的 // 如果在 组件中，想要访问，store 中的数据，只能通过 this.$store.state.*** 来访问 count: 0 &#125;, mutations: &#123; // 注意： 如果要操作 store 中的 state 值，只能通过 调用 mutations 提供的方法，才能操作对应的数据，不推荐直接操作 state 中的数据，因为 万一导致了数据的紊乱，不能快速定位到错误的原因，因为，每个组件都可能有操作数据的方法； increment(state) &#123; state.count++ &#125;, // 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit('方法名') // 这种 调用 mutations 方法的格式，和 this.$emit('父组件中方法名') subtract(state, obj) &#123; // 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数； console.log(obj) state.count -= (obj.c + obj.d) &#125; &#125;, getters: &#123; // 注意：这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations optCount: function (state) &#123; return '当前最新的count值是：' + state.count &#125; // 经过咱们回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为 过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者； // 其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值； &#125;&#125;)// 总结：// 1. state中的数据，不能直接修改，如果想要修改，必须通过 mutations// 2. 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.***// 3. 如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit('方法的名称'， 唯一的一个参数)// 4. 如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用 getters, 如果需要使用 getters ,则用 this.$store.getters.***const vm = new Vue(&#123; el: '#app', render: c =&gt; c(App), store // 5. 将 vuex 创建的 store 挂载到 VM 实例上， 只要挂载到了 vm 上，任何组件都能使用 store 来存取数据&#125;) counter.vue 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;减少&quot; @click&#x3D;&quot;remove&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;增加&quot; @click&#x3D;&quot;add&quot;&gt; &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;$store.state.count&quot;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; &#x2F;&#x2F; count: 0 &#125;; &#125;, methods: &#123; add() &#123; &#x2F;&#x2F; 千万不要这么用，不符合 vuex 的设计理念 &#x2F;&#x2F; this.$store.state.count++; this.$store.commit(&quot;increment&quot;); &#125;, remove() &#123; this.$store.commit(&quot;subtract&quot;, &#123;c: 3, d: 1&#125;); &#125; &#125;, computed: &#123; fullname: &#123; get() &#123; &#125;, set() &#123; &#125; &#125; &#125; &#125;;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt; amount.vue 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;!-- &lt;h3&gt;&#123; &#123; $store.state.count &#125; &#125;&lt;&#x2F;h3&gt; --&gt; &lt;h3&gt;&#123; &#123; $store.getters.optCount &#125; &#125;&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;","tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://wgy1993.gitee.io/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://wgy1993.gitee.io/tags/Vue/"}]},{"title":"Vue(一)","date":"2020-03-28T07:24:20.000Z","path":"archives/ad25968.html","text":"1. 什么是Vue Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 2. 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 3. 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto； 从 EJS 切换到 art-template 4. MVC和MVVM的关系图解 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 5. Vue基本代码 和 MVVM 之间的对应关系123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 导入Vue的包 --&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 将来 new 的Vue实例，会控制这个元素中的所有内容 --&gt;&lt;!-- Vue 实例所控制的这个元素区域，就是我们的 V --&gt;&lt;div id=\"app\"&gt; &lt;p&gt;&#123; &#123; msg &#125; &#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; // 2. 创建一个Vue的实例 // 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数 // 注意：我们 new 出来的这个 vm 对象，就是我们 MVVM中的 VM调度者 var vm = new Vue(&#123; el: '#app', // 表示，当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域 // 这里的 data 就是 MVVM中的 M，专门用来保存每个页面的数据的 data: &#123; // data 属性中，存放的是 el 中要用到的数据 msg: '欢迎学习Vue' // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; el 指定要控制的区域 data 是个对象，指定了控制的区域内要用到的数据 methods 虽然带个s后缀，但是是个对象，这里可以自定义了方法 在 VM 实例中，如果要访问 data 上的数据，或者要访问 methods 中的方法， 必须带 this 1234567891011121314151617181920212223242526&lt;script&gt; // 注意：在 VM实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名 或 this.方法名来进行访问，这里的this，就表示我们 new 出来的 VM 实例对象 var vm = new Vue(&#123; el: '#app', data: &#123; msg: '猥琐发育，别浪~~！', intervalId: null // 在data上定义 定时器Id &#125;, methods: &#123; lang() &#123; if (this.intervalId != null) return; this.intervalId = setInterval(() =&gt; &#123; var start = this.msg.substring(0, 1) // 获取到 后面的所有字符 var end = this.msg.substring(1) // 重新拼接得到新的字符串，并赋值给 this.msg this.msg = end + start &#125;, 400) // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去；【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 &#125; &#125; &#125;)&lt;/script&gt; 6. Vue指令6.1 插值表达式{ {} }1&lt;div&gt;&#123; &#123;msg2&#125; &#125;&lt;/div&gt; 6.2 v-cloak使用 v-cloak 能够解决插值表达式闪烁的问题 1234567&lt;style&gt; [v-cloak] &#123; display: none; &#125;&lt;/style&gt;&lt;p v-cloak&gt;++++++++ &#123; &#123; msg &#125; &#125; ----------&lt;/p&gt; 6.3 v-text默认 v-text 是没有闪烁问题的 v-text会覆盖元素中原本的内容，但是插值表达式只会替换自己的这个占位符，不会把整个元素的内容清空 1&lt;div v-text=\"msg\"&gt;&lt;/div&gt; 6.4 v-html执行js表达式 1234567891011121314151617&lt;div v-html=\"msg2\"&gt;1212112&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123', msg2: '&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;', mytitle: '这是一个自己定义的title' &#125;, methods: &#123; // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () &#123; alert('Hello') &#125; &#125; &#125;)&lt;/script&gt; 6.5 v-bindv-bind是 Vue中，提供的用于绑定属性的指令，v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 1&lt;input type=\"button\" value=\"按钮\" v-bind:title=\"mytitle\"&gt; 注意： v-bind: 指令可以被简写为 :要绑定的属性，v-bind 中，可以写合法的JS表达式 1&lt;input type=\"button\" value=\"按钮\" :title=\"mytitle + '123'\"&gt; 6.6 v-onVue 中提供了 v-on: 事件绑定机制 1&lt;input type=\"button\" value=\"按钮\" :title=\"mytitle + '123'\" v-on:click=\"alert('hello')\"&gt; v-on: 指令可以被简写为 @ 1&lt;input type=\"button\" value=\"按钮\" :title=\"mytitle + '123'\" @click=\"alert('hello')\"&gt; 6.7 事件修饰符123456789101112131415161718192021&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; div1Handler() &#123; console.log('这是触发了 inner div 的点击事件') &#125;, btnHandler() &#123; console.log('这是触发了 btn 按钮 的点击事件') &#125;, linkClick() &#123; console.log('触发了连接的点击事件') &#125;, div2Handler() &#123; console.log('这是触发了 outer div 的点击事件') &#125; &#125; &#125;);&lt;/script&gt; 6.7.1 .stop 阻止冒泡 123&lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\"&gt;&lt;/div&gt; 6.7.2 .prevent 阻止默认事件 1&lt;a href=\"http://www.baidu.com\" @click.prevent=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; 6.7.3 .capture添加事件侦听器时使用事件捕获模式 123&lt;div class=\"inner\" @click.capture=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt;&lt;/div&gt; 6.7.4 .self只当事件在该元素本身（比如不是子元素）触发时触发回调 123&lt;div class=\"inner\" @click.self=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt;&lt;/div&gt; 6.7.5 .once事件只触发一次 1&lt;a href=\"http://www.baidu.com\" @click.prevent.once=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; 6.8 v-mode使用 v-model 指令，可以实现表单元素和 Model 中数据的双向数据绑定 注意： v-model 只能运用在表单元素中 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;h4&gt;&#123; &#123; msg &#125; &#125;&lt;/h4&gt; &lt;!-- 注意： v-model 只能运用在 表单元素中 --&gt; &lt;!-- input(radio, text, address, email....) select checkbox textarea --&gt; &lt;input type=\"text\" style=\"width:100%;\" v-model=\"msg\"&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '大家都是好学生，爱敲代码，爱学习，爱思考，简直是完美，没瑕疵！' &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.9 vue中样式v-bind:class1、数组 1&lt;h1 :class=\"['red', 'thin']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 2、数组中使用三元表达式 1&lt;h1 :class=\"['red', 'thin', isactive?'active':'']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 3、数组中嵌套对象 1&lt;h1 :class=\"['red', 'thin', &#123;'active': isactive&#125;]\"&gt;这是一个邪恶的H1&lt;/h1&gt; 4、直接使用对象 1&lt;h1 :class=\"&#123;red:true, italic:true, active:true, thin:true&#125;\"&gt;这是一个邪恶的H1&lt;/h1&gt; 6.10 vue中样式v-bind:style1、直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style=\"&#123;color: 'red', 'font-size': '40px'&#125;\"&gt;这是一个善良的H1&lt;/h1&gt; 2、将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=\"h1StyleObj\"&gt;这是一个善良的H1&lt;/h1&gt; 3、在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;, h1StyleObj2: &#123; fontStyle: 'italic' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=\"[h1StyleObj, h1StyleObj2]\"&gt;这是一个善良的H1&lt;/h1&gt; 6.11 v-for6.11.1 v-for循环普通数组123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;!-- &lt;p&gt;&#123; &#123;list[0]&#125; &#125;&lt;/p&gt; &lt;p&gt;&#123; &#123;list[1]&#125; &#125;&lt;/p&gt; &lt;p&gt;&#123; &#123;list[2]&#125; &#125;&lt;/p&gt; &lt;p&gt;&#123; &#123;list[3]&#125; &#125;&lt;/p&gt; &lt;p&gt;&#123; &#123;list[4]&#125; &#125;&lt;/p&gt; --&gt; &lt;p v-for=\"(item, i) in list\"&gt;索引值：&#123; &#123;i&#125; &#125; --- 每一项：&#123; &#123;item&#125; &#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [1, 2, 3, 4, 5, 6] &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 6.11.2 v-for循环对象数组12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;p v-for=\"(user, i) in list\"&gt;Id：&#123; &#123; user.id &#125; &#125; --- 名字：&#123; &#123; user.name &#125; &#125; --- 索引：&#123; &#123;i&#125; &#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [ &#123;id: 1, name: 'zs1'&#125;, &#123;id: 2, name: 'zs2'&#125;, &#123;id: 3, name: 'zs3'&#125;, &#123;id: 4, name: 'zs4'&#125; ] &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 6.11.3 v-for循环对象12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;!-- 注意：在遍历对象身上的键值对的时候， 除了有 val key ,在第三个位置还有一个索引 --&gt; &lt;p v-for=\"(val, key, i) in user\"&gt;值是： &#123; &#123; val &#125; &#125; --- 键是： &#123; &#123;key&#125; &#125; -- 索引： &#123; &#123;i&#125; &#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; user: &#123; id: 1, name: '托尼·屎大颗', gender: '男' &#125; &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 6.11.4 v-for迭代数字1234567891011121314&lt;div id=\"app\"&gt; &lt;!-- in 后面我们放过 普通数组，对象数组，对象， 还可以放数字 --&gt; &lt;!-- 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始 --&gt; &lt;p v-for=\"count in 10\"&gt;这是第 &#123; &#123; count &#125; &#125; 次循环&lt;/p&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 6.11.5 v-for循环中key属性的使用1234&lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须在使用 v-for 的同时，指定唯一的字符串/数字类型 :key 值 --&gt;&lt;p v-for=\"item in list\" :key=\"item.id\"&gt; &lt;input type=\"checkbox\"&gt;&#123; &#123;item.id&#125; &#125; --- &#123; &#123;item.name&#125; &#125;&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 6.12 v-if/v-show12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toggle\" @click=\"flag=!flag\"&gt; &lt;!-- v-if 的特点：每次都会重新删除或创建元素 --&gt; &lt;!-- v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 --&gt; &lt;!-- v-if 有较高的切换性能消耗 --&gt; &lt;!-- v-show 有较高的初始渲染消耗 --&gt; &lt;!-- 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show --&gt; &lt;!-- 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if --&gt; &lt;h3 v-if=\"flag\"&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show=\"flag\"&gt;这是用v-show控制的元素&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123; &#125; &#125;);&lt;/script&gt; 7. 品牌管理案例-根据条件筛选品牌在Vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;div id=\"app\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;label&gt; 搜索名称关键字： &lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table table-bordered table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 之前，v-for 中的数据，都是直接从 data 上的list中直接渲染过来的 --&gt; &lt;!-- 现在，我们自定义了一个 search 方法，同时，把所有的关键字，通过传参的形式，传递给了 search 方法 --&gt; &lt;!-- 在 search 方法内部，通过执行 for 循环， 把所有符合搜索关键字的数据，保存到 一个新数组中，返回 --&gt; &lt;tr v-for=\"item in search(keywords)\" :key=\"item.id\"&gt; &lt;td&gt;&#123; &#123; item.id &#125; &#125;&lt;/td&gt; &lt;td v-text=\"item.name\"&gt;&lt;/td&gt; &lt;td&gt;&#123; &#123; item.ctime &#125; &#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', keywords: '', list: [ &#123;id: 1, name: '奔驰', ctime: new Date()&#125;, &#123;id: 2, name: '宝马', ctime: new Date()&#125; ] &#125;, methods: &#123; search(keywords) &#123; /*var newList=[]; this.list.forEach(item=&gt;&#123; if (item.name.indexOf(keywords) !=-1)&#123; newList.push(item); &#125; &#125;) return newList;*/ return this.list.filter(item =&gt; &#123; if (item.name.includes(keywords)) &#123; return item; &#125; &#125;) &#125; &#125; &#125;)&lt;/script&gt; 8. Vue调试工具vue-devtools安装地址 9. 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 过滤器的定义语法 123456Vue.filter('过滤器名称', function () &#123;&#125;)// 过滤器中的function第一个参数，已经被规定死了，永远都是过滤器管道符前面传递过来的数据Vue.filter('过滤器名称', function (data) &#123; return data + '123'&#125;) 9.1 全局的过滤器所谓的全局过滤器，就是所有的VM实例都共享的 123456789101112131415161718192021Vue.filter('dateFormat', function (dateStr, pattern = \"\") &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() // return y + '-' + m + '-' + d if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125;&#125;) 9.2 私有的过滤器只能在当前 VM 对象所控制的 View 区域进行使用 123456789101112131415161718192021222324252627282930// 如何自定义一个私有的过滤器（局部）var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123; // 定义私有过滤器 过滤器有两个条件 【过滤器名称 和 处理函数】 // 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器 dateFormat: function (dateStr, pattern = '') &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2, '0') var d = dt.getDate().toString().padStart(2, '0') if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours().toString().padStart(2, '0') var mm = dt.getMinutes().toString().padStart(2, '0') var ss = dt.getSeconds().toString().padStart(2, '0') return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125; ~~~~~~~` &#125; &#125; &#125;&#125;) 9.3 调用过滤器过滤器调用时候的格式 { { name | 过滤器的名称 } } 1&lt;td&gt;&#123; &#123;item.ctime | dataFormat('yyyy-mm-dd')&#125; &#125;&lt;/td&gt; 多个过滤器共同调用 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;p&gt;&#123; &#123; msg | msgFormat('疯狂+1', '123') | test &#125; &#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter('msgFormat', function (msg, arg, arg2) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/单纯/g, arg + arg2) &#125;) Vue.filter('test', function (msg) &#123; return msg + '========' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人' &#125; &#125;);&lt;/script&gt; 9.4 内置过滤器9.4.1 capitalize首字母大写 9.4.2 uppercase全部大写 9.4.3 lowercase全部小写 9.4.4 currency输出金钱以及小数点 参数: 第一个参数 {String} [货币符号] - 默认值: ‘$’ 第二个参数 {Number} [小数位] - 默认值: 2 10. 键盘修饰符10.1 默认键盘修饰符 为文本框回车键绑定事件 1234&lt;label&gt; Name: &lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.enter=\"add\"&gt;&lt;/label&gt; 10.2 使用自定义的按键修饰符通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名 12// 自定义全局按键修饰符Vue.config.keyCodes.f2 = 113; 11. 自定义指令11.1 定义全局的指令使用 Vue.directive() 定义全局的指令 v-focus 其中： 参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, 但是： 在调用的时候，必须在指令名称前 加上 v- 前缀来进行调用 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 12345678910111213141516171819202122232425262728293031Vue.directive('focus', &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 // 注意： 在每个函数中，第一个参数，永远是el ，表示被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 // 在元素刚绑定了指令的时候，还没有插入到DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125;&#125;)// 自定义一个 设置字体颜色的 指令Vue.directive('color', &#123; // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function (el, binding) &#123; // el.style.color = 'red' // console.log(binding.name) // 和样式相关的操作，一般都可以在 bind 执行 // console.log(binding.value) // console.log(binding.expression) el.style.color = binding.value &#125;&#125;) 12345&lt;label&gt; 搜索名称关键字： &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt; &lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\" v-focus v-color=\"'green'\"&gt;&lt;/label&gt; 11.2 自定义私有指令123456789101112131415161718var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123;&#125;, directives: &#123; // 自定义私有指令 'fontweight': &#123; // 设置字体粗细的 bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125;, 'fontsize': function (el, binding) &#123; // 注意：这个 function 等同于把代码写到了 bind 和 update 中去 el.style.fontSize = parseInt(binding.value) + 'px' &#125; &#125;&#125;) 123&lt;div id=\"app2\"&gt; &lt;h3 v-color=\"'pink'\" v-fontweight=\"900\" v-fontsize=\"50\"&gt;&#123; &#123; dt | dateFormat &#125; &#125;&lt;/h3&gt;&lt;/div&gt;","tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://wgy1993.gitee.io/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://wgy1993.gitee.io/tags/Vue/"}]},{"title":"Nginx","date":"2020-03-25T07:01:45.000Z","path":"archives/65b69107.html","text":"1. Nginx1.1 什么是NginxNginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师伊戈尔·西索夫（Igor Sysoev）所开发，官方测试 nginx 能够支支撑 5 万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定。 1.2 Nginx应用场景 http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 2. Nginx的安装与启动2.1 在Linux下的安装Nginx2.1.1 环境准备2.1.1.1 需要安装 gcc 的环境1yum install gcc-c++ 2.1.1.2 第三方的开发包PCRE: PCRE(Perl Compatible Regular Expressions)是一个 Perl 库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式。 1yum install -y pcre pcre-devel 注：pcre-devel 是使用 pcre 开发的一个二次开发库。nginx 也需要此库。 zlib: zlib 库提供了很多种压缩和解压缩的方式，nginx 使用 zlib 对 http 包的内容进行 gzip。 1yum install -y zlib zlib-devel OpenSSL: OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在 ssl 协议上传输 http）。 1yum install -y openssl openssl-devel 2.1.2 Nginx下载官方网站下载 nginx：http://nginx.org/ 2.1.3 Nginx安装1、把 nginx 的源码包nginx-1.8.0.tar.gz上传到 linux 系统 2、解压缩 1tar -zxvf nginx-1.8.0.tar.gz 3、进入nginx-1.8.0目录，使用 configure 命令创建makeFile 文件 123456789101112.&#x2F;configure \\--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \\--pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid \\--lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock \\--error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log \\--http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client \\--http-proxy-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;proxy \\--http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;fastcgi \\--http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;uwsgi \\--http-scgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;scgi 执行后可以看到Makefile文件 1234567891011121314151617181920212223242526Makefile是一种配置文件， Makefile 一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。configure参数.&#x2F;configure \\--prefix&#x3D;&#x2F;usr \\ 指向安装目录--sbin-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx \\ 指向（执行）程序文件（nginx）--conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \\ 指向配置文件--error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log \\ 指向log--http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log \\ 指向http-log--pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid \\ 指向pid--lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock \\ 安装文件锁定，防止安装文件被别人利用，或自己误操作。--user&#x3D;nginx \\--group&#x3D;nginx \\--with-http_ssl_module \\ 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）--with-http_flv_module \\ 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）--with-http_stub_status_module \\ 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）--with-http_gzip_static_module \\ 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）--http-client-body-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;client&#x2F; \\ 设定http客户端请求临时文件路径--http-proxy-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;proxy&#x2F; \\ 设定http代理临时文件路径--http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;fcgi&#x2F; \\ 设定http fastcgi临时文件路径--http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;uwsgi \\ 设定http uwsgi临时文件路径--http-scgi-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;scgi \\ 设定http scgi临时文件路径--with-pcre 启用pcre库 4、编译安装 123makemake install 2.2 Nginx启动与访问注意：启动nginx 之前，上边将临时文件目录指定为/var/temp/nginx/client， 需要在/var 下创建此目录 1mkdir &#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client -p 启动Nginx： 12345cd &#x2F;usr&#x2F;local&#x2F;ngiux&#x2F;sbin.&#x2F;nginxps aux|grep nginx 启动后查看进程 地址栏输入虚拟机的IP即可访问（默认为80端口） 关闭 nginx： 123.&#x2F;nginx -s stop或者.&#x2F;nginx -s quit 重启 nginx： 1.&#x2F;nginx -s reload 先关闭后启动，刷新配置文件 3. Nginx静态网站部署3.1 静态网站的部署将静态页面上传到服务器的/usr/local/nginx/html目录下即可访问 3.2 配置虚拟主机虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的物理服务器划分成多个“虚拟”服务器。虚拟主机技术极大的促进了网络技术的应用和普及。同时虚拟主机的租用服务也成了网络时代的一种新型经济形式。 3.2.1 端口绑定3.2.1.1 上传静态网站将/资料/静态页面/index目录上传至 /usr/local/nginx/index下 将/资料/静态页面/regist目录上传至 /usr/local/nginx/regist下 3.2.1.2 修改Nginx 的配置文件/usr/local/nginx/conf/nginx.conf 12345678910111213141516171819202122232425server &#123; listen 81; # 监听的端口 server_name localhost; # 域名或ip location &#x2F; &#123; # 访问路径配置 root index;# 根目录 index index.html index.htm; # 默认首页 &#125; error_page 500 502 503 504 &#x2F;50x.html; # 错误页面 location &#x3D; &#x2F;50x.html &#123; root html; &#125;&#125;server &#123; listen 82; # 监听的端口 server_name localhost; # 域名或ip location &#x2F; &#123; # 访问路径配置 root regist;# 根目录 index regist.html; # 默认首页 &#125; error_page 500 502 503 504 &#x2F;50x.html; # 错误页面 location &#x3D; &#x2F;50x.html &#123; root html; &#125;&#125; 3.2.1.3 访问测试地址栏输入：http://虚拟主机IP/:81 可以看到首页面 地址栏输入：http://虚拟主机IP/:82 可以看到注册页面 3.2.2 域名绑定3.2.2.1 什么是域名域名（Domain Name），是由一串用“点”分隔的字符组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置，地理上的域名，指代有行政自主权的一个地方区域）。域名是一个IP地址上有“面具” 。域名的目的是便于记忆和沟通的一组服务器的地址（网站)，电子邮件，FTP等）。域名作为力所能及难忘的互联网参与者的名称。域名按域名系统（DNS）的规则流程组成。在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示互联网协议（IP）资源，例如用于访问因特网的个人计算机，托管网站的服务器计算机，或网站本身或通过因特网传送的任何其他服务。世界上第一个注册的域名是在1985年1月注册的。 3.2.2.2 域名与IP绑定一个域名对应一个 ip 地址，一个 ip 地址可以被多个域名绑定。 本地测试可以修改 hosts 文件（C:\\Windows\\System32\\drivers\\etc） 可以配置域名和 ip 的映射关系，如果 hosts 文件中配置了域名和 ip 的对应关系，不需要走dns 服务器。 12虚拟主机IP www.hmtravel.com虚拟主机IP regist.hmtravel.com 修改nginx配置文件： 12345678910111213141516server &#123; listen 80; server_name www.hmtravel.com; location &#x2F; &#123; root index; index index.html; &#125;&#125;server &#123; listen 80; server_name regist.hmtravel.com; location &#x2F; &#123; root regist; index regist.html; &#125;&#125; 测试： 地址栏输入http://www.hmtravel.com/、http://regist.hmtravel.com/ 4. Nginx反向代理与负载均衡4.1 反向代理4.1.1 什么是反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 正向代理 正向代理是针对你的客户端，而反向代理是针对服务器的 4.1.2 配置反向代理准备工作： 将travel案例部署到tomcat中（ROOT目录），上传到服务器。 启动TOMCAT，输入网址http://虚拟主机IP:8080 可以看到网站首页 在Nginx主机修改 Nginx配置文件: 12345678910111213upstream tomcat-travel&#123; server 192.168.177.129:8080;&#125;server &#123; listen 80; # 监听的端口 server_name www.hmtravel.com; # 域名或ip location &#x2F; &#123; # 访问路径配置 # root index;# 根目录 proxy_pass http:&#x2F;&#x2F;tomcat-travel; index index.html index.htm; # 默认首页 &#125;&#125; 4.2 负载均衡4.2.1 什么是负载均衡负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 准备工作： 将刚才的存放工程的tomcat复制三份，修改端口分别为8080 ，8081，8082 分别启动这三个tomcat服务 为了能够区分是访问哪个服务器的网站，可以在首页标题加上标记以便区分 修改 Nginx配置文件： 1234567891011121314151617181920upstream tomcat-travel &#123; server 192.168.177.129:8080; server 192.168.177.129:8081; server 192.168.177.129:8082;&#125;server &#123; listen 80; # 监听的端口 server_name www.hmtravel.com; # 域名或ip location &#x2F; &#123; # 访问路径配置 # root index;# 根目录 proxy_pass http:&#x2F;&#x2F;tomcat-travel; index index.html index.htm; # 默认首页 &#125; error_page 500 502 503 504 &#x2F;50x.html; # 错误页面 location &#x3D; &#x2F;50x.html &#123; root html; &#125;&#125; 地址栏输入http:// www.hmtravel.com / 刷新观察每个网页的标题，看是否不同。 经过测试，三台服务器出现的概率各为33.3333333%，交替显示。 如果其中一台服务器性能比较好，想让其承担更多的压力，可以设置权重。 比如想让NO.1出现次数是其它服务器的2倍，则修改配置如下： 12345upstream tomcat-travel &#123; server 192.168.177.129:8080; server 192.168.177.129:8081 weight&#x3D;2; server 192.168.177.129:8082;&#125;","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wgy1993.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Nginx","slug":"Nginx","permalink":"https://wgy1993.gitee.io/tags/Nginx/"}]},{"title":"Linux(二)","date":"2020-03-24T09:09:35.000Z","path":"archives/be6dfc49.html","text":"1. rpm1.1 概述RPM（RedHat Package Manager），Rethat软件包管理工具，类似windows里面的setup.exe， 是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。 RPM包的名称格式： Apache-1.3.23-11.i386.rpm “apache” 软件名称 “1.3.23-11”软件的版本号，主版本和此版本 “i386”是软件所运行的硬件平台 “rpm”文件扩展名，代表RPM包 1.2 常用命令1.2.1 查询123基本语法： rpm -qa 查询所安装的所有rpm软件包 rpm –qa | grep rpm软件包 过滤，查找指定RPM软件包 1.2.2 卸载123基本语法： rpm -e rpm软件包 rpm -e --nodeps rpm软件包 不考虑依赖包，强制卸载 1.2.3 安装1234567基本语法： rpm -ivh rpm包全名 -i&#x3D;install，安装 -v&#x3D;verbose，显示详细信息 -h&#x3D;hash，进度条 --nodeps，不检测依赖进度 2. yum2.1 概述YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。 2.2 常用命令123456基本语法： yum install -y httpd 安装httpd并确认安装 yum list 列出所有可用的package和package组 yum clean all 清除所有缓冲数据 yum deplist httpd 列出一个包所有依赖的包 yum remove httpd 删除httpd 2.3 关联网络yum源2.3.1 前期文件准备前提条件linux系统必须可以联网 在Linux环境环境中访问该网络地址：http://mirrors.163.com/.help/centos.html，在使用说明中点击CentOS6-&gt;再点击保存 2.3.2 替换本地yum文件123456781. 把下载的文件移动到&#x2F;etc&#x2F;yum.repos.d&#x2F;目录 mv CentOS6-Base-163.repo &#x2F;etc&#x2F;yum.repos.d&#x2F; 2. 备份CentOS-Base.repo cp CentOS-Base.repo CentOS-Base.repo.bak3. 用CentOS6-Base-163.repo替换CentOS-Base.repo mv CentOS6-Base-163.repo CentOS-Base.repo 2.3.3 安装命令123yum clean all 清除所有缓存yum makecache 生成缓存 3. Linux上软件安装3.1 安装方式 二进制发布包 软件已经针对具体平台编译打包发布，只要解压，修改配置即可 RPM包 软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装 Yum在线安装 软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题 源码编译安装 软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。 3.2 上传与下载工具3.2.1 FileZilla 3.2.2 lrzsz使用yum安装方式安装 yum install -y lrzsz 在SecureCRT中设置上传与下载目录 上传 rz： 上传文件时，须将文件放入SecureCRT设置的上传目录upload中 下载 sz： 3.2.3 sftpSecureCRT使用alt + p 组合键打开sftp窗口 使用put 命令上传： 使用get命令下载： 默认下载位置在当前计算的的文档位置 3.3 在Linux上安装JDK3.3.1 上传JDK1234567#上传JDK # 查看安装的jdk信息 rpm -qa | grep java# 卸载已有jdk rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686 rpm -e --nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686 3.3.2 安装JDK123通常将软件安装到&#x2F;usr&#x2F;local直接解压就可以 tar –zxvf jdk.tar.gz -C 目标路径 3.3.3 配置JDK的环境变量12345678910111. vi &#x2F;etc&#x2F;profile2. 在末尾行添加 #set java environment JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk&#x2F;jdk1.7.0_71 CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib.tools.jar PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH export JAVA_HOME CLASSPATH PATH 保存退出3. source &#x2F;etc&#x2F;profile 使更改的配置立即生效4. java -version 查看jdk版本 3.4 在Linux上安装mysql3.4.1 上传mysql123456#上传mysql # 查看安装的mysql信息 rpm -qa | grep mysql# 卸载已有mysql rpm -e --nodeps mysql 3.4.2 安装mysql1234567891011使用tar命令解压 tar -xvf mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar清除yum里所有mysql依赖包 yum remove mysql-libs严格按照顺序安装 rpm -ivh mysql-community-common-5.7.29-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.29-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.29-1.el7.x86_64.rpm rpm -ivh mysql-community-server-5.7.29-1.el7.x86_64.rpm 3.4.3 配置数据库12345vim &#x2F;etc&#x2F;my.cnf添加character_set_server&#x3D;utf8 设置默认字符集UTF-8init_connect&#x3D;&#39;SET NAMES utf8&#39; 设置默认字符集UTF-8 3.4.4 设置密码和开启远程登录123456789#设置密码策略set global validate_password_policy&#x3D;LOW; 设置密码的验证强度等级set global validate_password_length&#x3D;4; 只要设置密码的长度小于 3 ，都将自动设值为 4set password&#x3D;password(&#39;root&#39;);#开启远程登录grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39;;flush privileges; 立即生效 3.5 在Linux上安装tomcat Tomcat上传到Linux上 将上传的tomcat解压 在tomcat/bin目录下执行 startup.sh（注意防火墙） 查看目标 tomcat/logs/catalina.out 3.5.1 部署项目到Linux 将war包上传到tomcat中的webapps目录 重启tomcat 3.6 在Linux上安装redis3.6.1 安装gcc-c++redis是C语言开发，安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境。 123456789yum install -y gcc-c++编译redis不成功还需安装:yum -y install centos-release-scl 升级到9.1版本yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutilscl enable devtoolset-9 bash以上为临时启用，如果要长期使用gcc 9.1的话：echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile 3.6.2 获取redis资源123cd &#x2F;usr&#x2F;local wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.5.tar.gz 3.6.3 安装redis1234567891011121314使用tar命令解压 tar -zxvf redis-6.0.5.tar.gz 编译安装 make cd src make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis make install安装完成后，会在&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin目录下生成下面几个可执行文件，它们的作用分别是： redis-server：Redis服务器端启动程序 redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作 redis-benchmark：Redis性能测试工具 redis-check-aof：数据修复工具 redis-check-dump：检查导出工具 3.6.4 配置redis1234567891. 复制配置文件到&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin目录： cd redis-6.0.5 cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin2. 修改配置文件 vi &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis.conf daemonize no 修改为 yes 设置为后台服务 注释掉bind 127.0.0.1 默认只支持本机连接，注释掉这行代表可以接受其他机器的连接 protected-mode yes 修改为 no 将redis的保护模式关闭掉，这样可以供外部来访问redis访问 3.6.5 启动redis123456cd redis&#x2F;bin 进入redis&#x2F;bin目录.&#x2F;redis-server redis.conf 启动redis服务端.&#x2F;redis-cli 启动redis客户端pkill redis 停止redis服务","tags":[{"name":"Linux","slug":"Linux","permalink":"https://wgy1993.gitee.io/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://wgy1993.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux(一)","date":"2020-03-23T08:54:46.000Z","path":"archives/115c672b.html","text":"1. Linux的概述1.1 学习Linux之前先了解UnixUnix是一个强大的多用户、多任务操作系统。于1969年在AT&amp;T的贝尔实验室开发。UNIX的商标权由国际开放标准组织（The Open Group）所拥有。UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。 1.2 Linux的概述Linux是基于Unix的，诞生于1991年10月5日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成 Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机 1.3 Linux的历史Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统。 1.4 Linux系统的应用服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等， 高性能运算、计算密集型应用Linux有强大的运算能力。 桌面应用系统 移动手持系统 1.5 Linux的版本Linux的版本分为两种：内核版本和发行版本； 内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ； 1.6 Linux的主流版本 2. Linux的安装2.1 虚拟机安装2.1.1 什么是虚拟机虚拟机：一台虚拟的电脑. 虚拟机软件: VmWare :收费的. VirtualBox :免费的. 2.2 CentOS的安装centos下载地址： 网易镜像：http://mirrors.163.com/centos/6/isos/ 搜狐镜像：http://mirrors.sohu.com/centos/6/isos/ 2.3 Linux的远程访问安装远程访问的软件SecureCRT 3. Linux的目录结构 4. Linux的常用命令4.1 切换目录命令1234567cd app 切换到app目录cd .. 切换到上一层目录cd &#x2F; 切换到系统根目录cd ~ 切换到用户主目录cd - 切换到上一个所在目录使用tab键来补全文件路径 4.2 列出文件列表123456789ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。 格式：ls[参数] [路径或文件名]常用： 在linux中以 . 开头的文件都是隐藏的文件 ls ls -a 显示所有文件或目录（包含隐藏的文件） ls -l 缩写成ll 4.3 创建目录和移除目录123456mkdir(make directory)命令可用来创建子目录。 mkdir app 在当前目录下创建app目录 mkdir –p app2&#x2F;test 级联创建aap2以及test目rmdir(remove directory)命令可用来删除“空”的子目录： rmdir app 删除app目录 4.4 浏览文件4.4.1 cat、more、less12345678910111213cat用于显示文件的内容,适合少量信息文件。格式：cat[参数]&lt;文件名&gt; cat yum.conf more一般用于要显示的内容会超过一个画面长度的情况。 more yum.conf 按空格键显示下一个画面。ctrl+f 按 b 键显示上一个画面。ctrl+b 回车显示下一行内容。 按 q 键退出查看。 less用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。 less yum.conf PgUp 和 PgDn 进行上下翻页. 4.4.2 tail12345tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。 用法: tail -10 &#x2F;etc&#x2F;passwd 查看后10行数据 tail -f catalina.log 动态查看日志(*****) ctrl+c 结束查看 4.5 文件操作4.5.1 rm12345678rm 删除文件 用法：rm [选项]... 文件... rm a.txt 删除a.txt文件删除需要用户确认，y&#x2F;n rm -f a.txt 不询问，直接删除rm 删除目录 rm -r a 递归删除询问递归删除 rm -rf a 不询问递归删除 rm -rf * 删除所有文件 rm -rf &#x2F;* 自杀 4.5.2 cp、mv1234567cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。 cp a.txt b.txt 将a.txt复制为b.txt文件 cp a.txt ..&#x2F; 将a.txt文件复制到上一层目录中mv 移动或者重命名 mv a.txt ..&#x2F; 将a.txt文件移动到上一层目录中 mv a.txt b.txt 将a.txt文件重命名为b.txt 4.5.3 tar1234567891011121314151617tar命令位于&#x2F;bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数： -c：创建一个新tar文件 -v：显示运行过程的信息 -f：指定文件名 -z：调用gzip压缩命令进行压缩 -t：查看压缩文件的内容 -x：解开tar文件打包： tar -cvf xxx.tar .&#x2F;*打包并且压缩： tar -zcvf xxx.tar.gz .&#x2F;* 解压 tar -xvf xxx.tar tar -zxvf xxx.tar.gz -C &#x2F;usr&#x2F;aaa 4.5.4 find1234567find指令用于查找符合条件的文件示例： find &#x2F; -name “ins*” 查找文件名称是以ins开头的文件 find &#x2F; -name “ins*” -ls find &#x2F; -user wgy -ls 查找用户wgy的文件 find &#x2F; -user wgy -type d -ls 查找用户wgy的目录 find &#x2F; -perm 777 -type f -ls 查找权限是777的文件 4.5.5 grep123456查找文件里符合条件的字符串。用法: grep [选项]... PATTERN [FILE]...示例： grep lang anaconda-ks.cfg 在文件中查找lang grep lang anaconda-ks.cfg --color 高亮显示 grep lang anaconda-ks.cfg --color -A5 高亮显示后五行 grep lang anaconda-ks.cfg --color -A5 -B5 高亮显示前后五行 4.6 系统管理命令12345ps 正在运行的某个进程的状态 ps -ef 查看所有进程 ps -ef | grep ssh 查找某一进程 kill 2868 杀掉2868编号的进程 kill -9 2868 强制杀死进程 4.7 管道1234567管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例: ls --help | more 分页查询帮助信息 ps -ef | grep java 查询名称中包含java的进程 ifconfig | more cat index.html | more ps -ef | grep aio 4.8 其他常用命令1234567891011pwd显示当前所在目录touch创建一个空文件 touch a.txt clear&#x2F;crtl+L清屏history 查看所敲命令历史echo echo要显示的内容 &gt;&gt; 存储内容的的文件 5. Vi和Vim编辑器5.1 Vim编辑器1234567891011121314151617181920212223在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。三种模式：命令行、插入、底行模式。 切换到命令行模式：按Esc键； 切换到插入模式：按 i 、o、a键； i 在当前位置前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 切换到底行模式：按 :（冒号） 打开文件：vim file 退出：esc -&gt; :q 修改文件：输入i进入插入模式 保存并退出：esc-&gt;:wq 不保存退出：esc-&gt;:q! 快捷键： dd - 快速删除一行 yy - 复制当前行 nyy - 从当前行向后复制几行 p - 粘贴 R - 替换 5.2 重定向输出&gt;和&gt;&gt;123456&gt; 重定向输出，覆盖原有内容；&gt;&gt; 重定向输出，又追加功能；示例： cat &#x2F;etc&#x2F;passwd &gt; a.txt 将输出定向到a.txt中 cat &#x2F;etc&#x2F;passwd &gt;&gt; a.txt 输出并且追加 ifconfig &gt; ifconfig.txt 6. Linux的权限命令6.1 文件权限 r：对文件是指可读取内容，对目录是可以ls w：对文件是指可修改文件内容，对目录是指可以在其中创建或删除子节点(目录或文件) x：对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录 6.2 Linux三种文件类型普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 设备文件： Linux系统把每一个设备都看成是一个文件 6.3 文件类型标识普通文件（-） 目录（d） 符号链接（l） 6.4 文件权限管理12345chmod 变更文件或目录的权限。 chmod 755 a.txt chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx a.txt chmod -R 777 &#x2F;home&#x2F;cookiex&#x2F;abc -R表示的是目录以及目录下面的所bai有内容都设置为相同的指定权限位 7. Linux上常用网络操作7.1 主机名配置123hostname 查看主机名hostname xxx 修改主机名 重启后无效如果想要永久生效，可以修改&#x2F;etc&#x2F;sysconfig&#x2F;network文件 7.2 IP地址配置123456789101112ifconfig 查看(修改)ip地址(重启后无效)ifconfig eth0 192.168.12.22 修改ip地址如果想要永久生效修改 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0文件 DEVICE&#x3D;eth0 #网卡名称 BOOTPROTO&#x3D;static #获取ip的方式(static&#x2F;dhcp&#x2F;bootp&#x2F;none) HWADDR&#x3D;00:0C:29:B5:B2:69 #MAC地址 IPADDR&#x3D;12.168.177.129 #IP地址 NETMASK&#x3D;255.255.255.0 #子网掩码 NETWORK&#x3D;192.168.177.0 #网络地址 BROADCAST&#x3D;192.168.0.255 #广播地址 NBOOT&#x3D;yes # 系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。 7.3 域名映射/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用,相当于windows系统的C:\\Windows\\System32\\drivers\\etc\\hosts文件的功能 7.4 网络服务管理1234567891011121314service network status 查看指定服务的状态service network stop 停止指定服务service network start 启动指定服务service network restart 重启指定服务service --status -all 查看系统中所有后台服务netstat -nltp 查看系统中网络进程的端口监听情况防火墙设置防火墙根据配置文件&#x2F;etc&#x2F;sysconfig&#x2F;iptables来控制本机的”出”、”入”网络访问行为。service iptables status 查看防火墙状态service iptables stop 关闭防火墙service iptables start 启动防火墙chkconfig iptables off 禁止防火墙自启","tags":[{"name":"Linux","slug":"Linux","permalink":"https://wgy1993.gitee.io/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://wgy1993.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}]