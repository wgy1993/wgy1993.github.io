[{"title":"Struts2(一)","date":"2020-06-04T15:33:21.000Z","path":"archives/90bb5282.html","text":"1. Struts2基本概念1.1 三层架构和三大框架各自的位置1.1.1 三层架构我们的开发架构一般都是基于两种形式，一种是C/S架构，也就是客户端/服务器，另一种是B/S架构，也就是浏览器/服务器。在JavaEE开发中，几乎全都是基于B/S架构的开发。那么在B/S架构中，系统标准的三层架构包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层： 也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web层，web需要接收http请求，完成http响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用MVC模型。（MVC是表现层的设计模型，和其他层没有关系） 业务层： 也就是我们常说的service层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web层依赖业务层，但是业务层不依赖web层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制） 持久层： 也就是我们是常说的dao层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。 通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。 1.1.2 三大框架和三层架构的关系 1.2 Struts2概述Struts2是一种基于MVC模式的轻量级Web框架，它自问世以来，就受到了广大Web开发者的关注，并广泛应用于各种企业系统的开发中。目前掌握Struts2框架几乎成为Web开发者的必备技能之一。 在介绍Struts2之前，先来认识一下Struts1。Struts1是最早的基于MVC模式的轻量级Web框架，它能够合理的划分代码结构，并包含验证框架、国际化框架等多种实用工具框架。但是随着技术的进步，Struts1的局限性也越来越多的暴露出来。为了符合更加灵活、高效的开发需求，Struts2框架应运而生。 Struts2是Struts1的下一代产品，是在 Struts1和WebWork技术的基础上进行合并后的全新框架（WebWork是由OpenSymphony组织开发的，致力于组件化和代码重用的J2EE Web框架，它也是一个MVC框架）。虽然Struts2的名字与Struts1相似，但其设计思想却有很大不同。实质上，Struts2是以WebWork为核心的，它采用拦截器的机制来处理用户的请求。这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts2可以理解为WebWork的更新产品。 Struts2拥有优良的设计和功能，其优势具体如下： 项目开源，使用及拓展方便，天生优势。 提供Exception处理机制。 Result方式的页面导航，通过Result标签很方便的实现重定向和页面跳转。 通过简单、集中的配置来调度业务类，使得配置和修改都非常容易。 提供简单、统一的表达式语言来访问所有可供访问的数据。 提供标准、强大的验证框架和国际化框架。 提供强大的、可以有效减少页面代码的标签。 提供良好的Ajax支持。 拥有简单的插件，只需放入相应的JAR包，任何人都可以扩展Struts2框架，比如自定义拦截器、自定义结果类型、自定义标签等，为Struts2定制需要的功能，不需要什么特殊配置，并且可以发布给其他人使用。 拥有智能的默认设置，不需要另外进行繁琐的设置。使用默认设置就可以完成大多数项目程序开发所需要的功能。 2. Struts2的入门2.1 Struts2环境搭建2.1.1 下载struts2开发包Struts2的官网: https://struts.apache.org/ 2.1.2 Struts2开发包目录介绍解压后的目录结构如下： 2.1.3 搭建步骤2.1.3.1 第一步：拷贝struts2必备jar包到web工程的lib目录要进行struts2的基本的开发，可以参考struts-2.3.24中的apps下的一些示例代码，其中struts2-blank.war是一个struts2的空的工程。我们只需要将struts2-blank.war解压后进入到WEB-INF下的lib中查看。 2.1.3.2 第二步：在类的根路径下创建一个名称为struts.xml的文件，并导入约束在开发中需要将struts.xml文件引入到工程的src下，因为src下内容发布到web服务器中就是WEB-INF下的classes中。 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 导入约束： 约束的位置：在struts2的核心jar包中 struts2-core-2.3.24.jar中包含一个名称为： struts-2.3.dtd的约束文件--&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt;&lt;&#x2F;struts&gt; 2.1.3.3 第三步：在web.xml配置struts2的核心控制器Struts2框架要想执行，所有的请求都需要经过这个前端控制器（核心过滤器） 12345678910111213141516&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot; version&#x3D;&quot;4.0&quot;&gt; &lt;!-- 配置struts2的核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;&lt;&#x2F;web-app&gt; 2.1.3.4 验证搭建成功与否把应用部署到tomcat中，启动tomcat，不报异常则表示搭建成功。 2.2 Struts2入门案例2.2.1 案例需求通过点击超链接发送请求，由Struts2中类来负责接收，并且在控制台输出接收到了的语句。 2.2.2 案例实现2.2.2.1 第一步：编写index.jsp 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;struts2的入门案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--struts2的核心控制默认会处理以.action为后缀的url，或者是没有任何后缀的url --%&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/hello\"&gt;访问第一个struts2应用&lt;/a&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/hello.action\"&gt;访问第一个struts2应用.action&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 2.2.2.2 第二步：编写Class12345678910111213141516171819202122232425/** * 我们的第一个动作类。 * 动作类： * 它就是一个概念。它就是struts2框架中用于处理请求的类。 * 我们以后处理请求都写动作类。 * * @author wgy */public class HelloAction &#123; /** * 我们的第一个动作方法 * 动作方法： * 动作类中用于处理请求的方法 * 动作方法有编写规范： * 1、访问修饰符都是public * 2、方法的返回值一般都是String(但是可以是void) * 3、方法都没有参数 * @return */ public String sayHello()&#123; System.out.println(\"HelloAction的sayHello方法执行了。。。。\"+this); return \"success\"; &#125;&#125; 2.2.2.3 第三步：在配置文件中配置我们的动作类123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.0.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 配置文件 --&gt; &lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 2.2.2.4 第四步：编写success.jsp1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;执行结果页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;执行成功！&lt;/body&gt;&lt;/html&gt; 2.2.2.5 第五步：启动tomcat测试访问结果2.3 Struts2的执行过程2.3.1 执行时序首先是，启动tomcat服务器，这时候会加载web.xml，当读到filter标签时，会创建过滤器对象。 Struts2的核心过滤器（StrutsPrepareAndExecuteFilter）会负责加载类路径下的struts.xml配置文件。 接下来，从客户端发送请求过来 先经过前端控制器（核心过滤器StrutsPrepareAndExecuteFilter），前端控制器会根据请求的名称在struts.xml中找到对应的配置，创建我们的动作类对象（每次访问时都会创建新的Action对象），然后执行指定的方法，根据方法的返回值找到Result的配置进行页面的跳转.最后响应浏览器。 2.3.2 内部执行流程Struts2框架在默认情况下核心控制器（StrutsPrepareAndExecuteFilter）默认会拦截以.action为后缀的请求，或者是没有任何后缀的请求。当拦截下来后，送入Struts2的核心内部。如下图所示： 我们通过上面的图解，应该明确在实际开发中我们用struts2要做哪些： 写动作类 写jsp 写配置文件 其中，又以配置文件为重。 3. Struts2的配置文件详解3.1 Struts2中的配置文件3.1.1 配置文件说明在struts2中给我们提供了6个配置文件。他们的加载时机是tomcat启动服务一加载我们的应用时，就加载struts2的配置文件。 他们的加载顺序入如下： 顺序 配置文件名 所在位置 说明 1 default.properties struts2-core-2.3.15.3.jar\\org\\apache\\struts2 不能修改 2 struts-default.xml struts2-core-2.3.15.3.jar 不能修改 3 strtuts-plugin.xml 在struts2提供的插件jar包中 不能修改 4 struts.xml 我们的应用中 我们修改的：推荐 5 struts.properties 我们的应用中 我们修改的 6 web.xml 我们的应用中 我们修改的，可以给过滤器配置参数 3.1.2 配置文件的注意事项 Struts2提供了两种配置的方式。一种是key=value的方式，即使用.properties文件。另一种是xml文件配置。我们推荐使用xml文件（它能描述层级关系）。 当多个配置文件中，有相同的参数，后加载的会把前面的值给覆盖了。 3.1.3 Struts2中的常用常量常量定义在了default.properties配置文件中，体现形式都是key=value。所有的struts2应用都会用到这些常量。 常用的： 常量名 常量值 说明 struts.i18n.encoding UTF-8 应用中使用的编码 struts.objectFactory.spring.autoWire name 和spring框架整合有关 struts.multipart.parser jakarta 指定文件上传用的组件 struts.multipart.maxSize 2097152 文件上传总文件大小限制：2M struts.action.extension action,, 能进入Struts2框架内部的url地址后缀名。多个值用逗号分隔 struts.enable.DynamicMethodInvocation false 是否允许动态方法调用 struts.devMode false 是否是开发模式。开发模式：改了配置文件，不需要重启。输出更多的错误信息。开发阶段建议为true struts.ui.theme xhtml 页面展示用的主题 3.2 Struts.xml中的标签详解3.2.1 constant标签123456789&lt;!-- constant标签： 作用： 用于修改struts2中的常量 属性： name：指定常量的key value：指定常量的值--&gt;&lt;!-- 开启开发者模式 --&gt;&lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; 3.2.2 package标签1234567891011121314151617181920&lt;!-- package标签： 作用：给访问的action进行分包管理。把配置文件按照面向对象的思想来管理。 属性： name：指定包的名称。必须写，并且必须唯一。 extends：指定当前包的父包。子包自动具备父包所定义的配置。我们的包一般都需要继承struts-default包。 该包在struts-defaul.xml文件中定义着。如果不继承该包，则不能使用struts2的核心功能。 abstract：把当前包声明为抽象包。抽象包就是用来被继承的。里面定义一般都是公共的配置。 只有没有action标签的包，才能定义为抽象包。 namespace：指定当前包的名称空间。它可以让我们的访问URL模块化。当我们指定了该属性，访问URL就变成了：名称空间+&#x2F;hello 名称空间的写法：第一个字符必须是&#x2F;，后面紧跟的字符必须是一个字母。其余内容可以是字母，也可以是数字。 例如：我们访问用户 &#x2F;user&#x2F;addUser.action &#x2F;user&#x2F;updateUser.action 名称空间有默认值。默认值是：&quot;&quot;--&gt;&lt;package name&#x3D;&quot;p1&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;n1&quot;&gt; &lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.2.3 action标签12345678910&lt;!-- action标签： 作用：建立动作名称，动作类和动作方法的对应关系 属性： name:指定动作名称。它是唯一的 class:指定动作类的全限定类名 method：指定动作方法名称--&gt;&lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3 action的三种创建方式3.3.1 第一种：无侵入式创建(实际开发中基本不用)12345678910111213/** * 我们的第一个动作类 * 动作类的第一种创建方式： * 无侵入式的创建。 */public class HelloAction &#123; public String sayHello()&#123; System.out.println(this); System.out.println(\"HelloAction中的sayHello方法执行了。。。。\"); return \"success\"; &#125;&#125; 123&lt;action name&#x3D;&quot;hello&quot; class&#x3D;&quot;com.wgy.web.action.HelloAction&quot; method&#x3D;&quot;sayHello&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3.2 第二种：实现Action接口的定义方式 (实际开发中用的也不多)12345678910111213/** * 通过实现接口的方式创建动作类 * * @author wgy */public class Hello2Action implements Action &#123; @Override public String execute() throws Exception &#123; System.out.println(\"Hello2Action的execute方法执行了。。。。\"); return SUCCESS; &#125;&#125; 1234&lt;!-- 默认动作方法：当我们要是执行的是execute方法时，method属性可以不写。 --&gt;&lt;action name&#x3D;&quot;hello2&quot; class&#x3D;&quot;com.wgy.web.action.Hello2Action&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; Action接口中的常量 SUCCESS：一般多用于成功 ERROR：一般多用于动作方法执行失败 LOGIN：一般多用于返回登录页面 NONE：一般用于不返回任何结果视图，和return null作用是一样的 INPUT：一般多用于数据回显，也是struts2中数据回显时的默认返回值。 3.3.3 第三种：继承ActionSupport (实际开发中采用的方式)12345678/** * 通过继承ActionSupport的方式创建动作类 * * @author wgy */public class Hello3Action extends ActionSupport &#123;&#125; 123&lt;action name&#x3D;&quot;hello3&quot; class&#x3D;&quot;com.wgy.web.action.Hello3Action&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.3.4 默认动作类：ActionSupport类1234&lt;!-- 通过struts-default.xml中我们知道默认的动作类是ActionSupport，所以如果实现该类的execute方法，则可以不用指定class和method属性 --&gt;&lt;action name&#x3D;&quot;hello4&quot;&gt; &lt;result name&#x3D;&quot;success&quot; type&#x3D;&quot;dispatcher&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;&lt;&#x2F;action&gt; 3.4 action的三种访问方式12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 用户的动作类 * * @author wgy */public class UserAction extends ActionSupport &#123; /** * 保存 * @return */ public String addUser() &#123; System.out.println(\"保存了用户\"); return SUCCESS; &#125; /** * 更新 * @return */ public String updateUser() &#123; System.out.println(\"更新了用户\"); return SUCCESS; &#125; /** * 查询 * @return */ public String deleteUser() &#123; System.out.println(\"删除了用户\"); return SUCCESS; &#125; /** * 删除 * @return */ public String findUser() &#123; System.out.println(\"查询了用户\"); return SUCCESS; &#125;&#125; 3.4.1 第一种：全匹配配置访问方式1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUser\"&gt;查询用户&lt;/a&gt; 1234567891011121314&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;addUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;addUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;updateUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;updateUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;deleteUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;deleteUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;action name&#x3D;&quot;findUser&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;findUser&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.4.2 第二种：使用通配符的方式* 通配符基本用法 1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUser\"&gt;查询用户&lt;/a&gt; 123456&lt;!-- 通配符基本用法 --&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;*&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot; method&#x3D;&quot;&#123;1&#125;&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 通配符的高级用法 1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/add_User\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/update_User\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/delete_User\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/find_User\"&gt;查询用户&lt;/a&gt; 123456&lt;!-- 通配符的高级用法 --&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;*_*&quot; class&#x3D;&quot;com.wgy.web.action.&#123;2&#125;Action&quot; method&#x3D;&quot;&#123;1&#125;&#123;2&#125;&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 3.4.3 第三种：使用动态方法调用的方式1234567&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!addUser\"&gt;添加用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!updateUser\"&gt;更新用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!deleteUser\"&gt;删除用户&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user!findUser\"&gt;查询用户&lt;/a&gt; 1234567&lt;!-- 使用动态方法调用的方式 --&gt;&lt;constant name&#x3D;&quot;struts.enable.DynamicMethodInvocation&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;package name&#x3D;&quot;user&quot; extends&#x3D;&quot;struts-default&quot;&gt; &lt;action name&#x3D;&quot;user&quot; class&#x3D;&quot;com.wgy.web.action.UserAction&quot;&gt; &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt;&lt;&#x2F;package&gt; 4. 案例：Strut2+Hibernate查询客户列表4.1 第一步：搭建hibernate开发环境并准备实体类和映射配置可参考Hibernate环境搭建。 Hibernate开发环境 1234567891011121314151617181920212223242526272829303132&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory--&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;struts2&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;property&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;&#x2F;property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping class&#x3D;&quot;com.wgy.domain.Customer&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 实体类和映射配置 123456789101112131415161718192021222324252627282930313233/** * 客户的实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name = \"cust_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 4.2 第二步：搭建struts2环境参考2.1.3章节的步骤去做。 4.3 第三步：导入crm的jsp页面把下图中红框内文件夹下所有内容都拷贝到WebContent目录中 4.4 第四步：修改menu.jsp12345&lt;TR&gt; &lt;TD class=menuSmall&gt; &lt;A class=style2 href=\"$&#123;pageContext.request.contextPath&#125;/customer/findAllCustomer.action\" target=main&gt;－ 客户列表&lt;/A&gt; &lt;/TD&gt;&lt;/TR&gt; 4.5 第五步：在配置文件中配置findAllCustomer.action1234567891011121314&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 开启开发者模式 --&gt; &lt;constant name&#x3D;&quot;struts.devMode&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;constant&gt; &lt;!-- 动作配置 --&gt; &lt;package name&#x3D;&quot;customer&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;customer&quot;&gt; &lt;action name&#x3D;&quot;findAllCustomer&quot; class&#x3D;&quot;com.wgy.web.action.CustomerAction&quot; method&#x3D;&quot;findAllCustomer&quot;&gt; &lt;result name&#x3D;&quot;findAllCustomer&quot;&gt;&#x2F;jsp&#x2F;customer&#x2F;list.jsp&lt;&#x2F;result&gt; &lt;&#x2F;action&gt; &lt;&#x2F;package&gt;&lt;&#x2F;struts&gt; 4.6 第六步：创建动作类并提供动作方法123456789101112131415161718192021222324/** * 客户的动作类 * * @author wgy */public class CustomerAction extends ActionSupport &#123; private ICustomerService customerService = new CustomerServiceImpl(); /** * 查询所有客户 * @return */ public String findAllCustomer()&#123; //1.调用service查询客户 List&lt;Customer&gt; customers = customerService.findAllCustomer(); //2.获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //3.把查询的结果存入请求域中 request.setAttribute(\"customers\", customers); //4.返回 return \"findAllCustomer\"; &#125;&#125; 4.7 第七步：编写service接口和实现类1234567891011121314/** * 客户的业务层接口 * * @author wgy */public interface ICustomerService &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 1234567891011121314151617181920212223242526272829303132/** * 客户的业务层实现类 * 事务控制在业务层的 * * @author wgy */public class CustomerServiceImpl implements ICustomerService &#123; private ICustomerDao customerDao = new CustomerDaoImpl(); @Override public List&lt;Customer&gt; findAllCustomer() &#123; Session s = null; Transaction tx = null; try&#123; //1.获取Session s = HibernateUtil.getCurrentSession(); //2.开启事务 tx = s.beginTransaction(); //3.执行操作 List&lt;Customer&gt; customers = customerDao.findAllCustomer(); //4.提交事务 tx.commit(); //5.返回结果 return customers; &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); throw new RuntimeException(e); &#125; &#125;&#125; 4.8 第八步：编写dao接口和实现类1234567891011121314/** * 客户的持久层接口 * * @author wgy */public interface ICustomerDao &#123; /** * 查询所有客户 * * @return */ List&lt;Customer&gt; findAllCustomer();&#125; 123456789101112/** * 客户的持久层实现类 * * @author wgy */public class CustomerDaoImpl implements ICustomerDao &#123; @Override public List&lt;Customer&gt; findAllCustomer() &#123; return HibernateUtil.getCurrentSession().createQuery(\"from Customer\").list(); &#125;&#125; 4.9 第九步：页面展示jsp/customer/list.jsp12345678910&lt;c:forEach items=\"$&#123;customers&#125;\" var=\"customer\"&gt; &lt;TR&gt; &lt;TD&gt;$&#123;customer.custName &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custLevel &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custSource &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custIndustry &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custAddress &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.custPhone &#125;&lt;/TD&gt; &lt;/TR&gt; &lt;/c:forEach&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Struts2","slug":"Struts2","permalink":"https://wgy1993.gitee.io/tags/Struts2/"}]},{"title":"Hibernate(四)","date":"2020-06-03T14:33:02.000Z","path":"archives/c4c4045f.html","text":"1. JPA相关概念1.1 JPA概述全称是：Java Persistence API。是SUN公司推出的一套基于ORM的规范。Hibernate框架中提供了JPA的实现。 JPA通过JDK 5.0注解或XML描述对象—关系表的映射关系，并将运行期的实体对象持久化到数据库中。 1.2 JPA的优势 标准化 JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。 容器级特性的支持 JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。 简单方便 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成。 查询能力 JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。 高级特性 JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。 1.3 学习JPA要明确的 JPA是一套ORM规范，Hibernate实现了JPA规范 hibernate中有自己的独立ORM操作数据库方式，也有JPA规范实现的操作数据库方式。 2. JPA入门2.1 需求介绍本章节我们实现基于JPA注解的对象关系映射，配置实体类和数据库表的对应关系。并且使用JPA规范中的方法实现CRUD操作。 2.2 JPA环境搭建2.2.1 第一步：拷贝jar包 2.2.2 第二步：创建配置文件在src下面的META-INF文件夹下面创建一个名称为persistence.xml的文件。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;persistence xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;persistence&#x2F;persistence_2_0.xsd&quot; version&#x3D;&quot;2.0&quot;&gt; &lt;!-- 配置持久化单元，可以配置多个，但是名称不能重复 name:用于指定持久化单元名称 transaction-type:指定事务的类型。 JTA：Java Transaction API RESOURCE_LOCAL:指的是本地代码事务。（我们用这个） --&gt; &lt;persistence-unit name&#x3D;&quot;myJPAUnit&quot; transaction-type&#x3D;&quot;RESOURCE_LOCAL&quot;&gt; &lt;!-- JPA规范的提供商 可以不写。--&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;&#x2F;provider&gt; &lt;!-- 指定由Jpa注解的实体类位置 可以不写。--&gt; &lt;class&gt;com.wgy.domain.Customer&lt;&#x2F;class&gt; &lt;!-- 连接库相关的一些配置 --&gt; &lt;properties&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot; value&#x3D;&quot;org.hibernate.dialect.MySQLDialect&quot;&#x2F;&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot; value&#x3D;&quot;update&quot;&#x2F;&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;persistence-unit&gt;&lt;&#x2F;persistence&gt; 2.2.3 第三步：编写工具类，用于获取JPA的操作数据库对象1234567891011121314151617181920212223/** * JPA的工具类 * * @author wgy */public class JPAUtil &#123; //它就相当于SessionFactory private static EntityManagerFactory factory; static &#123; //注意：该方法参数必须和persistence.xml中persistence-unit标签name属性取值一致 factory = Persistence.createEntityManagerFactory(\"myJPAUnit\"); &#125; /** * 获取EntityManager对象 * * @return */ public static EntityManager createEntityManager() &#123; return em.createEntityManager(); &#125;&#125; 2.2.4 第四步：编写实体类并使用注解配置12345678910111213141516171819202122232425262728293031323334/** * 客户实体类 * 使用的注解都是JPA规范，所以导包，都需要导入javax.persistence包下的 * * @author wgy */@Entity//表明该类是一个实体类@Table(name = \"cst_customer\")//建立当前类和数据库表的对应关系public class Customer implements Serializable &#123; @Id//表明当前字段是主键 @Column(name = \"cust_id\")//表明对应数据库的主键字段是cust_id @GeneratedValue(strategy = GenerationType.IDENTITY)//指定主键生成策略。 private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 2.3 JPA的CRUD操作2.3.1 保存123456789101112131415161718192021/** * 保存 */@Testpublic void test1() &#123; //创建客户对象 Customer c = new Customer(); c.setCustName(\"JPA Customer\"); //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行保存操作 em.persist(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.2 快照更新12345678910111213141516171819/** * 更新操作 */@Testpublic void test3() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //修改客户的地址为：顺义区 c.setCustAddress(\"顺义区\"); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.3 merge更新12345678910111213141516171819202122/** * 更新的另一种操作方式 * merge是合并 （两个实体合并） */@Testpublic void test4() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //修改客户的地址为：顺义区 c.setCustAddress(\"北京市顺义区\"); em.merge(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.4 删除1234567891011121314151617181920/** * 删除操作 */@Testpublic void test5() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); //删除操作 em.remove(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.5 查询一个12345678910111213141516171819202122232425262728293031323334353637/** * 查询一个实体 立即加载 */@Testpublic void test2() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.find(Customer.class, 1L); System.out.println(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125;/** * 查询一个实体 延迟加载 */@Testpublic void test2_1() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.执行更新操作（需要把更新的对象先查询出来） Customer c = em.getReference(Customer.class, 1L); System.out.println(c); //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 2.3.6 查询所有12345678910111213141516171819202122232425262728293031323334353637/** * 查询所有 * * 涉及的对象是： * JPA的Query * 如何获取该对象： * EntityManager的createQuery(String jpql) * 参数含义： * JPQL：Java Persistence Query Language * 他的写法和HQL很相似。也是把表名换成类名，把字段名换成属性名称 * 它在写查询所有时，不能直接用 from 实体类 * 需要使用select关键字 * select c from Customer c */@Testpublic void test6() &#123; //1.获取EntityManager对象 EntityManager em = JPAUtil.createEntityManager(); //2.获取事务对象，并开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.获取JPA的查询对象Query Query query = em.createQuery(\"select c from Customer c where custName like ? and custLevel = ? \"); //给占位符赋值 query.setParameter(1, \"%集%\"); query.setParameter(2, \"23\"); //执行方法获取结果集 //getSingleResult()：查询结果是一个对象 List list = query.getResultList(); for (Object o : list) &#123; System.out.println(o); &#125; //4.提交事务 tx.commit(); //5.关闭资源 em.close();&#125; 3. JPA的多表操作3.1 一对多关系配置及操作3.1.1 配置123456789101112131415161718192021222324252627282930313233343536373839404142/** * 客户实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name = \"cust_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; /** * 一对多关系映射：一个客户可以有多个联系人 * mappedBy 取消维护 * cascade 级联保存 * fetch 查询加载时机 */ @OneToMany(targetEntity = LinkMan.class,mappedBy = \"customer\",cascade = CascadeType.ALL,fetch = FetchType.EAGER) private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); ...&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 联系人的实体类 * * @author wgy */@Entity@Table(name = \"cst_linkman\")public class LinkMan implements Serializable &#123; @Id @Column(name = \"lkm_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long lkmId; @Column(name = \"lkm_name\") private String lkmName; @Column(name = \"lkm_gender\") private String lkmGender; @Column(name = \"lkm_phone\") private String lkmPhone; @Column(name = \"lkm_mobile\") private String lkmMobile; @Column(name = \"lkm_email\") private String lkmEmail; @Column(name = \"lkm_position\") private String lkmPosition; @Column(name = \"lkm_memo\") private String lkmMemo; /** * 一对多关系映射，多的一方。 * 从表实体包含主表实体的对象引用 */ @ManyToOne(targetEntity = Customer.class,fetch = FetchType.LAZY) @JoinColumn(name = \"lkm_cust_id\",referencedColumnName = \"cust_id\") private Customer customer; ...&#125; 3.1.2 操作3.1.2.1 保存123456789101112131415161718192021222324/** * 保存操作 * 创建一个客户和一个联系人 * 建立客户和联系人的双向关联关系 * 先保存客户，再保存联系人 */@Testpublic void test1() &#123; Customer c = new Customer(); LinkMan l = new LinkMan(); c.setCustName(\"JPA One To Many Customer\"); l.setLkmName(\"JPA One To Many LinkMan\"); c.getLinkmans().add(l); l.setCustomer(c); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); em.persist(c); em.persist(l); tx.commit(); em.close();&#125; 3.1.2.2 更新1234567891011121314151617181920212223/** * 更新操作 * 创建一个联系人 * 查询id为5的客户 * 为5这个客服分配该联系人 * 更新客户 */@Testpublic void test2() &#123; LinkMan l = new LinkMan(); l.setLkmName(\"JPA One To Many LinkMan 2\"); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer c = em.find(Customer.class, 5L); c.getLinkmans().add(l); l.setCustomer(c); tx.commit(); em.close();&#125; 3.1.2.3 删除123456789101112131415/** * 删除操作 */@Testpublic void test3() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer c = em.find(Customer.class, 5L); em.remove(c); tx.commit(); em.close();&#125; 3.1.2.4 查询12345678910111213141516171819202122232425262728293031323334353637/** * 根据客户查询客户下的联系人 */@Testpublic void test1() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //1.查询id为1的客户 Customer c = em.find(Customer.class, 1l); System.out.println(c); //查询当前客户下的联系人 Set&lt;LinkMan&gt; linkmans = c.getLinkmans(); System.out.println(linkmans); tx.commit(); em.close();&#125;/** * 根据联系人，查询联系人的所属客户 */@Testpublic void test2() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //1.查询id为1的客户 LinkMan l = em.find(LinkMan.class, 1l); System.out.println(l); //查询当前客户下的联系人 Customer c = l.getCustomer(); System.out.println(c); tx.commit(); em.close();&#125; 3.2 多对多关系配置及操作3.2.1 配置12345678910111213141516171819202122232425262728293031/** * 角色的实体类 * * @author wgy */@Entity@Table(name = \"sys_role\")public class SysRole implements Serializable &#123; @Id @Column(name = \"role_id\") @GenericGenerator(name = \"uuid\", strategy = \"uuid\")//声明一个主键生成器 name属性：给生成器起个名字。strategy：指定的就是hibernate中包含的生成策略 @GeneratedValue(generator = \"uuid\") private String roleId; @Column(name = \"role_name\") private String roleName; @Column(name = \"role_memo\") private String roleMemo; //多对多关系映射：一个角色可以赋予多个用户 @ManyToMany(cascade=CascadeType.ALL) //加入一张表 @JoinTable(name=\"user_role_ref\", joinColumns = &#123;@JoinColumn(name=\"role_id\",referencedColumnName=\"role_id\")&#125;,//写的是当前实体在中间表的外键字段 inverseJoinColumns=&#123;@JoinColumn(name=\"user_id\",referencedColumnName=\"user_id\")&#125;//写的是对方实体在中间表的外键字段 ) private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); ...&#125; 1234567891011121314151617181920212223242526272829/** * 用户的实体类 * * @author wgy */@Entity@Table(name = \"sys_user\")public class SysUser implements Serializable &#123; @Id @Column(name = \"user_id\") @GenericGenerator(name = \"uuid\", strategy = \"uuid\") @GeneratedValue(generator = \"uuid\") private String userId; @Column(name = \"user_name\") private String userName; @Column(name = \"user_password\") private String userPassword; @Column(name = \"user_state\") private Integer userState; //多对多关系映射：一个用户可以具备多个角色 @ManyToMany(mappedBy=\"users\",cascade= CascadeType.ALL) private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); ...&#125; 3.2.2 操作3.2.2.1 保存1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 保存操作 * 创建两个用户 * 创建三个角色 * 让1号用户具备1号和2号角色 * 让2号用户具备2号和3号角色 * 保存用户和角色 */@Testpublic void test1() &#123; SysUser u1 = new SysUser(); SysUser u2 = new SysUser(); u1.setUserName(\"JPA Many to Many u1\"); u2.setUserName(\"JPA Many to Many u2\"); SysRole r1 = new SysRole(); SysRole r2 = new SysRole(); SysRole r3 = new SysRole(); r1.setRoleName(\"JPA Many to Many r1\"); r2.setRoleName(\"JPA Many to Many r2\"); r3.setRoleName(\"JPA Many to Many r3\"); //建立用户和角色的关联关系 u1.getRoles().add(r1); u1.getRoles().add(r2); u2.getRoles().add(r2); u2.getRoles().add(r3); r1.getUsers().add(u1); r2.getUsers().add(u1); r2.getUsers().add(u2); r3.getUsers().add(u2); EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //保存操作 em.persist(u1); tx.commit(); em.close();&#125; 3.2.2.2 删除123456789101112131415/** * 删除操作 * 双向级联删除，不管是hibernate还是Jpa,多对多中都不能配置 */@Testpublic void test2() &#123; EntityManager em = JPAUtil.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); //查询用户 SysUser u1 = em.find(SysUser.class, \"8a7e83cc5fbf19b6015fbf19bada0000\"); em.remove(u1); tx.commit(); em.close();&#125; 4. JPA的其他说明4.1 JPA中使用C3P0连接池4.1.1 第一步：拷贝C3P0所必须的3个jar包 4.1.2 第二步：在persistence.xml配置文件中配置12&lt;!-- 配置使用C3P0数据源 --&gt;&lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot; value&#x3D;&quot;org.hibernate.connection.C3P0ConnectionProvider&quot;&#x2F;&gt; 4.1.3 验证是否配置成功1234567891011121314151617/** * 验证c3p0连接池是否配置成功 */@Testpublic void test1() &#123; //1.获取jpa中的操作对象 EntityManager em = JPAUtil.createEntityManager(); //2. Session session = em.unwrap(Session.class); //3.执行session的doWork方法 session.doWork(new Work() &#123; @Override public void execute(Connection conn) throws SQLException &#123; System.out.println(conn.getClass().getName()); &#125; &#125;);&#125; 12345678@Testpublic void test2() &#123; //1.获取jpa中的操作对象 EntityManager em1 = JPAUtil.createEntityManager(); EntityManager em2 = JPAUtil.createEntityManager(); //false System.out.println(em1 == em2);&#125; 4.2 JPA与Hibernate中操作数据的方法对照 5. Hibernate中使用JPA注解映射配置5.1 编写主配置文件(hibernate.cfg.xml)1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!-- 在类的根路径下创建名称为hibernate.cfg.xml的配置文件导入约束：dtd约束 --&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory SessionFactory的作用就是用于创建Session对象的。 Session对象就是hibernate中操作数据库的核心对象。 此处的配置不要求背，但是要求记住创建SessionFactory必须的三部分信息 第一部分： 连接数据库的信息 第二部分： hibernate的可选配置 第三部分： 映射文件的位置 --&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- update表示检测实体类的映射配置和数据库的表结构是否一致，如果不一致，更新表结构 --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 设置hibernate的连接池提供商 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider &lt;&#x2F;property&gt; &lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt; &lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping class&#x3D;&quot;com.wgy.domain.Customer&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 5.2 编写实体类并使用JPA注解配置123456789101112131415161718192021222324252627282930313233/** * 客户实体类 * * @author wgy */@Entity@Table(name = \"cst_customer\")public class Customer implements Serializable &#123; @Id @Column(name=\"cust_id\") @GeneratedValue(strategy=GenerationType.IDENTITY) private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...&#125; 5.2 操作5.2.1 保存12345678910111213/** * 保存 */@Testpublic void test1() &#123; Customer c = new Customer(); c.setCustName(\"hibernate jpa customer\"); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); s.save(c); tx.commit();&#125; 5.2.2 查询1234567891011/** * 查询一个 */@Testpublic void test2() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); System.out.println(c); tx.commit();&#125; 5.2.3 修改1234567891011/** * 修改 */@Testpublic void test3() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); c.setCustAddress(\"顺义区\"); tx.commit();&#125; 5.2.4 删除1234567891011/** * 删除操作 */@Testpublic void test4() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 6L); s.delete(c); tx.commit();&#125;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(三)","date":"2020-05-31T08:27:38.000Z","path":"archives/3e87eb50.html","text":"1. 多表设计1.1 表之间的关系划分 一对一 一对多（多对一） 多对多 2. 如何确立和实现数据库中的表关系2.1 一对多的表关系在数据库中如何实现?使用外键约束。我们一般习惯把一的方称为主表，把多的一方称为从表。 什么是外键： 从表中有一列，该列的取值除了null之外，只能来源于主表的主键。默认情况下，外键字段的值是可以重复的。 2.2 多对多的表关系在数据库中如何实现？使用中间表。中间表中只有两个外键，引用两个多对多表的主键。不能有其他字段信息，至于中间表的主键，应该采用联合主键。 任何一个多方的表和中间表去比较，都是一对多的关系。 2.3 一对一的表关系在数据库中如何实现？有两种： 第一种：建立外键的方式： 使用外键约束，唯一约束，非空约束。它是把外键字段加了非空和唯一约束。从而实现了一对一。 第二种：使用主键的方式： 让其中一张表既是主键，又是外键。 2.4 如何确立两张表之间的关系：找外键。 3. 学习多表映射配置要遵循的步骤 第一步：确定两张表之间的关系 第二步：在数据库中实现两张表之间的关系建立 第三步：在实体类中描述出两个实体之间的关系 第四步：在映射配置文件中建立两个实体和两张表之间的关系 4. 一对多关系映射配置示例：客户和联系人两张表 4.1 确定两张表之间的关系一个客户可以包含多个联系人，多个联系人可以属于同一个客户。所以：客户和联系人之间的关系是一对多。 4.2 在数据库中实现两张表之间的关系建立实现一对多的关系，靠外键。客户表是主表，联系人表是从表。我们需要在联系人表中添加外键。 4.3 在实体类中描述出两个实体之间的关系主表的实体类应该包含从表实体类的集合引用，从表的实体类应该包含主表实体类的对象引用 123456789101112131415161718192021/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; /** * 一对多关系映射：一的一方 * 主表实体应该包含从表实体的集合引用 */ private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); ...&#125; 1234567891011121314151617181920212223/** * 联系人的实体类 * * @author wgy */public class LinkMan implements Serializable &#123; private Long lkmId; private String lkmName; private String lkmGender; private String lkmPhone; private String lkmMobile; private String lkmEmail; private String lkmPosition; private String lkmMemo; /** * 一对多关系映射，多的一方。 * 从表实体包含主表实体的对象引用 */ private Customer customer; ...&#125; 4.4 在映射配置文件中建立两个实体和两张表之间的关系客户配置文件： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml导入约束：dtd约束 --&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot; lazy&#x3D;&quot;true&quot;&gt; &lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&#x2F;&gt; &lt;!-- 一对多关系映射：主表实体的映射配置 涉及的标签： set： 作用：用于配置set集合属性。 属性： name：指定实体类中set集合的属性名称。 table：指定从表的名称。在一对多配置时可以不写。 key: 作用：用于映射外键字段。 属性： column：指定外键字段名称 one-to-many: 作用：用于建立一对多的映射配置 属性： class：用于指定从表实体的名称 --&gt; &lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 联系人配置文件： 1234567891011121314151617181920212223242526272829&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;LinkMan&quot; table&#x3D;&quot;cst_linkman&quot;&gt; &lt;id name&#x3D;&quot;lkmId&quot; column&#x3D;&quot;lkm_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&#x2F;&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;lkmName&quot; column&#x3D;&quot;lkm_name&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmGender&quot; column&#x3D;&quot;lkm_gender&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmPhone&quot; column&#x3D;&quot;lkm_phone&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmMobile&quot; column&#x3D;&quot;lkm_mobile&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmEmail&quot; column&#x3D;&quot;lkm_email&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmPosition&quot; column&#x3D;&quot;lkm_position&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;lkmMemo&quot; column&#x3D;&quot;lkm_memo&quot;&#x2F;&gt; &lt;!-- 一对多关系映射：从表实体的映射配置 涉及的标签： many-to-one： 作用：建立多对一的映射配置 属性： name：从表实体中引用主表实体对象引用的名称 class：指定属性所对应的实体类名称 column：指定从表中外键字段的名称 --&gt; &lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 5. 多对多关系映射配置示例：用户和角色 5.1 确定两张表之间的关系一个用户可以有多个角色，一个角色可以赋给多个用户，所以用户和角色之间是多对多。 5.2 在数据库中实现两张表之间的关系建立在数据库中实现多对多要靠中间表。中间表中只能出现用户和角色主键。 5.3 在实体类中描述出两个实体之间的关系各自包含对方一个集合引用 12345678910111213141516/** * 用户的实体类 * * @author wgy */public class SysUser implements Serializable &#123; private Long userId; private String userName; private String userPassword; private Integer userState; //多对多关系映射：一个用户可以具备多个角色 private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); ...&#125; 123456789101112131415/** * 角色的实体类 * * @author wgy */public class SysRole implements Serializable &#123; private Long roleId; private String roleName; private String roleMemo; //多对多关系映射：一个角色可以赋予多个用户 private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); ...&#125; 5.4 在映射配置文件中建立两个实体和两张表之间的关系用户配置文件： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;SysUser&quot; table&#x3D;&quot;sys_user&quot;&gt; &lt;id name&#x3D;&quot;userId&quot; column&#x3D;&quot;user_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;userName&quot; column&#x3D;&quot;user_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;userPassword&quot; column&#x3D;&quot;user_password&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;userState&quot; column&#x3D;&quot;user_state&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 多对多关系映射 涉及的标签： set: 作用：用于映射set集合属性 属性： name：指定集合的名称 table：指定的是中间表的名称 key: 作用：用于映射外键字段 属性： column：指定的是当前实体在中间表的外键字段名称 many-to-many 作用：用于映射多对多的关系 属性： class：对方的实体类名称 column：对方在中间表的外键字段名称 --&gt; &lt;set name&#x3D;&quot;roles&quot; table&#x3D;&quot;user_role_ref&quot;&gt; &lt;key column&#x3D;&quot;user_id&quot;&gt;&lt;&#x2F;key&gt; &lt;many-to-many class&#x3D;&quot;SysRole&quot; column&#x3D;&quot;role_id&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 角色配置文件： 12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;class name&#x3D;&quot;SysRole&quot; table&#x3D;&quot;sys_role&quot;&gt; &lt;id name&#x3D;&quot;roleId&quot; column&#x3D;&quot;role_id&quot;&gt; &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;property name&#x3D;&quot;roleName&quot; column&#x3D;&quot;role_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;roleMemo&quot; column&#x3D;&quot;role_memo&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 多对多关系映射 --&gt; &lt;set name&#x3D;&quot;users&quot; table&#x3D;&quot;user_role_ref&quot; inverse&#x3D;&quot;true&quot;&gt; &lt;key column&#x3D;&quot;role_id&quot;&gt;&lt;&#x2F;key&gt; &lt;many-to-many class&#x3D;&quot;SysUser&quot; column&#x3D;&quot;user_id&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 6. 多表增删改操作6.1 一对多关系的操作6.1.1 保存操作6.1.1.1 正常保存12345678910111213141516171819/** * 保存操作 * 正常的保存：创建一个新的联系人，需要关联一个客户 */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c1 = s.get(Customer.class, 1L); //2.创建一个新的联系人 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人\"); //3.建立客户和联系人的关联关系（让联系人知道属于哪个客户即可） l.setCustomer(c1); //4.保存联系人 s.save(l); tx.commit();&#125; 6.1.1.2 特殊情况1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 特殊的情况： * 创建一个客户和一个联系人 * 建立联系人和客户的双向关联关系 * 使用符合原则的保存 * 原则是：先保存主表实体，再保存从表实体 * * 此时保存会有问题： * 我们保存两个实体，应该只有两条insert语句。 * 而执行结果却是多了一条update的语句。 * * 解决办法： * 让客户在执行操作的时候，放弃维护关联关系的权利。 * 配置的方式： * 在Customer的映射配置文件中的set标签上使用inverse属性。 * inverse含义：是否放弃维护关联关系的权利 * true：放弃 * false：不放弃（默认值） * */@Testpublic void test2()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_4\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_4\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 //持久态 有一级缓存和快照 s.save(c1); //持久态 有一级缓存和快照 s.save(l); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 6.1.1.3 级联保存级联操作是指当主控方执行保存、更新或者删除操作时，其关联对象（被控方）也执行相同的操作。 保存客户 123456789101112131415161718192021222324252627282930/** * 保存操作： * 级联保存 * 使用级联保存，配置的方式，仍然是找到Customer的映射配置文件的Set标签， * 也可以配置在many-to-one上。 * 在上面加入cascade属性 * cascade：配置级联操作 * 级联保存更新的取值：save-update */@Testpublic void test3()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_5\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_5\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 s.save(c1); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 保存联系人 123456789101112131415161718192021@Testpublic void test4()&#123; //1.创建一个客户 //瞬时态 Customer c1 = new Customer(); c1.setCustName(\"一对多的客户_6\"); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人_6\"); //3.建立客户和联系人的关联关系(双向) l.setCustomer(c1); c1.getLinkmans().add(l); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //4.保存，要符合原则 s.save(l); tx.commit();&#125; 1&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot;&#x2F;&gt; 6.1.2 更新操作123456789101112131415161718192021222324/** * 更新操作 * 需求： * 创建一个新的联系人，查询一个已有客户 * 联系人新联系人和已有客户的双向关联关系 * 更新客户 */@Testpublic void test5()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c1 = s.get(Customer.class, 1L); //2.创建一个新的联系人 //瞬时态 LinkMan l = new LinkMan(); l.setLkmName(\"一对多的联系人\"); //3.建立客户和联系人的关联关系（双向） l.setCustomer(c1); c1.getLinkmans().add(l); //4.更新客户 s.update(c1); tx.commit();&#125; 6.1.3 删除操作123456789101112131415161718192021/** * 删除操作 * 删除从表数据就是单表 * 删除主表数据： * 看有没有从表数据引用 * 有引用： * 在删除是，hibernate会把从表中的外键字段置为null，然后再删除主表数据。 * 如果外键字段有非空约束，则hibernate不能更新外键字段为null，会报错。 * 如果仍然想删除，此时需要使用级联删除。同时必须配置inverse属性是true。 * 没有引用： 就是单表，直接删 */@Testpublic void test6()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.查询一个客户 Customer c9 = s.get(Customer.class, 5L); //2.删除id为5的客户 s.delete(c9); tx.commit();&#125; 1234&lt;set name&#x3D;&quot;linkmans&quot; table&#x3D;&quot;cst_linkman&quot; inverse&#x3D;&quot;true&quot; cascade&#x3D;&quot;save-update,delete&quot;&gt; &lt;key column&#x3D;&quot;lkm_cust_id&quot;&#x2F;&gt; &lt;one-to-many class&#x3D;&quot;LinkMan&quot;&#x2F;&gt;&lt;&#x2F;set&gt; 6.2 多对多关系的操作6.2.1 保存操作12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 保存操作 * 需求： * 创建2个用户和3个角色 * 让1号用户具备1号和2号角色 * 让2号用户具备2号和3号角色 * 保存用户和角色 */@Testpublic void test1()&#123; SysUser u1 = new SysUser(); u1.setUserName(\"用户1\"); SysUser u2 = new SysUser(); u2.setUserName(\"用户2\"); SysRole r1 = new SysRole(); r1.setRoleName(\"角色1\"); SysRole r2 = new SysRole(); r2.setRoleName(\"角色2\"); SysRole r3 = new SysRole(); r3.setRoleName(\"角色3\"); //建立双向关联关系 //先建立用户的 u1.getRoles().add(r1); u1.getRoles().add(r2); u2.getRoles().add(r2); u2.getRoles().add(r3); //再建立角色 r1.getUsers().add(u1); r2.getUsers().add(u1); r2.getUsers().add(u2); r3.getUsers().add(u2); Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); s.save(u1); s.save(u2); s.save(r1); s.save(r2); s.save(r3); tx.commit();&#125; 6.2.2 删除操作12345678910111213141516/** * 删除操作 * 实际开发中：多对多的双向级联删除是禁止使用的 */@Testpublic void test2()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1查询id为3的用户 SysUser u3 = s.get(SysUser.class, 3L); //删除 s.delete(u3); tx.commit();&#125; 7. Hibernate中的多表查询7.1 对象导航查询7.1.1 概述对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。 例如：我们通过OID查询方式查出一个客户，可以调用Customer类中的getLinkMans()方法来获取该客户的所有联系人。 对象导航查询的使用要求是：两个对象之间必须存在关联关系。 7.1.2 对象导航检索示例查询联系人 123456789101112131415/** * 查询id为1的客户下所属联系人 * 一对多时，根据一的一方查询多的一方时，需要使用延迟加载。（默认配置即可） */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //查询id为1的客户 Customer c = s.get(Customer.class, 1L); System.out.println(c); Set&lt;LinkMan&gt; linkmans = c.getLinkmans(); System.out.println(linkmans); tx.commit();&#125; 查询客户 12345678910111213141516171819/** * 查询id为5的联系人属于哪个客户 * 多对一时，根据多的一方查询一的一方时，不需要使用延迟加载，而是使用立即加载，需要配置一下 * 需要找到联系人的映射配置文件：在many-to-one标签上使用lazy属性。 * 取值有： * false：使用立即加载。 * proxy：是看load方法是延迟加载还是立即加载 * no-proxy：不管 */@Testpublic void test2()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); LinkMan l = s.get(LinkMan.class, 5L); System.out.println(l); Customer c = l.getCustomer(); System.out.println(c); tx.commit();&#125; 1&lt;many-to-one name&#x3D;&quot;customer&quot; class&#x3D;&quot;Customer&quot; column&#x3D;&quot;lkm_cust_id&quot; cascade&#x3D;&quot;save-update&quot; lazy&#x3D;&quot;false&quot;&#x2F;&gt; load方法加载 1234567891011121314/** * 关于load方法改为立即加载的方式 * 找到查询实体的映射配置文件，它的class标签上也有一个lazy属性。含义是：是否延迟加载 * true：延迟加载(默认值) * false：立即加载 */@Testpublic void test3()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); Customer c = s.load(Customer.class, 1L); System.out.println(c); tx.commit();&#125; class标签的lazy：它只能管load方法是否是延迟加载。 set标签的lazy：它管查询关联的集合对象是否是延迟加载。 many-to-one的lazy：它管查询关联的主表实体是否是立即加载。","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(二)","date":"2020-05-28T16:09:27.000Z","path":"archives/4074cb7b.html","text":"1. Hibernate的持久化类和对象标识符1.1 持久化类的编写规范1.1.1 什么是持久化类Hibernate是持久层的ORM映射框架，专注于数据的持久化工作。 持久化就是将内存中的数据永久存储到关系型数据库中。 持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为是持久化类。其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。 1.1.2 持久化类的编写规范应该遵循JavaBean的编写规范: Bean：在软件开发中是指的可重用的组件。 JavaBean：指的是用java语言编写的可重用组件。在我们的实际项目中：domain,service,dao都可以看成是JavaBean。 编写规范： 类都是public的 一般实现序列化接口 类成员（字段）都是私有的 私有类成员都有公有get/set方法 类都有默认无参构造函数 细节： 数据类型的选择问题： 基本类型和包装类，选择哪个？由于包装类可以有null值。所以实际开发中都是用包装类。 1.2 Hibernate中对象标识符（OID）OID全称是Object Identifier，又叫做对象标识符。 它是hibernate用于区分两个对象是否是同一个对象的标识。 我们都知道，虚拟机内存区分两个对象看的是内存的地址是否一致。数据库区分两个对象，靠的是表的主键。Hibernate负责把内存中的对象持久化到数据库表中，靠的就是对象标识符来区分两个对象是否是同一个。实体类中映射主键的字段就是OID，如下图所示： 1.3 Hibernate的主键生成策略 2. Hibernate的一级缓存和对象状态2.1 Hibernate的一级缓存什么缓存？ 它就是内存中的临时数据。 什么样的数据适用于缓存，什么样的数据不适用缓存？ 适用缓存的数据： 经常查询的，并且不经常修改的。同时数据一旦出现问题，对最终结果影响不大的。 不适用缓存的数据： 不管是否经常查询，只要是经常修改的，都可以不用缓存。并且如果数据由于使用缓存，产生了异常数据，对最终结果影响很大，则不能使用。例如：股市的牌价，银行的汇率，商品的库存等等。 2.1.1 Hibernate中的一级缓存Hibernate的一级缓存就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。Hibernate的一级缓存的作用就是减少对数据库的访问次数。 在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存。只要 Session 实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。 Hibernate的一级缓存有如下特点： 当应用程序调用Session接口的save()、update()、saveOrUpdate时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。 当调用Session接口的load()、get()方法，以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中。 当调用Session的close()方法时，Session缓存会被清空。 2.1.2 测试一级缓存123456789101112131415161718192021/** * 证明一级缓存确实存在 */@Testpublic void test1() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //1.根据id查询客户 //先去数据库查询，并且把查询的结果存入了一级缓存之中 Customer c1 = s.get(Customer.class, 1L); System.out.println(c1); //2.根据id再次查询客户 //先去一级缓存中看看有没有，如果有的话，直接拿过来用，如果没有的话，再去查询。 Customer c2 = s.get(Customer.class, 1L); System.out.println(c2); //true 一级缓存缓存的是对象的地址 System.out.println(c1 == c2); tx.commit(); //session关闭，一级缓存就消失了 s.close();&#125; 2.1.3 快照机制Hibernate 向一级缓存放入数据时，同时复制一份数据放入到Hibernate快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。 1234567891011121314151617181920212223@Testpublic void test2() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //1.根据id查询客户 Customer c5 = s.get(Customer.class, 2L); //输出客户的地址：北京市顺义区 System.out.println(c5.getCustAddress()); //2.修改客户的地址为 湖北省 c5.setCustAddress(\"湖北省\"); //输出客户的地址：湖北省 System.out.println(c5.getCustAddress()); //没有写update语句 tx.commit(); //session关闭，一级缓存就消失了 s.close(); //打印c5的address，这个c5能不能用 答案是可以使用。 //此时输出是什么 北京市顺义区 | 湖北省 System.out.println(c5.getCustAddress());&#125; 2.2 对象的状态2.2.1 对象的状态说明Hibernate为了更好的来管理持久化类，特将持久化类分成了三种状态。在Hibernate中持久化的对象可以划分为四种状态，分别是瞬时态、持久态、脱管态和删除状态，一个持久化类的实例可能处于四种不同状态中的某一种，四种状态的详细介绍如下。 瞬时态（transient） 瞬时态也称为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，不存在持久化标识OID（相当于主键值），尚未与Hibernate Session关联，在数据库中也没有记录，失去引用后将被JVM回收。瞬时状态的对象在内存中是孤立存在的，与数据库中的数据无任何关联，仅是一个信息携带的载体。 持久态（persistent） 持久态的对象存在持久化标识OID ，加入到了Session缓存中，并且相关联的Session没有关闭，在数据库中有对应的记录，每条记录只对应唯一的持久化对象，需要注意的是，持久态对象是在事务还未提交前变成持久态的。 脱管态（detached） 脱管态也称离线态或者游离态，当某个持久化状态的实例与Session的关联被关闭时就变成了脱管态。脱管态对象存在持久化标识OID，并且仍然与数据库中的数据存在关联，只是失去了与当前Session的关联，脱管状态对象发生改变时Hibernate不能检测到。 删除状态（了解） 2.2.2 学习对象状态我们要明确的 是为了更好的掌握hibernate中操作的方法。 区分状态只有两个标识：一是否有OID，二是否和Session建立的关系 瞬时状态（临时状态） 标志：没有OID，和Session没有关系。 持久化状态 标志：有OID，和Session有关系。只有持久化状态的对象才会有一级缓存的概念。 脱管状态（游离状态） 标志：有OID，和Session没有关系。 删除状态（了解）： 标志：有OID，和Session有关系。同时已经调用了删除方法，即将从数据库中把记录删除。但是事务还没有提交，此时的对象状态是删除态。 1234567891011@Testpublic void test2() &#123; //瞬时状态 Customer c = new Customer(); c.setCustName(\"测试_saveOrUpdate\"); Session s1 = HibernateUtil.openSession(); Transaction tx1 = s1.beginTransaction(); s1.saveOrUpdate(c); tx1.commit(); s1.close();&#125; 1234567891011121314151617181920@Testpublic void test3() &#123; Session s1 = HibernateUtil.openSession(); Transaction tx1 = s1.beginTransaction(); //持久化状态 Customer c = s1.get(Customer.class, 9L); tx1.commit(); s1.close(); c.setCustAddress(\"顺义校区\"); //脱管状态 System.out.println(c); Session session = HibernateUtil.openSession(); Transaction tx = session.beginTransaction(); //持久化状态 session.saveOrUpdate(c); tx.commit(); session.close();&#125; 3. Hibernate的事务控制3.1 配置Session和线程绑定保证在Service中开启的事务时使用的Session对象和DAO中多个操作使用的是同一个Session对象。 在hibernate.cfg.xml文件中配置 12&lt;!-- 把session和线程绑定，从而实现一个线程只有一个Session --&gt;&lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt; 获取Session时使用的方法 1234567891011121314151617181920212223242526272829/** * 抽取hibernate的工具类 * * @author wgy */public class HibernateUtil &#123; private static SessionFactory factory; //了解：hibernate把可以预见的异常都转成了运行时异常 static &#123; try &#123; Configuration configuration = new Configuration(); configuration.configure(); factory = configuration.buildSessionFactory(); &#125; catch (ExceptionInInitializerError e) &#123; throw new ExceptionInInitializerError(\"初始化SessionFactory失败,请检查配置文件\"); &#125; &#125; /** * 从当前线程上获取Session对象 * @return session */ public static Session getCurrentSession()&#123; //只有配置了把session和线程绑定之后，才能使用此方法，否则返回值是null return factory.getCurrentSession(); &#125;&#125; 验证session和线程绑定的配置 12345678910111213141516171819202122@Testpublic void test1() &#123; Session s1 = HibernateUtil.getCurrentSession(); Session s2 = HibernateUtil.getCurrentSession(); // true System.out.println(s1 == s2);&#125;/** * 当我们把session和线程绑定之后，hibernate就会在提交或者回滚事务之后，自动帮我们关闭session */@Testpublic void test2() &#123; //瞬时状态 Customer c = new Customer(); c.setCustName(\"测试_getCurrentSession\"); Session s1 = HibernateUtil.getCurrentSession(); Transaction tx1 = s1.beginTransaction(); s1.saveOrUpdate(c); tx1.commit(); //s1.close();&#125; 4. Hibernate中的查询方式hibernate中一共有5种查询方式 OID查询： 根据id查询一个实体。涉及的方法：get和load SQL查询： 使用SQL语句查询数据库。涉及两种方式： 第一种：SQLQuery（一般不怎么用） 1234567891011121314151617@Testpublic void testFindAll() &#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); //使用session对象，获取一个查询对象Query SQLQuery sqlquery = s.createSQLQuery(\"select * from cst_customer\"); //使用sqlquery对象获取结果集 List&lt;Object[]&gt; list = sqlquery.list(); for (Object[] os : list) &#123; System.out.println(\"------------数组中的内容-----------\"); for (Object o : os) &#123; System.out.println(o); &#125; &#125; tx.commit(); s.close();&#125; 第二种：session的doWork方法，它可以拿到Connection 1234567891011121314151617181920/** * hibernate中如何使用原始JDBC API * JDBC的API： * Connection * Statement * PreparedStatement * ResultSet */@Testpublic void test1() &#123; //1.获取Session对象 Session s = HibernateUtil.openSession(); //2.调用doWork方法 s.doWork(new Work() &#123; @Override public void execute(Connection conn) throws SQLException &#123; System.out.println(conn.getClass().getName()); &#125; &#125;);&#125; HQL查询： 使用HQL语句查询数据库 QBC查询： 使用Criteria对象查询数据库 对象导航查询： 对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。 5. Hibernate查询对象的API5.1 Query5.1.1 概述Query代表面向对象的一个Hibernate查询操作。 在Hibernate中，通常使用session.createQuery()方法接受一个HQL语句，然后调用Query的list()或uniqueResult()方法执行查询。 所谓的HQL是Hibernate Query Language缩写，其语法很像SQL语法，但它是完全面向对象的。 在Hibernate中使用Query对象的步骤，具体所示： 获得Hibernate的Session对象 编写HQL语句 调用session.createQuery 创建查询对象 如果HQL语句包含参数，则调用Query的setXxx设置参数 调用Query对象的方法执行查询 HQL的说明： ​ 把表的名称换成实体类名称。把表字段名称换成实体类属性名称。 例如： 12345SQL：select * from cst_customer where cust_name like ?HQL：select * from Customer where custName &#x3D; ?其中select * 可以省略，写为：from Customer where custName &#x3D; ? 5.1.2 常用查询5.1.2.1 基本查询12345678910111213141516/** * 基本查询 */@Testpublic void test1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.2 条件查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 条件查询 */@Testpublic void test2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer where custLevel = ? and custName like ?\"); //给参数占位符赋值 //hibernate的参数占位符是从0开始的 query.setString(0, \"23\"); query.setString(1, \"%集%\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125;/** * 条件查询 * 给参数占位符提供一个具体的名称 * 参数占位符的写法： * :名称 * 赋值的时候不需要写冒号，直接写名称 */@Testpublic void test3()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.获取Query对象 Query query = s.createQuery(\"from Customer where custName like :custName and custLevel = :custLevel\"); //2.给参数占位符赋值 //query.setString(\"custName\", \"%集%\"); //query.setString(\"custLevel\", \"普通客户\"); query.setParameter(\"custLevel\", \"23\"); query.setParameter(\"custName\", \"%集%\"); //3.执行对象的方法，获取结果集 List list = query.list(); for(Object o : list)&#123; System.out.println(o); &#125; tx.commit();&#125; 5.1.2.3 分页查询123456789101112131415161718192021222324252627282930/** * 分页查询 * mysql分页关键字 * limit * Limit的两个参数含义 * 第一个：查询的开始记录索引 * 第二个：每次查询的条数 * hibernate为我们提供了两个方法： * setFirstResult：设置查询的开始记录索引 * setMaxResults：设置每次查询的条数 * * 不管是用什么数据库，涉及分页的都是这两个方法。 * 因为SQL语句的生成已经是hibernate的事了。 */@Testpublic void test5() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer\"); //设置分页的方法 query.setFirstResult(2); query.setMaxResults(2); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.4 排序查询12345678910111213141516/** * 排序查询 */@Testpublic void test4() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"from Customer order by custId desc\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 5.1.2.5 统计查询12345678910111213141516171819202122232425/** * HQL使用聚合函数： * 统计查询 * 聚合函数： * count sum max min avg * * sql语句使用聚合函数时，在不使用group by子句的情况下，返回的结果，永远只有一行一列的情况。 * * 在SQL语句时： * select count(*) from table 它是统计所有字段，效率没有只统计主键字段高 * select count(主键) from table 它和第一个的结果是一样的，但是效率更高 * select count(非主键) from table 只统计不为null的字段 */@Testpublic void test1()&#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1.获取Query对象 Query query = s.createQuery(\"select count(*) from Customer\"); //2.获取结果集 //当返回的结果唯一时，可以使用此方法。如果返回的结果不唯一，使用了此方法会抛异常。 Long total = (Long)query.uniqueResult(); System.out.println(total); tx.commit();&#125; 5.1.2.6 投影查询12345678910111213141516171819202122/** * 投影查询 * 当我们在查询实体时，只需要部分字段，而是全部。并且希望它的返回结果使用实体类来封装，而不是Object[] * 这个时候我们称之为创建实体类的投影 * * 投影查询的用法： * 1.查询语句需要时使用new关键字 * 2.在实体类中添加对应参数列表的构造函数 */@Testpublic void test7() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.获取Query对象 Query query = session.createQuery(\"select new com.wgy.domain.Customer(custId,custName) from Customer\"); //2.获取结果集 List list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; transaction.commit();&#125; 123456789101112131415161718192021222324252627/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; public Customer() &#123; &#125; /** * //提供对应参数列表的构造函数 * @param custId * @param custName */ public Customer(Long custId, String custName) &#123; this.custId = custId; this.custName = custName; &#125; ..... 5.1.3 Query中的方法说明 list方法：该方法用于查询语句，返回的结果是一个list集合。 uniqueResult方法：该方法用于查询，返回的结果是一个Object对象。 setter方法：Query接口中提供了一系列的setter方法用于设置查询语句中的参数，针对不同的数据类型，需要用到不同的setter方法。 uniqueResult()方法：该方法用于返回唯一的结果，在确保只有一条记录的查询时可以使用该方法。 setFirstResult()方法：该方法可以设置获取第一个记录的位置，也就是它表示从第几条记录开始查询，默认从0开始计算。 setMaxResult()方法：该方法用于设置结果集的最大记录数，通常与setFirstResult()方法结合使用，用于限制结果集的范围，以实现分页功能。 5.2 Criteria5.2.1 概述Criteria是一个完全面向对象，可扩展的条件查询API，通过它完全不需要考虑数据库底层如何实现，以及SQL语句如何编写，它是Hibernate框架的核心查询对象。 Criteria 查询，又称为QBC查询（Query By Criteria），它是Hibernate的另一种对象检索方式。 通常，使用Criteria对象查询数据的主要步骤，具体如下： 获得Hibernate的Session对象 通过Session获得Criteria对象 使用Restrictions的静态方法创建Criterion条件对象。Restrictions类中提供了一系列用于设定查询条件的静态方法，这些静态方法都返回Criterion实例，每个Criterion实例代表一个查询条件 向Criteria对象中添加Criterion 查询条件。Criteria的add()方法用于加入查询条件 执行Criterita的 list() 或uniqueResult() 获得结果 细节： HQL能查的，QBC都能查，反之亦然。 5.2.2 常用查询5.2.2.1 基本查询1234567891011121314151617/** * 基本查询 */@Testpublic void test1() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 //它就相当于HQL的from Customer Criteria c = s.createCriteria(Customer.class); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.2 条件查询12345678910111213141516171819/** * 条件查询 */@Testpublic void test2() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //使用criteria对象的add方法来添加条件 c.add(Restrictions.eq(\"custLevel\", \"23\")); c.add(Restrictions.like(\"custName\", \"%集%\")); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.3 分页查询1234567891011121314151617181920/** * 分页查询 * QBC的分页查询和HQL的分页查询所用的方法和方法的含义都是一模一样的 */@Testpublic void test4() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //设置分页条件 c.setFirstResult(2); c.setMaxResults(2); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.4 排序查询123456789101112131415161718/** * 排序查询 */@Testpublic void test3() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //添加排序 c.addOrder(Order.desc(\"custId\")); //2. 获取结果集 List list = c.list(); for (Object o : list) &#123; System.out.println(o); &#125; tx.commit();&#125; 5.2.2.5 统计查询1234567891011121314151617/** * 统计（投影）查询 */@Testpublic void test5() &#123; Session s = HibernateUtil.getCurrentSession(); Transaction tx = s.beginTransaction(); //1. 获取Criteria对象 Criteria c = s.createCriteria(Customer.class); //设置聚合函数 //c.setProjection(Projections.rowCount()); c.setProjection(Projections.count(\"custId\")); //2. 获取结果集 Long count = (Long)c.uniqueResult(); System.out.println(count); tx.commit();&#125; 5.2.2.6 离线查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 离线查询 * 离线： * 它是和在线对应的。 * Criteria对象是一个在线对象，它是由一个可用的（活动的）Session对象获取的出来的。 * 当session失效时，就无法再获取该对象了。 * 有一个对象，它也可以用于设置条件，但是获取的时候并不需要Session对象。该对象就叫做离线对象： * DetachedCriteria对象 * 使用该对象进行的查询就叫做：离线查询 * * 如何获取该对象 * DetachedCriteria dCriteria = DetachedCriteria.forClass(要查询的实体类字节码); */@Testpublic void testServlet()&#123; //1.获取离线对象，不需要Session DetachedCriteria dc = DetachedCriteria.forClass(Customer.class); //2.封装查询条件 dc.add(Restrictions.eq(\"custLevel\", \"23\")); dc.add(Restrictions.like(\"custName\",\"%集%\")); List list = testService(dc); for(Object o : list)&#123; System.out.println(o); &#125;&#125;private List testService(DetachedCriteria dc) &#123; Session s = null; Transaction tx = null; try&#123; s = HibernateUtil.getCurrentSession(); tx = s.beginTransaction(); List list = testDao(dc); tx.commit(); return list; &#125;catch(Exception e)&#123; tx.rollback(); &#125; return null;&#125;private List testDao(DetachedCriteria dc) &#123; Session s = HibernateUtil.getCurrentSession(); //把离线对象转成在线对象 Criteria c = dc.getExecutableCriteria(s); return c.list();&#125; 5.2.3 QBC常用查询条件说明 短语 含义 Restrictions.eq 等于= Restrictions.allEq 使用Map,使用key/value进行多个等于的判断 Restrictions.gt 大于&gt; Restrictions.ge 大于等于&gt;= Restrictions.lt 小于&lt; Restrictions.le 小于等于&lt;= Restrictions.between 对应sql的between子句 Restrictions.like 对应sql的like子句 Restrictions.in 对应sql的in子句 Restrictions.and and 关系 Restrictions.or or关系 Restrictions.sqlRestriction Sql限定查询 Restrictions.asc() 根据传入的字段进行升序排序 Restrictions.desc() 根据传入的字段进行降序排序 运算类型 HQL运算符 QBC运算方法 type = Restrictions.eq() Restrictions.not(Restrictions.eq()) >= Restrictions.ge()","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Hibernate(一)","date":"2020-05-28T06:17:43.000Z","path":"archives/ef455019.html","text":"1. Hibernate和ORM的概念1.1 Hibrenate概述它是一个轻量级，企业级，开源的ORM持久层框架。是可以操作数据库的框架。 框架：它就是一个架构。 通常情况下，软件工程的持久层解决方案，一个为主一个为辅。两者并存（写SQL语句的和不写SQL语句的 轻量级：指的是使用时依赖的资源很少。（目前我们使用的阶段，只依赖log4j，c3p0连接池） 企业级：指的是在企业级应用中使用的比较多 开源的：开放源代码。 ORM的操作方式：建立对象关系映射，实现操作实体类就相当于操作数据库表。 Hibernate框架是当今主流的Java持久层框架之一，由于它具有简单易学、灵活性强、扩展性强等特点，能够大大地简化程序的代码量，提高工作效率，因此受到广大开发人员的喜爱。 Hibernate是一个开放源代码的ORM框架，它对JDBC进行了轻量级的对象封装，使得Java开发人员可以使用面向对象的编程思想来操作数据库。 1.2 ORMObject Relational Mapping 对象关系映射 就是建立实体类和数据库表的对应关系。 实现操作实体类对象就相当于操作数据库表 Object Relation Mapping 对象关系映射。 对象-关系映射（OBJECT/RELATIONALMAPPING，简称ORM），是随着面向对象的软件开发方法发展而产生的。用来把对象模型表示的对象映射到基于S Q L 的关系模型数据库结构中去。这样，我们在具体的操作实体对象的时候，就不需要再去和复杂的 SQ L 语句打交道，只需简单的操作实体对象的属性和方法[2] 。O R M 技术是在对象和关系之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化[1] 。 简单的说就是把我们程序中的实体类和数据库表建立起来对应关系。 1.3 为什么要学习Hibernate与其它操作数据库的技术相比，Hibernate具有以下几点优势： Hibernate对JDBC访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了DAO（Data Access Object，数据访问对象）层编码工作。 Hibernate的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。 可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。 明确： ​ 操作实体类就相当于操作数据库表 使用传统的JDBC开发应用系统时，如果是小型应用系统，并不觉得有什么麻烦，但是对于大型应用系统的开发，使用JDBC就会显得力不从心。例如对几十、几百张包含几十个字段的表进行插入操作时，编写的SQL语句不但很长，而且繁琐，容易出错；在读取数据时，需要写多条getXxx语句从结果集中取出各个字段的信息，不但枯燥重复，并且工作量非常大。为了提高数据访问层的编程效率，Gavin King开发出了一个当今最流行的的ORM框架，它就是Hibernate框架。 所谓的ORM就是利用描述对象和数据库表之间映射的元数据，自动把Java应用程序中的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库表的操作。可以把ORM理解为关系型数据和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。ORM原理如图所示。 2. CRMCRM：客户关系管理系统 CRM（Customer Relationship Management）客户关系管理，是利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，向客户提供创新式的个性化的客户交互和服务的过程。 其最终目标是将面向客户的各项信息和活动集成起来，组建一个以客户为中心的企业，实现对面向客户的活动的全面管理。 3. Hibernate快速入门3.1 需求介绍保存一个客户到数据库的客户表中。 3.2 搭建Hibernate开发环境3.2.1 第一步：拷贝必备的jar包到开发目录数据库驱动包，如下图： Hibernate/lib/required/*.jar，如下图： 日志记录的包，如下图: 3.2.2 第二步：创建数据库和实体类持久化类是应用程序中的业务实体类，这里的持久化是指类的对象能够被持久化保存到数据库中。Hibernate使用普通Java对象（Plain Old Java Object），即POJO的编程模式来进行持久化。POJO类中包含的是与数据库表相对应的各个属性，这些属性通过getter和setter方法来访问，对外部隐藏了内部的实现细节。下面就来编写Customer持久化类。 在项目src目录下，创建cn.wgy.domain包，并在包中创建实体类Customer（对应数据库表cst_customer），Customer类包含与cst_customer数据表字段对应的属性，以及相应的getXxx ()和setXxx ()方法。 1234567891011&#x2F;*创建客户表*&#x2F;CREATE TABLE &#96;cst_customer&#96; ( &#96;cust_id&#96; bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#39;客户编号(主键)&#39;, &#96;cust_name&#96; varchar(32) NOT NULL COMMENT &#39;客户名称(公司名称)&#39;, &#96;cust_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户信息来源&#39;, &#96;cust_industry&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户所属行业&#39;, &#96;cust_level&#96; varchar(32) DEFAULT NULL COMMENT &#39;客户级别&#39;, &#96;cust_address&#96; varchar(128) DEFAULT NULL COMMENT &#39;客户联系地址&#39;, &#96;cust_phone&#96; varchar(64) DEFAULT NULL COMMENT &#39;客户联系电话&#39;, PRIMARY KEY (&#96;cust_id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;94 DEFAULT CHARSET&#x3D;utf8; 123456789101112131415/** * 客户实体类 * * @author wgy */public class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; ...&#125; 3.2.3 第三步：编写映射配置文件（xml）实体类Customer目前还不具备持久化操作的能力，而Hibernate需要知道实体类Customer映射到数据库Hibernate中的哪个表，以及类中的哪个属性对应数据库表中的哪个字段，这些都需要在映射文件中配置。 在实体类Customer所在的包中，创建一个名称为Customer.hbm.xml的映射文件，在该文件中定义了实体类Customer的属性是如何映射到cst_customer表的列上的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。该文件建议名称为：实体类名称+.hbm+.xml --&gt;&lt;!-- 导入约束:dtd约束 位置：在Hibernate的核心jar包中名称为hibernate-mapping-3.0.dtd 明确该文件中的内容： 实体类和表的对应关系 实体类中属性和表的字段的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;&lt;!-- package属性用于设定包的名称，接下来该配置文件中凡是用到此包中的对象时都可以省略包名 --&gt;&lt;hibernate-mapping package&#x3D;&quot;com.wgy.domain&quot;&gt; &lt;!-- class标签 作用：建立实体类和表的对应关系 属性： name：指定实体类的名称 table：指定数据库表的名称 --&gt; &lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;cst_customer&quot;&gt; &lt;!-- id标签 作用：用于映射主键 属性： name：指定的是属性名称。也就是get&#x2F;set方法后面的部分，并且首字母要转小写。 column:指定的是数据库表的字段名称 --&gt; &lt;id name&#x3D;&quot;custId&quot; column&#x3D;&quot;cust_id&quot;&gt; &lt;!-- generator标签： 作用：配置主键的生成策略。 属性： class:指定生成方式的取值。 取值之一：native。使用本地数据库的自动增长能力。 mysql数据库的自动增长能力是让某一列自动+1。但是不是所有数据库都支持这种方式。 --&gt; &lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt; &lt;&#x2F;id&gt; &lt;!-- property标签： 作用：映射其他字段 属性： name：指定属性的名称。和id标签的name属性含义一致 column：指定数据库表的字段名称 --&gt; &lt;property name&#x3D;&quot;custName&quot; column&#x3D;&quot;cust_name&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custLevel&quot; column&#x3D;&quot;cust_level&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custSource&quot; column&#x3D;&quot;cust_source&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custIndustry&quot; column&#x3D;&quot;cust_industry&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custAddress&quot; column&#x3D;&quot;cust_address&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;custPhone&quot; column&#x3D;&quot;cust_phone&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;class&gt;&lt;&#x2F;hibernate-mapping&gt; 3.2.4 第四步：编写主配置文件（hibernate.cfg.xml）Hibernate的映射文件反映了持久化类和数据库表的映射信息，而Hibernate的配置文件则主要用来配置数据库连接以及Hibernate运行时所需要的各个属性的值。在项目的src下创建一个名称为hibernate.cfg.xml的文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!-- 在类的根路径下创建名称为hibernate.cfg.xml的配置文件 --&gt;&lt;!-- 导入dtd约束： 位置：在核心jar包中的名称为hibernate-configuration-3.0.dtd中--&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置SessionFactory SessionFactory的作用就是用于创建Session对象的。 Session对象就是hibernate中操作数据库的核心对象。 此处的配置不要求背，但是要求记住创建SessionFactory必须的三部分信息 第一部分： 连接数据库的信息 第二部分： hibernate的可选配置 第三部分： 映射文件的位置 --&gt; &lt;session-factory&gt; &lt;!-- 第一部分：连接数据库的信息 --&gt; &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hibernate01&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt; &lt;!-- 第二部分：hibernate的可选配置 --&gt; &lt;!-- 是否显示hibernate生成的SQL语句 --&gt; &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt; &lt;!-- 是否使用格式化输出sql语句到控制台 --&gt; &lt;property name&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;property&gt; &lt;!-- 是否让hibernate根据表结构的变化来生成DDL语句 DDL:数据定义语言 hibernate可以根据映射文件来为我们生成数据库的表结构。但是他不能生成数据库。 hbm2ddl.auto的取值 * none:不用Hibernate自动生成表. * create:每次都会创建一个新的表.(测试) * create-drop:每次都会创建一个新的表，执行程序结束后删除这个表.(测试) * update:如果数据库中有表，使用原来的表，如果没有表，创建一个新表.可以更新表结构。 * validate:只会使用原有的表.对映射关系进行校验. --&gt; &lt;property name&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt; &lt;!-- 第三部分：映射配置文件的位置 --&gt; &lt;mapping resource&#x3D;&quot;com&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;&#x2F;&gt; &lt;&#x2F;session-factory&gt;&lt;&#x2F;hibernate-configuration&gt; 3.4 实现保存操作在项目中新建一个名称为cn.wgy.test的包，然后在包中建立一个名为HibernateDemo1Test.java的文件，该文件是用来测试的类文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * hibernate的入门案例 * 需求： * 实现保存一个客户到数据库 * * @author wgy */public class HibernateDemo1Test &#123; /** * 步骤分析 * 1、解析主配置文件 * 2、根据配置文件创建SessionFactory * 3、根据SessionFactory创建Session * 4、开启事务 * 5、执行操作（保存） * 6、提交事务 * 7、释放资源 */ @Test public void test1() &#123; Customer customer = new Customer(); customer.setCustName(\"测试1\"); // 1、解析主配置文件 Configuration configuration = new Configuration(); configuration.configure(); // 2、根据配置文件创建SessionFactory SessionFactory sessionFactory = configuration.buildSessionFactory(); // 3、根据SessionFactory创建Session Session session = sessionFactory.openSession(); // 4、开启事务 Transaction transaction = session.beginTransaction(); // 5、执行操作（保存） session.save(customer); // 6、提交事务 transaction.commit(); // 7、释放资源 session.close(); sessionFactory.close(); &#125;&#125; 3.5 入门案例的执行过程首先创建Configuration类的实例，并通过它来读取并解析配置文件hibernate.cfg.xml。然后创建SessionFactory读取解析映射文件信息，并将Configuration对象中的所有配置信息拷贝到SessionFactory内存中。接下来，打开Session，让SessionFactory提供连接，并开启一个事务，之后创建对象，向对象中添加数据，通过session.save()方法完成向数据库中保存数据的操作。最后提交事务，并关闭资源。 4. Hibernate中API介绍4.1 Configuration对象4.1.1 作用在使用Hibernate时，首先要创建Configuration实例，Configuration实例主要用于启动、加载、管理hibernate的配置文件信息。在启动Hibernate的过程中，Configuration实例首先确定Hibernate配置文件的位置，然后读取相关配置，最后创建一个唯一的SessionFactory实例。Configuration对象只存在于系统的初始化阶段，它将SessionFactory创建完成后，就完成了自己的使命。 Hibernate通常使用Configuration config = new Configuration().configure();的方式创建实例，此种方式默认会去src下读取 hibernate.cfg.xml配置文件。如果不想使用默认的hibernate.cfg.xml配置文件，而是使用指定目录下（或自定义）的配置文件，则需要向configure()方法中传递一个文件路径的参数，其代码写法如下： 1Configuration config &#x3D; new Configuration().configure(&quot;xml文件位置&quot;); 此种写法hibernate会去指定位置查找配置文件，例如，想要使用src下config包中的 hibernate.cfg.xml文件，只需将文件位置加入configure()中即可，其代码如下所示： 1Configuration config = new Configuration().configure(\"/config/hibernate.cfg.xml\"); 【加载映射文件】 Hibernate除了可以使用Configuration对象加载核心配置文件以外，还可以利用该对象加载映射文件。因为如何使用properties文件作为Hibernate的核心配置文件，其他的属性可以使用key=value的格式来设置，但是映射没有办法加载。这时这个对象就有了用武之地。可以在手动编写代码的时候去加载映射文件。 123Configuration configuration &#x3D; new Configuration().configure(&quot;xml文件位置&quot;);configuration.addResource(&quot;cn&#x2F;wgy&#x2F;domain&#x2F;Customer.hbm.xml&quot;); 4.1.2 常用方法1234567891011121314默认构造函数： 它只能加载类的根路径下，名称为hibernate.properties的配置文件。不能加载xmlconfigure()： 它用于加载类的根路径下，名称为hibernate.cfg.xml的配置文件。 configuration.configure();buildSessionFactory()： 根据配置文件，构建SessionFactory SessionFactory sessionFactory &#x3D; configuration.buildSessionFactory();addResource(String url); 指定映射文件的位置 configuration.addResource(&quot;com&#x2F;itheima&#x2F;domain&#x2F;Customer.hbm.xml&quot;);addClass(Class clazz); 指定实体类的字节码 configuration.addClass(Customer.class); 4.2 SessionFactory4.2.1 作用SessionFactory接口负责Hibernate的初始化和建立Session对象。它在Hibernate中起到一个缓冲区作用，Hibernate可以将自动生成的SQL语句、映射数据以及某些可重复利用的的数据放在这个缓冲区中。同时它还保存了对数据库配置的所有映射关系，维护了当前的二级缓存。 SessionFactory 实例是通过Configuration对象获取的，其获取方法如下所示。 1SessionFactory sessionFactory = config.buildSessionFactory(); 4.2.2 常用方法1openSession()：每次都是生成一个新的Session 4.2.3 细节该对象维护了很多信息： 连接数据库的信息 hibernate的基本配置 映射文件的位置，以及映射文件中的配置 一些预定义的SQL语句（这些语句都是通用的） 比如：全字段保存，根据id的全字段更新，根据id的全字段查询，根据id的删除等等。 hibernate的二级缓存（了解） 同时，它是一个线程安全的对象，所有由该工厂生产的Session都共享工厂中维护的数据。 4.2.4 使用原则由于SessionFactory维护了很多信息同时又是线程安全的，一般情况下，一个项目中只需要一个SessionFactory，只有当应用中存在多个数据源时，才为每个数据源建立一个SessionFactory实例。因此，不应该反复的创建和销毁。 原则：一个应用应该只有一个SessionFactory。在应用加载时创建，应用卸载时销毁。 4.2.5 在hibernate中使用数据源(连接池)SessionFactory内部还维护了一个连接池，如果我们需要使用第三方的连接池如C3P0，那么需要我们自己手动进行配置 配置C3P0步骤如下： 导入连接池的jar包 在hibernate主配置文件中配置 1234&lt;!-- 配置数据源的提供商 --&gt;&lt;property name&#x3D;&quot;hibernate.connection.provider_class&quot;&gt; org.hibernate.connection.C3P0ConnectionProvider&lt;&#x2F;property&gt; 4.3 Session4.3.1 作用Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。 创建SessionFactory实例后，就可以通过它获取Session实例。获取Session实例有两种方式，一种是通过openSession()方法，另一种是通过getCurrentSession()方法。两种方法获取session的代码如下所示： 12345//采用openSession方法创建sessionSession session = sessionFactory.openSession();//采用getCurrentSession()方法创建sessionSession session = sessionFactory.getCurrentSession(); 以上两种获取session实例方式的主要区别是，采用openSession方法获取Session实例时，SessionFactory直接创建一个新的Session实例，并且在使用完成后需要调用close方法进行手动关闭。而getCurrentSession方法创建的Session实例会被绑定到当前线程中，它在提交或回滚操作时会自动关闭。 4.3.2 常用方法123456789save(Object entity); ：保存一个实体到数据库update(Object entity);：更新一个实体delete(Object entity);：删除一个实体get(Class clazz,Serializable id);：根据id查询一个实体。参数的含义：Class表示要查询的实体类字节码。Serializable就是查询的条件。beginTransaction();：开启事务，并返回事务对象 4.3.3 细节由于SessionFactory已经维护了很多数据，所以Session就维护较少的内容。 它是一个轻量级对象。并且：它不是线程安全的！！！！！！！ 它维护了hibernate的一级缓存。 它的反复创建销毁不会消耗太多资源。 4.3.4 使用原则每个线程都只有一个Session对象。 4.4 Transaction4.4.1 作用Transaction接口主要用于管理事务，它是Hibernate的数据库事务接口，且对底层的事务接口进行了封装。Transaction接口的事务对象是通过Session对象开启的，其开启方式如下所示。 1Transaction transaction &#x3D; session.beginTransaction(); 4.4.2 常用方法123commit()：提交事务rollback()：回滚事务 Session执行完数据库操作后，要使用Transaction接口的commit()方法进行事务提交，才能真正的将数据操作同步到数据库中。发生异常时，需要使用rollback()方法进行事务回滚，以避免数据发生错误。因此，在持久化操作后，必须调用Transaction接口的commit()方法和rollback()方法。如果没有开启事务，那么每个Session的操作，都相当于一个独立的操作。 123456789101112131415161718@Testpublic void testSave1() &#123; Customer c = new Customer(); c.setCustName(\"测试保存功能\"); Transaction tx = null; Session s = null; try &#123; s = HibernateUtil.openSession(); tx = s.beginTransaction(); //保存客户 s.save(c); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); &#125; finally &#123; s.close(); &#125;&#125; 5. 抽取HibernateUtil工具类1234567891011121314151617181920212223242526272829/** * hibernate的工具类 * 用于生产一个Session对象 * * @author wgy */public class HibernateUtil &#123; private static SessionFactory factory; static&#123; try &#123; Configuration cfg = new Configuration(); cfg.configure(); factory = cfg.buildSessionFactory(); &#125; catch (Exception e) &#123; //e.printStackTrace(); throw new ExceptionInInitializerError(\"初始化SessionFactory失败\"); &#125; &#125; /** * 获取一个新的Session对象 * @return */ public static Session openSession()&#123; return factory.openSession(); &#125;&#125; 6. 案例：使用Hibernate实现CRUD6.1 保存操作12345678910111213141516@Testpublic void testAdd()&#123; Customer c = new Customer(); c.setCustName(\"测试保存功能\"); //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 //Transaction tx = session.beginTransaction(); //3.保存客户 session.save(c); //4.提交事务 //tx.commit(); //5.释放资源 session.close();&#125; 6.2 查询一个实体1234567891011121314@Testpublic void testFindOne()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为2的客户 Customer c = session.get(Customer.class, 2L); System.out.println(c); //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.3 修改操作1234567891011121314151617@Testpublic void testUpdate()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为2的客户 Customer c = session.get(Customer.class, 2L); //修改客户的地址为：湖北省 c.setCustAddress(\"湖北省\"); //执行更新 session.update(c); //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.4 删除操作123456789101112131415@Testpublic void testDelete()&#123; //1.使用工具类获取一个Session Session session = HibernateUtil.openSession(); //2.开启事务 Transaction tx = session.beginTransaction(); //3.查询id为1的客户 Customer c = session.get(Customer.class, 1L); //删除实体 session.delete(c);//delete from cst_customer where cust_id = ? //4.提交事务 tx.commit(); //5.释放资源 session.close();&#125; 6.5 实体查询get和load方法6.5.1 实体查询的概念所谓实体查询即OID查询，就是使用主键作为条件来查询一个实体。其中涉及的方法是Session对象get方法和load方法。 6.5.2 方法的说明get方法： 12345678910111213141516/** * 根据id查询一个实体 * @param entityType 指的是要查询的实体类字节码对象 * @param id 查询的条件，即主键的值。 * @return 返回的是实体类对象 */&lt;T&gt; T get(Class&lt;T&gt; entityType, Serializable id);@Testpublic void testGet()&#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); Customer c = s.get(Customer.class, 2L); System.out.println(\"get : \"+c.toString()); tx.commit();&#125; load方法： 12345678910111213141516/** * 根据id查询一个实体 * @param theClass 指的是要查询的实体类字节码 * @param id查询的条件，即主键的值。 * @return 返回的是实体类对象或者是实体类对象的代理对象 */&lt;T&gt; T load(Class&lt;T&gt; theClass, Serializable id);@Testpublic void testLoad()&#123; Session s = HibernateUtil.openSession(); Transaction tx = s.beginTransaction(); Customer c = s.load(Customer.class, 2L); System.out.println(\"load : \"+c.toString()); tx.commit();&#125; 6.5.3 get和load的区别 查询的时机不一样。 get的查询时机：每次调用get方法时，马上发起查询。 立即加载 load的查询时机：每次真正使用的时候，发起查询。 延迟加载 懒加载 惰性加载 返回的结果不一样。 get方法返回的对象是实体类类型 load方法返回的对象是实体类类型的代理对象 load方法默认情况下是延迟，可以通过配置的方式改为立即加载。 12&lt;!-- 由于load方法是hibernate的方法所以只有XML的方式：--&gt;&lt;class name=\"Customer\" table=\"cst_customer\" lazy=\"false\"&gt;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://wgy1993.gitee.io/tags/Hibernate/"},{"name":"ORM","slug":"ORM","permalink":"https://wgy1993.gitee.io/tags/ORM/"},{"name":"框架","slug":"框架","permalink":"https://wgy1993.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"使用hexo+github搭建免费个人博客","date":"2020-05-15T11:40:37.000Z","path":"archives/52429b60.html","text":"前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi wgy1993! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置： 12$ git config --global user.name &quot;yourname&quot;&#x2F;&#x2F; 你的github用户名，非昵称$ git config --global user.email &quot;xxx@163.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱 具体这个配置是干嘛的我没仔细深究。 使用hexo写博客hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装1$ npm install -g hexo 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\\MyGitWorkSpace\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /e/MyGitWorkSpace/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了 浏览目录 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： 12$ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里： 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法： 1234deploy: type: git repository: git@github.com:wgy1993&#x2F;wgy1993.github.io.git branch: master 错误写法： 1234deploy: type: github repository: https:&#x2F;&#x2F;github.com&#x2F;wgy1993&#x2F;wgy1993.github.io.git branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件： 1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 保留README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 常用hexo命令常见命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写： 1234hexo n &#x3D;&#x3D; hexo newhexo g &#x3D;&#x3D; hexo generatehexo s &#x3D;&#x3D; hexo serverhexo d &#x3D;&#x3D; hexo deploy 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 写博客定位到我们的hexo根目录，执行命令： 1hexo new &#39;my-first-blog&#39; hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 那么hexo new page &#39;postName&#39;命令和hexo new &#39;postName&#39;有什么区别呢？ 1hexo new page &quot;my-second-blog&quot; 生成如下： 最终部署时生成：hexo\\public\\my-second-blog\\index.html，但是它不会作为文章出现在博文目录。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上``即可，例如： 12345678910111213# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； 最终效果：","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wgy1993.gitee.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://wgy1993.gitee.io/tags/GitHub/"}]}]